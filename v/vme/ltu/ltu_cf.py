self.baseAddr="0x810000"
self.spaceLength="0x800"
self.vmeregs=[('CODE_ADD', '0x4', ''), ('SERIAL_NUMBER', '0x8', ''), ('VERSION_ADD', '0xC', ''), ('SOFT_RESET', '0x28', ''), ('TEMP_START', '0x58', ''), ('TEMP_STATUS', '0x5c', ''), ('TEMP_READ', '0x60', ''), ('MASTER_MODE', '0x64', ''), ('LTUVERSION_ADD', '0x80', ''), ('TEST_ADD', '0xc0', ''), ('BC_STATUS', '0xc4', ''), ('ADC_SELECT', '0x4c0', ''), ('BC_DELAY_ADD', '0x4c8', ''), ('ADC_START', '0xcc', ''), ('ADC_DATA', '0xd0', ''), ('ERROR_ENABLE', '0xd4', ''), ('ERROR_STATUS', '0xd8', ''), ('ERROR_SELECTOR', '0xdc', ''), ('ERROR_DEMAND', '0xe0', ''), ('ERROR_RATE', '0x4e4', ''), ('ORBIT_CLEAR', '0xe8', ''), ('EMULATION_START', '0xec', ''), ('QUIT_SET', '0xf0', ''), ('BREAK_SET', '0xf4', ''), ('LAST_BC', '0x4f8', ''), ('PREPULSE_BC', '0x4fc', ''), ('CALIBRATION_BC', '0x500', ''), ('GAP_BC', '0x504', ''), ('ORBIT_BC', '0x508', ''), ('L1_DELAY', '0x50c', ''), ('L2_DELAY', '0x510', ''), ('TRG_TOGGLE', '0x5c4', ''), ('ORBIT_TIME', '0x5c0', ''), ('PP_TIME', '0x5c4', ''), ('TTC_DATA', '0x5c8', ''), ('RATE_LIMIT', '0x5cc', ''), ('SLM_ADD_CLEAR', '0x114', ''), ('SLM_DATA', '0x118', ''), ('EMU_STATUS', '0x11c', ''), ('START_SET', '0x520', ''), ('SOFT_TRIGGER', '0x124', ''), ('RANDOM_NUMBER', '0x528', ''), ('COUNT_PERIOD', '0x52c', ''), ('TTC_INTERFACE', '0x530', ''), ('STDALONE_MODE', '0x534', ''), ('BUSY_ENABLE', '0x138', ''), ('BUSY_STATUS', '0x13c', ''), ('SW_BUSY', '0x140', ''), ('L1_FORMAT', '0x544', ''), ('L1MAX_CLEAR', '0x148', ''), ('L2MAX_CLEAR', '0x14c', ''), ('SCOPE_SELECT', '0x550', ''), ('BACKPLANE_EN', '0x554', ''), ('MINIMAX_SELECT', '0x570', ''), ('MINIMAX_LIMIT', '0x578', ''), ('FIFO_MAX', '0x158', ''), ('SOFT_LED', '0x15c', ''), ('BUSYMAX_DATA', '0x168', ''), ('BUSYMINI_DATA', '0x16c', ''), ('MINIMAX_CLEAR', '0x174', ''), ('PIPELINE_CLEAR', '0x198', ''), ('SSMcommand', '0x19c', ''), ('SSMstart', '0x1a0', ''), ('SSMstop', '0x1a4', ''), ('SSMaddress', '0x1a8', ''), ('SSMdata', '0x1ac', ''), ('SSMstatus', '0x1b0', ''), ('TIMING_TEST', '0x1b8', ''), ('PLL_RESET', '0x1bc', ''), ('TIMING_TEST', '0x1b8', ''), ('TTC_STATUS', '0x1c8', ''), ('COPYCOUNT', '0x1d4', ''), ('COPYBUSY', '0x1d8', ''), ('COPYCLEARADD', '0x1dc', ''), ('COPYREAD', '0x1e0', ''), ('CLEARCOUNTER', '0x5ac', '')]
self.hiddenfuncs=" ADC SLM SSM EmuTests FrontPanel ExpertConf ConfiguratioH SHM Browser"
self.funcs=[['Browser', '', 'void', 'getsigSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', ''], ['bits', 'int', '']]], ['Browser', '', 'void', 'finddifSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', '']]], [None, "CTP emulator:\n- start Sequence list editor\n- load sequence list\n- set signal error rate, enable/disable errors\n  ask for 'on demand' error\n- START signal generation selection\n- start/break/quit Sequence execution\n", 'GUI', 'CTP_Emulator', [], 'CTP Emulator'], ['ConfiguratioH', '', 'void', 'prtfnames', [['directory', 'char', '*'], ['suffix', 'char', '*']]], ['ConfiguratioH', '', 'void', 'waitKB', []], ['ConfiguratioH', '', 'void', 'setglobalmode', []], ['Configuration', "Current settings are kept in shared memory and are accessible\nby ECS through ltu_proxy or by 'vmecrate -Trigger control client'.\nCurrent settings will be loaded into LTU/TTC boards:\n   - at the start of the run through ECS or \n   - by LTUinit/TTCinit buttons (TTCinit actions are \n     part of LTUinit actions)\n\nSave/Load memory buttons allows you to modify these current settings.\nDuring editing, the values different from 'default values' are shown\nwith yellow background color.\n\nLoad defaults/Save as defaults buttons allow the modification of\nsettings in database. Use 'Save as defaults' button ONLY WHEN\nYOU WANT CURRENT SETTINGS TO BE SAVED AND USED AFTER POWERING UP \nYOUR PARTITION.\nThe settings saved in database are loaded AUTOMATICALY\ninto Current settings and LTU/TTC boards (TTCvi+TTCrx chip) when\nthe crate is powered ON.\n", 'GUI', 'setCurrents', [], 'Defaults editor'], ['Configuration', '', 'GUI', 'CheckRateLimit', [], 'Rate limit'], ['ConfiguratioH', '', 'int', 'getsgmode', []], ['ConfiguratioH', 'b2: 3 ext. orbit, stdalone\n    1 int. orbit, stdalone\n    0 global mode\n', 'void', 'setstdalonemode', [['b2', 'w32', '']]], ['FrontPanel', '', 'void', 'getCounters', [['Ncounters', 'int', ''], ['accrual', 'int', ''], ['bakery_customer', 'int', '']]], ['FrontPanel', '', 'void', 'clearCounters', []], ['ConfiguratioH', "rc: Dial switch value X, (char: 0,1,...,f) i.e. it can be used to form\n    '0x1X' input string for setDestination() (see ltutmx.c)\n", 'char', 'getSwitchValue', []], ['ExpertConf', "Set (mode=1) or clear(mode=0) 'Timing test mode'.\nIn Timing test mode, L1 Data signal of the emulator\n(i.e. valid only in STDALONE) is continuously toggled.\n\nThis mode is used with another (slave) LTU, connected through\nspecial cable connecting the backplane signals of this LTU\nto its CTP inputs connector. \nSlave LTU, switched to GLOBAL, can measure\n(Configuration->ADC_Scan) delay, which should be kept with\ncurrent cabling.\n", 'void', 'TTmode', [['mode', 'int', '']]], ['ExpertConf', "Normally, destination VME address for B-channel data is\nTTCvi's 'B Channel Data for B-Go<2>' (0x80x0B8). \nInstead of TTCvi board, another LTU can become 'the receiver of\ndata sent over VME by setting destination to 0x1X \nwhere X is dial of receiving LTU.\nReceiving LTU must have its snapshot memory\nenabled for 'VME write' -> by starting setSSMVMEW() on this LTU.\n\nSet destination to 0 for normal mode of operation (with TTCvi).\n", 'void', 'setDestination', [['destination', 'w32', '']]], ['ExpertConf', "Set Snapshot memory of this LTU to 'VME write' mode. This should\nbe done before starting 'setDestination()' on another LTU board,\nredirecting MASTER vme writes to this board.\n", 'void', 'setSSMVMEW', []], ['SHM', 'rc: 0: ok\n    1: error reading counters\n', 'int', 'readCNTS2SHM', []], ['Configuration', 'Shows: status of all the signals contributing to BUSY output\nAllows: to enable/disable BUSY1, BUSY2 inputs and set/clear\n        SOFTWARE BUSY\n', 'GUI', 'CheckBusy', [], 'Check/set/reset BUSYs'], ['SimpleTests', 'Click to Stop/Start blinking\nfront panel LEDs\n  ', 'void', 'TestLEDS', []], ['SimpleTests', 'send L1h word ower B channel.\ndata: 12bits data\nwords: numbe of words to be send as quickly as possible\nMAXW: number of words to be send in one batch (after batch is sent,\n      the loop testing TTC_STATUS for empty fifo is started)\n      FIFO capacity is 128 words.\n', 'void', 'sendB', [['data', 'w32', ''], ['words', 'int', ''], ['MAXW', 'int', '']]], ['ConfiguratioH', 'Print 1 line string xxxx\nwhere x is the status (0/1) of software LED word\n', 'void', 'getSWLEDS', []], ['ExpertConf', "micsecs: time interval (in micsecs). During this time, triggers are counted\n         and compared with maxtrigs limit. Options:\n         999999    -read current micsecs/maxtrigs settings \n         209100/204700 -max. interval \n                   (any higher value results in 209100/204700).\n         Interval is set in PERIOD_STEP micsecs slots. Minimal value is 2 slots.\nmaxtrigs: max. number of triggers allowed in any time interval (set by micsecs)\n         Allowed values are: 0..63\nenadis:  1: enable, 0: disable 'rate limit' option \nRATE_LIMIT word:\n0x80000000 1:enable rate limit\n0x0000ff00 period in 0.82ms steps (255 till ver. 0xb4)\n0x0007ff00 period in 0.1ms steps (2047 - VALID from 19.7.2010, LTU ver 0xb5)\n0x0000003f limit:max number of triggers/period\n", 'void', 'RateLimit', [['micsecs', 'int', ''], ['maxtrigs', 'int', ''], ['enadis', 'int', '']]], ['SimpleTests', 'print: \nCODE_ADD       always 0x56 for LTU\nSERIAL_NUMBER  of the LTU board\nVERSION_ADD    VME FPGA version firmware\nLTUVERSION_ADD LTU FPGA version firmware\nBC_STATUS      BC ststus (should be 0x2 == PLL locked, BC ok)\n ', 'void', 'printversion', []], ['SimpleTests', 'busys      -number of busy pulses to be generated\nbusylength -length of the pulses (us)\nperiod     -time interval between pulses (us)\n', 'void', 'GenTrigBusy', [['busys', 'int', ''], ['busylength', 'int', ''], ['period', 'int', '']]], ['SLM', 'filen: see SLMload (e.g. CFG/ltu/SLM/one.seq) ', 'int', 'SLMcheck', [['filen', 'char', '*']]], ['SLM', 'read SLM and write its contents to the file WORK/slmasci\n', 'int', 'SLMdump', []], ['SLM', "SLM memory fetch sequence during emulation test: \n  execute following steps in the loop:\n- clear SLM_ADD_CLEAR\n- SLMstart()\n- SLMswstart(1,milsecs);\n- SLMwaitemuend();\nDon't start it from here, instead use:\n1.\nltu/ltu.exe -noboardInit    -> the PID appears\nSLMes(0)\n2. from independent window, issue 'kill -s USR1 PID' if necessary\n", 'void', 'SLMes', [['milsecs', 'int', '']]], ['SLM', 'break emulation. RC: EMU_STATUS immediately after break\n', 'int', 'SLMbreak', []], ['SLM', 'set BC scaled down START signal:\n0: 25ns\n0x3fffff:   ~ 0.1 secs\n0x3ffffff:  ~ 1.7 secs\n0x3fffffff: ~ 26 secs\n', 'void', 'setBCDOWN', [['bcsd', 'w32', '']]], ['SLM', 'Set random rate of automatic START signal generation\n', 'void', 'setrate', [['rndrate', 'w32', '']]], ['SLM', 'return: 0 = errors disabled, or 1 ->errors enabled ', 'int', 'getERenadis', []], ['SLM', 'return selector: bits[6:0] ', 'w32', 'ERgetselector', []], ['SLM', 'demand: bits[2:0] valid values: 1-6\n', 'void', 'ERseterrrate', [['errrate', 'w32', '']]], [None, 'Counters monitor ', 'GUI', 'Counters', [], 'Counters'], [None, '', 'GUI', 'Snapshot_memory', [], 'Snapshot Memory'], [None, 'Signal selection for front panel \nA,B outputs\n', 'GUI', 'ScopeAB', [], 'Scope Signals'], ['Configuration', 'Initialise LTU board and TTC path (TTCvi and TTCrx).\n', 'void', 'LTUinit', []], ['ExpertConf', 'Set parameter name to value\n', 'int', 'setOption', [['name', 'char', '*'], ['value', 'char', '*']]], ['Configuration', "Set 'L0 mode' :\n'L0 over fibre'         if ttcint is 8\n'L0 over cable'         if ttcint is 0\n\nThis routine sets the TTC_INTERFACE register. It calculates\n2 least sifnificant bits (from BC_DELAY_ADD register). Bits 2..3 are\ntaken from ttcint parameter.\nsetTTCint() should be invoked ALWAYS AFTER BC_DELAY_ADD change.\nThe 4 least significant bits of this register are used for setting:\n- 12.5ns delay for Orbit and/or L1\n- the polarity of L1 output      \n- 'L0 over TTC' mode\n\nTTC_INTERFACE bits:\n0  'Delay Orbit' flag. 0: no delay, 1: 12.5ns delay\n1  'Delay L1' flag. 0: no delay, 1: 12.5ns delay\n   Both bits depends on BC_DELAY_ADD.\n2   L1 polarity.    0: positive (TTCex, default)   1: negative (TTCvi)\n3  'L0 over TTC' flag. \n   0:  normal mode (only L1 as 1 bit over A-TTC channel)\n   1:  'L0overTTC' mode. In this mode: \n   - L0 is sent over coaxial cable as in normal mode. In addition,\n        it is sent over A-TTC channel as 2 bits '10' in 2 BC clocks\n   - L1 is sent as 2 bits '11' over A-TTCchannel\n", 'void', 'setTTCint', [['ttcint', 'w32', '']]], ['Configuration', 'set BC_DELAY_ADD (0..31 in ns). setTTCint is activated after BC_DELAY_ADD\nwritten.\n', 'int', 'fpgainit', []], ['Configuration', "- initialise TTCvi for operation in STANDALONE mode\n- reset TTCrx over fibre (TTCrxready goes OFF for ~6ms)\n- set Control register 3 in TTCrx (over fibre), enabling Dout strobe \n- set FineDelay1,FineDelay2 and CoarseDelay TTCrx registers \n- send FEEreset (after more than 1 second)\n- check BUSY signal and print Warnings and/or Errors:\n  Warning: BUSY is ON before TTCrx reset\n  Error: BUSY not raised during 'TTCrx READY' off\n  Warning: BUSY not raised during 'QPLL LOCKED' off (if QPLL clock is used)\n  Error: BUSY ON 10milsecs after FEEreset\n", 'int', 'TTCinit', []], ['Configuration', 'Show shared memory content. Shared memory variables can be \nmodified by Load from memory/Save buttons in Defaults editor.\nshmtemp: 1 shm    0: temp\n', 'void', 'printltuDefaults', []], ['Configuration', 'Set Prepulse delay directly on TTCvi board. \nWarning: delay is set only on TTCviboard (i.e. it is not changed\nin memory, which means, TTCinit will set it back to value\nstored in shared memory (see Defaults editor)\n', 'int', 'ttcPPdelay', [['bc', 'int', '']]], ['Configuration', 'Set delay registers directly in TTCrx, without resetting TTCrx.\nInput:\nFine1ps, Fine2ps: required Fine delays on TTCrx chip in ps\nThe coreespoding value in TTCrx registers in can be set with 104.17 ps step\n(e.g. the value corresponding to 4ps or 104 ps is equal: 0xe ) \n\nCoarse: the required content of TTCrx Coarse register\n', 'int', 'ttcDelays', [['Fine1ps', 'int', ''], ['Fine2ps', 'int', ''], ['Coarse', 'int', '']]], ['Configuration', "-send 'Front End Electronics reset command' through TTC B-channel.\n The header '0x8' is reserved for this command (e.g. 0x3 is allocated\n for L2accept header).\n", 'int', 'ttcFEEreset', []], ['Configuration', "-send 'Front End Electronics user defined command' through TTC B-channel.\nCommand: number 8-15 \n     8 already reserved for FEEreset\n 9..11 reserved for CTP\n12..15 available for subdetectors\n\n12 data bits are set to 0.\nNote: \n   0 not used\n1..7 used for L1h, L1data, L2ah, L2adata, L2r, RoIh, RoIdata\n", 'int', 'ttcFEEcmd', [['Command', 'int', '']]], ['Configuration', '', 'GUI', 'setGLOBAL', [], 'setGLOBAL'], ['Configuration', '', 'GUI', 'setSTDALONE', [], 'setSTDALONE'], ['SimpleTests', 'returns temperature on the board in centigrades (-100 if error) ', 'int', 'ReadTemperature', []], ['ConfiguratioH', '', 'int', 'getgltuver', []], ['SimpleTests', 'Return average busy time (busy/L0) during 100milsecs\n', 'int', 'measureBusy100ms', []], ['SimpleTests', 'Measure busy between 2 mouse clicks\n', 'int', 'measureBusy', []], ['SLM', '', 'void', 'SLMsetstart', [['sel', 'w32', '']]], ['SLM', '', 'int', 'SLMgetstart', []], ['SLM', '', 'int', 'SLMswstart', [['n', 'int', ''], ['milsecs', 'int', '']]], ['SLM', '', 'int', 'SLMstart', []], ['SLM', '', 'void', 'ERenadis', [['enadis', 'int', '']]], ['SLM', '', 'void', 'ERsetselector', [['selector', 'w32', '']]], ['SLM', '', 'void', 'ERdemand', [['demand', 'w32', '']]], ['SLM', '', 'int', 'SLMreadasci', [['filen', 'char', '*'], ['slmdata', 'w32', '*']]], ['SLM', '', 'int', 'SLMload', [['filen', 'char', '*']]], ['SLM', '', 'int', 'SLMquit', []], ['SLM', '', 'int', 'SLMwaitemuend', [['micsec', 'int', '']]], ['ConfiguratioH', '', 'void', 'setBUSY', [['binputs', 'w32', '']]], ['FrontPanel', '', 'void', 'setAB', [['A', 'w32', ''], ['B', 'w32', '']]], ['SSM', '', 'int', 'SSMsetom', [['opmo', 'w32', '']]], ['SSM', '', 'void', 'SSMstartrec', [['mode', 'w32', '']]], ['SSM', '', 'void', 'SSMstoprec', []], ['SSM', '', 'int', 'SSMdump', []], ['SSM', '', 'void', 'SSMschedule', [['whenmode', 'w32', '']]], ['SSM', '', 'int', 'SSMclearac', []], ['SSM', '', 'void', 'SSMclear', []], ['ADC', 'Set BC_DELAY_ADD \n- WITH TTC_INTERFACE correction (ttcint=0)\n- WITHOUT TTC_INTERFACE correction (ttcint=1)\n  16.12.2008: measured for both in the lab (for hmpid 0x811000),\n              but no difference was seen\n', 'void', 'setbcdelay', [['delay', 'w32', ''], ['ttcint', 'int', '']]], ['ADC', 'rc: 2 BC_STATUS low bits: [BC_STATUSpll, BC_STATUSerr] ', 'w32', 'getbcstatus', []], ['ADC', '', 'void', 'pllreset', []], ['ADC', 'Reads adc 300 times as quickly as possible and print it.\n', 'void', 'adcitest', []], ['ADC', 'Reads ADC checking for busy and timeout.\n', 'int', 'readadc', []], ['ADC', 'Reads ADC using readadc and checking that two subsequent values are the same.\n', 'int', 'readadc_s', []], ['ADC', 'Scan of BC delay with going from 0 to 31 \nwaiting micseconds between measurements.\nDo not change TTC_INTERFACE word during scan !\n\nThis subroutine is used with BC phase measurements i.e.\n1st line of stdout is relevant.\n', 'void', 'scan', [['micseconds', 'int', '']]], ['ADC', "Measure BC phase of this FO (ltufo=0) or this LTU (ltufo=1)\nFO:\n- arrange toggling on FO connector + global mode for this LTU\n  before calling this routine\nLTU:\n- just call this routine\nOperation:\n- check if global ( the check for toggling to be done)\n- store BC_DELAY_ADD, measure\n- restore BC_DELAY_ADD\nstdout: value of ADC (for BC_DELAY_ADD=0)\n        0      may indicate 'not toggling' for FO measurement\n        0..128 measured phase\n        256    indicates 'not global' for FO measurement (toggling not done yet)\nNOTE:\nFor FO measurement (getbcphase(0)), the change of cable length\nleads to change of phase.\n", 'void', 'getbcphase', [['ltufo', 'int', '']]], ['ADC', 'Demonstrates time constant parameters of RL element in delay line.\n', 'void', 'adctimeconst', [['delay0', 'w32', ''], ['delay1', 'w32', '']]], ['ADC', 'Generates random delays and measure adc for each of them.\nStdout:\n<delay> <adc_value>\n...\n<0.00> <4.524>\nWhere:\ndelay, adc_value: measured pairs as integers 0..31 and 0..127\nLast line: avarage wait for PLL locked\n', 'void', 'rndtest', []], ['Configuration', 'Automatic synchronisation of CTP and LTU signal transitions. \nBefore this measurement is started,\narrange the following:\n- this LTU is in GLOBAL mode\n- L1 Data signal (CTP input connector) is continuously toggled\n  by BCclock frequency/2\n', 'GUI', 'ADC_Scan', [], 'ADC_Scan']]
