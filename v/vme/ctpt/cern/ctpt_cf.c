/* generated by comp.py */
#include <stdio.h>
#include "vmewrap.h"
#include "vmeaistd.h"

char BoardName[]="ctpt";
char BoardBaseAddress[11]="0x820000";
char BoardSpaceLength[11]="0xd000";
char CTP_Classes_usagehelp[]="The Classes definition, i.e. for each (1-50) class: \n\
 -enabling/disabling\n\
 -L0,L1,L2 inputs and selectable vetos\n\
 -cluster\n\
 -L0 pre-scaler\n\
";

char CTP_Clusters_usagehelp[]="The Clusters definition, i.e. which detectors (LTUs) belong to each cluster.\n\
Cluster definition consist of 'assignment of clusters to\n\
each Fanout connector'.\n\
";

char Resources_usagehelp[]="The Shared resources definition. They are:\n\
- random generators(2) and BC generators(2) rates\n\
- 3 Interaction functions (16 bits lookup tables)\n\
- 2 L0 input functions (16 bits lookup tables)\n\
- 2 Interaction selectors\n\
- All/Rare events CTP option\n\
- 5 Past/Future protection circuits for all trigger levels \n\
    (PF1-PF4 for physics and PF5 for Test Class)\n\
";

char Counters_usagehelp[]="Displays counters on all CTP boards\n\
";

char CheckTestClass_usagehelp[]="Test class control.\n\
";

char ScopeAB_usagehelp[]="Signal selection for front panel \n\
A,B outputs\n\
";

char SSMbrowser_usagehelp[]="Browse CTP snapshot memories \n\
";

char SSMcontrol_usagehelp[]="The CTP snapshot memories control\n\
";

Tpardesc checkScopeBoard_parameters[1]={
{"ab", 3}};
char checkScopeBoard_usagehelp[]="rc: the number of the board (0-10) which has its ab output enabled\n\
    -1 if there is no enabled board\n\
Note: by running this subroutine, all boards are checked, and\n\
      if there is more 'enabled' boards then 1, they are disabled\n\
      (but the first enabled one)\n\
";

Tpardesc setScopeBoard_parameters[2]={
{"ab", 3},
{"board", 1}};
char setScopeBoard_usagehelp[]="Enable 1 board scope output.\n\
rc: the number of the board (0-10) which has its ab output enabled\n\
    -1 if there is no enabled board\n\
Note: by running this subroutine, all boards are checked, and\n\
      if there is more 'enabled' boards then 1, they are disabled\n\
      (but the first enabled one)\n\
";

Tpardesc getScopeSignal_parameters[2]={
{"board", 1},
{"ab", 3}};
char getScopeSignal_usagehelp[]="rc: the number of the signal choosen for this board's ab output\n\
    0x1000+0..31  -> Abis signals\n\
    0x100 +0..31  -> Bbis signals\n\
";

Tpardesc setScopeSignal_parameters[3]={
{"board", 1},
{"ab", 3},
{"signal", 1}};
char setScopeSignal_usagehelp[]="signal: 0x1000+0..23  -> Abis signals\n\
        0x100 +0..23  -> Bbis signals\n\
rc: the number of the signal choosen for this board's ab output\n\
    -1 in case of error\n\
";

char getVMERWScope_usagehelp[]="rc: word with the bits corresponding to CTP boards in VMERW-Scope mode\n\
    0 -no board in VMERW-Scope mode\n\
    0x7ff -all boards in VMERW-Scope mode\n\
";

Tpardesc setVMERWScope_parameters[2]={
{"newv", 2},
{"oldv", 2}};
char setVMERWScope_usagehelp[]="newv: new settings     oldv: old settings\n\
";

char SaveFile_usagehelp[]="- Save configuration to WORK/.cfg configuration to file\n\
";

char LoadFile_usagehelp[]="- Load configuration from WORK/.cfg configuration to file\n\
Todo:\n\
- check hw configuration with the memory-configuration\n\
- Load (i.e. add) partition configuration (i.e. from .configuration\n\
  file prepared by partition editor)\n\
";

char Readhw_usagehelp[]="- Load configuration from CTP boards\n\
";

char Write2hw_usagehelp[]="- Write configuration into CTP boards\n\
";

char readORBIT_READs_usagehelp[]="read/print 2 counters: L2_ORBIT_READ and INT_ORBIT_READ ";

Tpardesc i2cread_parameters[2]={
{"channel", 1},
{"branch", 1}};
char i2cread_usagehelp[]="read voltages from 1 board.\n\
channel: 0-7\n\
branch:  0-7  ";

Tpardesc setClusters_parameters[8]={
{"daqbsy", 2},
{"tc", 2},
{"c1", 2},
{"c2", 2},
{"c3", 2},
{"c4", 2},
{"c5", 2},
{"c6", 2}};
char setClusters_usagehelp[]="Set daqbsy, T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board\n\
";

char getClusters_usagehelp[]="Read T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board and print it as 1 line\n\
";

char getDAQbusy_usagehelp[]="Read DAQ_BUSY word ";

Tpardesc getFO_parameters[1]={
{"ix", 1}};
char getFO_usagehelp[]="ix: FO1BOARD..FO1BOARD+5   (6 FO boards)\n\
always read FO board's CLUSTER, TEST_CLUSTER words\n\
STDOUT:\n\
- no output                if ix FO is not in the crate\n\
cluster testcluster        for FO in the crate\n\
";

Tpardesc setFO_parameters[3]={
{"ix", 1},
{"cluster", 2},
{"tcluster", 2}};
char setFO_usagehelp[]="write to FO board's registers only if modified\n\
ix: FO1BOARD..FO1BOARD+5   (i.e. 5-10, 6 FO boards)\n\
";

Tpardesc setFOrocs_parameters[2]={
{"calflag", 1},
{"roc", 2}};
char setFOrocs_usagehelp[]="set cal. flag and roc on ALL the FO boards\n\
";

Tpardesc swtrigger_parameters[1]={
{"ssm", 1}};
char swtrigger_usagehelp[]="Start SW trigger.\n\
Input:\n\
ssm: 1   ->start SSM recording in L0 output moinitoring mode before\n\
           starting trigger\n\
Operation:\n\
- clear flags\n\
- start SSM (optionally)\n\
- start sw trigger\n\
- usleep(200) -micsecs\n\
- read L0_TCSTATUS word\n\
Output:\n\
L0_TCSTATUS word\n\
ToDo: -for whic detector? \n\
      - ROC bits to be written to FO and INT board\n\
";

char getTCSTATUS_usagehelp[]="ret: TCSTATUS bits from L0,1,2 boards:\n\
Bits:\n\
4-0  L0_TCSTATUS bits\n\
5    L1_TCSTATUS bit3 (L1ack flag)\n\
7-6  L2_TCSTATUS bits (L2Aack and L2Rack)\n\
";

char getTCSET_usagehelp[]="ret: TC_SET bits from L0,1,2 boards:\n\
Bits:\n\
18-0  L0_TC_SET bits\n\
19   L1_TC_SET bit18 (P/F veto)\n\
20   L2_TC_SET bit24 (P/F/veto)\n\
";

Tpardesc setTCSET_parameters[2]={
{"tcset012", 2},
{"dets", 2}};
char setTCSET_usagehelp[]="tcset012 -extended mening (bits 18,19 -see getTCSET() )\n\
";

char clearTC_usagehelp[]="operation: clear TC flags on all the boards\n\
";

Tpardesc getClass_parameters[1]={
{"klas", 1}};
char getClass_usagehelp[]="klas: 1-50   -class number\n\
get L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n\
    L1_DEFINITION L1_INVERT L2_DEFINITION words for klas\n\
\n\
L0_INVERT, L1_INVERT are 0:for classes 1-44 or \n\
corresponding board is not in the crate\n\
";

Tpardesc setClass_parameters[8]={
{"klas", 1},
{"condition", 2},
{"invert", 2},
{"veto", 2},
{"scaler", 2},
{"l1def", 2},
{"l1invert", 2},
{"l2def", 2}};
char setClass_usagehelp[]="set L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n\
    L1_DEFINITION L1_INVERT L2_DEFINITION\n\
words for klas (1..50)\n\
ATTENTION: \n\
1. bit17 (0x10000) of veto is CLASS MASK bit written into bit0 of L0_MASK\n\
2. invert,l1invert -valid only for class>=45\n\
";

char disableClasses_usagehelp[]="disable all 50 classes, i.e.:\n\
- set all inputs,vetos as dontcare for all 50 classes i.e.:\n\
L0_CONDITION = 0xffffffff\n\
L0_VETO      = 0xfffffff0   (cluster0)\n\
and 0x0 in:\n\
L0_INVERT   =0\n\
L0_PRESCALER=0\n\
";

char hw2rates_usagehelp[]="read all rates (scalers) from hw to Klas structure\n\
";

char rates2hw_usagehelp[]="write all rates (scalers) from Klas structure to hw\n\
";

char getShared_usagehelp[]="get rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2 INTSEL1 INTSEL2 allrare\n\
";

Tpardesc setShared_parameters[9]={
{"r1", 2},
{"r2", 2},
{"bs1", 2},
{"bs2", 2},
{"int1", 2},
{"int2", 2},
{"intt", 2},
{"l0fun1", 2},
{"l0fun2", 2}};
char setShared_usagehelp[]="set rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2\n\
";

Tpardesc setShared2_parameters[2]={
{"intsel", 2},
{"allrare", 2}};
char setShared2_usagehelp[]="set INTERACTSEL ALL_RARE_FLAG\n\
";

Tpardesc clearSPY_parameters[1]={
{"board", 1}};
char clearSPY_usagehelp[]="check spy memory (256 words from 0x9400 on L0 board )\n\
Operation: \n\
- write a, a+1 a+2 ... \n\
- read back and check\n\
- write 0s to all the 256 words\n\
";

char getBCmasks_usagehelp[]="read BC masks from HW and print out 3564 4bits words\n\
";

char setBCmasks_usagehelp[]="set BC masks in HW from input line containing 3564 hexa-chars.\n\
";

Tpardesc checkBCmasks_parameters[2]={
{"ntimes", 1},
{"words", 1}};
char checkBCmasks_usagehelp[]="set/read/check ntimes\n\
words: if 0 than checj whole BCmask memory (3564)\n\
";

Tpardesc getPF_parameters[1]={
{"ix", 1}};
char getPF_usagehelp[]="get PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
";

Tpardesc getPFc_parameters[2]={
{"ix", 1},
{"circ", 1}};
char getPFc_usagehelp[]="get PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
O: on stdout: 3 hexadecimal numbers: PFBLOCK_A, PFBLOCK_B, PFLUT\n\
";

Tpardesc setPF_parameters[2]={
{"ix", 1},
{"pfc", 2}};
char setPF_usagehelp[]="set PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
pfc: PF_COMMON word\n\
";

Tpardesc setPFc_parameters[5]={
{"ix", 1},
{"circ", 1},
{"A", 2},
{"B", 2},
{"LUT", 2}};
char setPFc_usagehelp[]="set PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
A, B, LUT -3 words to be written\n\
";

char testSYNCH_usagehelp[]="1. Prepare 24 input signals in SSM, start it in continuous input generator mode.\n\
2. set step by step (keep 1 sec delay between settings) all 24 SYNCH_ADD\n\
   from 0 to 15\n\
";

Tpardesc testBCDELAY_parameters[1]={
{"steps", 1}};
char testBCDELAY_usagehelp[]="Set BC_DELAY from 0..31 with step 1, wait 1 sec between\n\
steps: number of steps (0..34)\n\
";

Tpardesc setOrbitBChalf_parameters[1]={
{"bit8", 1}};
char setOrbitBChalf_usagehelp[]="set Orbit on backplane to BC/2 signal.\n\
bit8: 1 ->set toggling     0->disable toggling\n\
Necessary for delay measurement on l0/l1/l2 board.\n\
";

Tpardesc micsleep_parameters[1]={
{"mics", 1}};
char micsleep_usagehelp[]="Wait mics microeconds (using system usleep() call) ";

char initmain_usagehelp[]="   rc: 0 -board ix is in the crate \n\
       1 -board ix is not in the crate\n\
";

Tpardesc getPFHW_parameters[2]={
{"board", 1},
{"ipf", 1}};
char getPFHW_usagehelp[]="--------------------------------------getPFHW()\n\
 ";

char printPFHW_usagehelp[]="-----------------------------------------------------printPFHW()\n\
 ";

Tpardesc printPFHWs_parameters[1]={
{"board", 1}};
char printPFHWs_usagehelp[]=" * Read HW from board and prints\n\
";

Tpardesc setPFHW_parameters[2]={
{"board", 1},
{"ipf", 1}};
char setPFHW_usagehelp[]=" * Write current HardWare PF to board\n\
 ";

char readHWL1class_usagehelp[]="--------------------------------------------------------readHWL1class\n\
";

char printHWL1class_usagehelp[]="-------------------------------------------------------printHWL1class\n\
";

Tpardesc L2a2Interface_parameters[3]={
{"boardl1", 1},
{"boardl2", 1},
{"boardint", 1}};
char L2a2Interface_usagehelp[]="-----------------------------------------------L2a2Interface()\n\
 *  analyze interface board data\n\
 *  L2alist - list of CTP readout from L2 board\n\
 *  INTlist - list of CTP readout and IR data from Interface board\n\
 ";

Tpardesc dumpIntSsm_parameters[1]={
{"board", 1}};
char dumpIntSsm_usagehelp[]="--------------------------------------------------dumpINTSSM()\n\
 * Dumps Interface board ssm. Word is in output if any bit nonzero.\n\
 * SSM should be read before !\n\
 ";

Tpardesc dumpL2amesage_parameters[1]={
{"board", 1}};
char dumpL2amesage_usagehelp[]=" * get L2 message\n\
 ";

Tpardesc mysleep_parameters[1]={
{"delta", 2}};
Tpardesc setswtrig_parameters[3]={
{"trigtype", 3},
{"BC", 2},
{"detectors", 2}};
char setswtrig_usagehelp[]="--------------------------------------------------setswtrig\n\
 Set asynchr. sw trigger\n\
 trigtype: 'a' - asynchronous\n\
           's' - synchronous, noncalibration\n\
           'c' - callibration\n\
 BC : BC for synchronous trigger\n\
";

char clearflags_usagehelp[]="--------------------------------------------clearflags()\n\
 * Clear flags on all levels\n\
";

Tpardesc swtrginf_parameters[3]={
{"trigtype", 3},
{"BC", 2},
{"detectors", 2}};
char swtrginf_usagehelp[]="   Generate infinite loop of software triggers\n\
   Code same as swtrg\n\
   trigtype:\n\
             'c' - calibration\n\
             's' - synchronous\n\
             'a' - asynchronous\n\
   BC : bunch crossing for the case of 'c' and 's'\n\
   detectors: integer for detectorcode=list of detectors in CTPreadout\n\
";

Tpardesc swtrg_parameters[4]={
{"n", 1},
{"trigtype", 3},
{"BC", 2},
{"detectors", 2}};
char swtrg_usagehelp[]="   Generate n swtrig sequence\n\
   if n=0 -> infinite loop (dont run in graph mode)\n\
   trigtype:\n\
             'c' - calibration\n\
             's' - synchronous\n\
             'a' - asynchronous\n\
   BC : bunch crossing for the case of 'c' and 's'\n\
   detectors: integer for detectorcode=list of detectors in CTPreadout\n\
";

char gettableSSM_usagehelp[]="return the names+modes of SSMs for present boards:\n\
stdout:\n\
name1 mode1 \n\
name2 mode2 \n\
...\n\
mode -mode of the ssm or:\n\
      _nomode if sms[ix].mode is epmty string\n\
      notin  board is not in the crate\n\
      nossm  if board or sms[ix].sm==NULL\n\
";

Tpardesc getsfSSM_parameters[1]={
{"board", 1}};
char getsfSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

char getsyncedSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

Tpardesc getsigSSM_parameters[4]={
{"board", 1},
{"bit", 1},
{"frombc", 1},
{"bits", 1}};
char getsigSSM_usagehelp[]="Extract 1 signal to stdout:\n\
Input:\n\
board:   (0...) according to sms global array\n\
bit:     SSM bit (0-31)\n\
frombc: bc number. \n\
         0 corresponds to word with address sms[board].offset\n\
bits:    number of bits to be examined (but don't print more then\n\
         102 lines)\n\
Output:\n\
value_of_the_1st_bit      or <0 if error\n\
bit_number_for_which_value_changed\n\
bit_number_for_which_value_changed\n\
...\n\
Errors:\n\
-1 -> required SSM not read\n\
";

Tpardesc finddifSSM_parameters[3]={
{"board", 1},
{"bit", 1},
{"frombc", 1}};
char finddifSSM_usagehelp[]="Find signal change.\n\
Input:\n\
board,bit,frombc: as in getsigSSM()\n\
Output (on stdout):\n\
-1 -signal does not change (or memory not accessible)\n\
n  - pointing to the last bit with the same value, next bit\n\
     is different\n\
";

Tpardesc getoffsetSSM_parameters[1]={
{"board", 1}};
char getoffsetSSM_usagehelp[]="print sms[board].offset\n\
";

Tpardesc setoffsetSSM_parameters[2]={
{"board", 1},
{"newoffset", 1}};
char setoffsetSSM_usagehelp[]="set sms[board].offset\n\
";

Tpardesc setmodeSSM_parameters[3]={
{"board", 1},
{"newmode", 3| 0x80000000},
{"ltubase", 3| 0x80000000}};
char setmodeSSM_usagehelp[]="set sms[board].mode, ltubase\n\
board: 0..  index into sms[]\n\
newmode: file name in CFG/ctp/ssmsigs without .sig suffix\n\
ltubase: valid only for ltu (board>10)\n\
";

char printsms_usagehelp[]="set sms[board].offset\n\
";

Tpardesc getswSSM_parameters[1]={
{"board", 1}};
char getswSSM_usagehelp[]="-------------------------------------------------------------- getswSSM() \n\
return status word of SSM\n\
LTU: [4] FrontPanel->SSM mode active\n\
     [3] not used\n\
     [2] BUSY bit\n\
     [1..0] operation\n\
CTP: [8] -BUSY\n\
     [7..6] Enable SSM Input..Output flag\n\
     [5..4] ConfSel bits\n\
     [3..3] InOut flag   0:out   1:in\n\
     [2..1] Operation bits \n\
     [0..0] mode bit \n\
error: 0xdeadbeaf\n\
";

Tpardesc setsmssw_parameters[2]={
{"ix", 1},
{"newmode", 3| 0x80000000}};
char setsmssw_usagehelp[]="-------------------------------------------------------------- setsmssw() \n\
set sms[].mode\n\
";

Tpardesc setomSSM_parameters[2]={
{"board", 1},
{"opmo", 2}};
char setomSSM_usagehelp[]="Set operation & mode. If SSM is BUSY, an attempt is made to stop\n\
the recording.\n\
Input parameteres:\n\
board -number of the board (index into global sms array) \n\
       0..NSSMBOARDS    (busy,L0,1,2,int,fo1,2,3,4,5,6,ltu1,2,3,4)\n\
opmo  -mode/operation bit for SSMcommand word. symbolic names \n\
       are defined in ctp.h (as SSMom*)\n\
\n\
opmo for LTU boards:\n\
--------------\n\
0x0 -VME access, read\n\
0x1 -VME access, write\n\
0x2 -RECORDING, After  (cca 26 milsec)\n\
0x3 -RECORDING, Before (should be stopped by SSMstoprec)\n\
\n\
Bit opmo[4] (0x10) should be set to 1 for LTU/RECORDING mode\n\
    (new feature 'FrontPanel->SSM' introduced for LTU 7.10.2005)\n\
    If not set, signals from LTU-FPGA will be recorded.\n\
\n\
opmo for CTP boards:\n\
--------------\n\
The codes above (0-3) are valid, in addition 7 bits (opmo[9..3] are\n\
meaningfull, and 2 more codes are added:\n\
0x4 - GENERATING, single pass\n\
0x5 - GENERATING, continuous\n\
opmo[9..8] - bits to be used for selecting SSMenable word\n\
             10 ->enable Input    01 ->enable Output\n\
opmo[7..6] - not used\n\
opmo[5..4] - ConfSel bits  (defined in \n\
               $VMECFDIR/CFG/ctp/ssmsigs/.sig files)\n\
opmo[3]      - InOut flag   1:in   0:out (side of FPGA logic)\n\
Examples: \n\
0x20d - generate continuously  inputs for board logic\n\
0x20c - generate 1 pass (27ms) inputs for board logic\n\
0x102 - record   1 pass (27ms) of board logic outputs\n\
RC:  0->ok, mode set\n\
     1->mode not set, possible errors (printed to stdout):\n\
        -BC signal not connected\n\
        -Cannot stop recording operation\n\
     2->bad mode for LTU board\n\
";

Tpardesc startSSM1_parameters[1]={
{"board", 1}};
Tpardesc stopSSM_parameters[1]={
{"board", 1}};
char stopSSM_usagehelp[]="------------------------------------------------------- stopSSM()\n\
Opearation:\n\
- check if board is in BUSY status\n\
- stop (recording or generation)\n\
rc: == 0 OK\n\
       1 board not busy, no action\n\
       2 problem with openvme for LTU\n\
";

Tpardesc readSSM_parameters[1]={
{"board", 1}};
char readSSM_usagehelp[]="--------------------------------------------------------- readSSM()\n\
read whole SSM into array of unsigned ints\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
Output:\n\
rc:  0 SSM read into sms[board].sm->\n\
";

Tpardesc writeSSM_parameters[1]={
{"board", 1}};
char writeSSM_usagehelp[]="------------------------------------------------------ writeSSM()\n\
write whole sms[].sm into hardware\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
";

Tpardesc dumpSSM_parameters[2]={
{"board", 1},
{"fname", 3| 0x80000000}};
char dumpSSM_usagehelp[]="------------------------------------------------------ dumpSSM()\n\
write whole sms[].sm into hardware\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
";

Tpardesc printSSM_parameters[2]={
{"board", 1},
{"fromadr", 1}};
char printSSM_usagehelp[]="print to stdout SSM board from word 'fromadr'\n\
";

Tpardesc readSSMDump_parameters[2]={
{"board", 1},
{"filename", 3| 0x80000000}};
char readSSMDump_usagehelp[]=" Read binary dump written by dumpSSM() to the sms[board].sm\n\
";

Tpardesc readL0count_parameters[2]={
{"board", 1},
{"readHW", 1}};
char readL0count_usagehelp[]="------------------------------------------------readL0count()\n\
 *  1= BUSY\n\
 *  0= ok\n\
 *  redaHW =1 : reads Counters\n\
 *          0 : reads only memory\n\
 ";

Tpardesc printL0count_parameters[1]={
{"board", 1}};
char printL0count_usagehelp[]="-----------------------------------------------printL0count()\n\
 ";

Tpardesc readHWrate_parameters[1]={
{"board", 1}};
char readHWrate_usagehelp[]="-----------------------------------------readHWrate()\n\
 * Reads down sacle factors for every class\n\
 ";

Tpardesc printHWrate_parameters[1]={
{"boards", 1}};
char printHWrate_usagehelp[]="-----------------------------------------printHWrate()\n\
 * Prints presacling factors.\n\
 ";

Tpardesc setRate_parameters[2]={
{"class", 1},
{"rate", 2}};
char setRate_usagehelp[]="-----------------------------------------setRate()\n\
 *  Set rate for class i. 1st class: i=0; \n\
 *  Writes to cpu memory.\n\
 ";

Tpardesc writeHWrate_parameters[1]={
{"board", 1}};
char writeHWrate_usagehelp[]="-----------------------------------------writeHWrate()\n\
 * Writes pre scaling factors to board\n\
 ";

Tpardesc readHWL0class_parameters[1]={
{"board", 1}};
char readHWL0class_usagehelp[]="------------------------------------------------------readHW()\n\
 * Reads Class L0 trigger definition from hardware.\n\
";

Tpardesc printHWL0class_parameters[1]={
{"board", 1}};
char printHWL0class_usagehelp[]="------------------------------------------printHWL0class\n\
 * Print L0 class HW settings\n\
";

Tpardesc testRate_parameters[4]={
{"board", 1},
{"overflow", 1},
{"rate", 1},
{"downscale", 1}};
char testRate_usagehelp[]="-----------------------------------------------------testRate()\n\
 ";

Tpardesc L0classoutmonT_parameters[4]={
{"board", 1},
{"cptdt", 1},
{"l0strobe", 1},
{"chan", 1}};
char L0classoutmonT_usagehelp[]="--------------------------------------------------------L0outmon\n\
 * Cluster emulation in outmon mode\n\
 * What is this ?\n\
";

Tpardesc notInCrate_parameters[1]={
{"ix", 1}};
Tpardesc getCounter_parameters[2]={
{"board", 1},
{"reladr", 1}};
Tpardesc getCounters_parameters[1]={
{"accrual", 1}};
char README_usagehelp[]=" Algorithm(1):\n\
  - write to generating board simple pattern: e.g.1000100010001...\n\
  - start receiving board\n\
  - start generating board\n\
  - wait\n\
  - stop all boards\n\
  This fails often due to the wrong bits either at the begining of \n\
  recording in ssmssm or start of generation. \n\
  SO BEFORE CLAIMING WRONG CONNECTION CHECK IT. \n\
  You will see inapropriate bit at the beginning of ssm or at the begining\n\
  of recording.\n\
  To avoid this problem a new algoritm was introduced.\n\
  Algoritm (2):\n\
  - write to the generating board any pattern (even more complcated) BUT\n\
    its length should be divider if the ssm size, i.e multiple of 2.\n\
  - start generating ssm in continuous mode\n\
  - start receiving board \n\
  - stop boards\n\
  By this you avoid problem with the start of generation errors\n\
";

Tpardesc FOLTUConnection_parameters[1]={
{"ltu", 1}};
char FOLTUConnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Connections between FO -> LTUs.\n\
 * FO2LTU() -- ltu1 = top connector -> first in parameters !!!\n\
 * FO mode\n\
 ltu = 11 : 0x811000 tested\n\
     = 12 : 0x812000 testes\n\
";

char FOL0L1mode_usagehelp[]=" * ------------------------------------------------------------------\n\
 * FO L0/L1 logic\n\
 * FO: generates PP,L0,L1,L1data\n\
 * LTU: receives PP,L0,L1,L1data\n\
 * FO2LTU() -- ltu1 = top connector -> first in parameters !!!\n\
 * FO mode\n\
 * RULE for FO->LTU CABLE CONNECTIONS:\n\
 * the lowest LTU VME dial goes to top FO connector(=ltu1)\n\
 * RULE for BUSY CABLE CONNECTIONS:\n\
 * the ltu1 = 1st busy input\n\
";

char FOL2mode_usagehelp[]=" * ------------------------------------------------------------------\n\
 * FO L2 logic\n\
 * FO: Generates L2strobe,L2Data1,L2Data2\n\
 * LTU: receives L2strobe, L2data/\n\
 * FO2LTU() -- ltu1 = top connector -> first in parameters !!!\n\
 * FO mode\n\
";

char L0FOconnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0->FO connection\n\
 * L0 generates: l0clstt,l0clst[6..1],l0strobe,l0data,pp,int[2..1]\n\
 * F0 receives: l0clstt,l0clst[6..1],pp at input\n\
 *              l0data,int are on other board\n\
 *              pp[4..1],l0[4..1] at output\n\
 *              \n\
 * L0 mode             \n\
";

char L0FOconnection2_usagehelp[]=" * Different way of connection test:\n\
  - generating board go to continuous\n\
 * L0 mode\n\
";

char L0L1connection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0->L1 connection\n\
 * L0 mode\n\
 ";

char L0L2connection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0->L2 connection\n\
 * L0 mode\n\
 ";

char L0INTconnection_usagehelp[]=" *------------------------------------------------------------------\n\
 * L0->INT connections\n\
 * L0 mode\n\
 ";

char L0ingener_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0 class logic NOT FINISHED\n\
 * L0 generates: l0clstt,l0clst[6..1],l0strobe,l0data,pp,int[2..1]\n\
 * F0 receives: l0clstt,l0clst[6..1],pp at input\n\
 *              l0data,int are on other board\n\
 *              pp[4..1],l0[4..1] at output\n\
 * L0 mode     \n\
";

char L0outmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Output Monitor mode\n\
 *  Start L0 in recording mode and read SSM to memory.\n\
 *  L0 mode\n\
 ";

char L0inmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Input Monitor mode\n\
 *  Start L0 in recording mode and read SSM to memory.\n\
 *  L0 mode\n\
 ";

Tpardesc L0testPF_parameters[10]={
{"tha1", 2},
{"tha2", 2},
{"thb1", 2},
{"thb2", 2},
{"deltaTa", 2},
{"deltaTb", 2},
{"sbc1", 2},
{"resa", 2},
{"resb", 2},
{"lut12D", 2}};
char L0testPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  Output Monitor mode: testing L0 PF\n\
 *  Input: almost all p/f settings\n\
 *  Set HW according to input\n\
 *  Examples with SB: \n\
 *            th=1,deltaT=4,sbc1=3,res=0\n\
 *            th=1,deltaT=3,sbc1=6,res=1\n\
 *            th=1,deltaT=2,sbc1=7,res=2\n\
 *            th=1,deltaT=5,sbc1=10,res=1\n\
 *  L0 mode\n\
";

Tpardesc L0testPF2_parameters[1]={
{"ipf", 1}};
char L0testPF2_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Output Monitor mode: testing L0 PF\n\
 *  Input: ipf : circuit\n\
 *  Read HW settings from HW !\n\
 *  Examples with SB: \n\
 *            th=1,deltaT=4,sbc1=3,res=0\n\
 *            th=1,deltaT=3,sbc1=6,res=1\n\
 *            th=1,deltaT=2,sbc1=7,res=2\n\
 *            th=1,deltaT=5,sbc1=10,res=1\n\
 *  L0 mode\n\
";

Tpardesc L0rndPF_parameters[1]={
{"ipf", 1}};
char L0rndPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Output Monitor mode: testing L0 PF by random HW settings\n\
 *  L0 mode\n\
";

char L0rndallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  Output Monitor mode: testing all 5 L0 PF by random HW settings\n\
 *  L0 mode\n\
";

char L0classlogic_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 class logic\n\
 *  Classes generated by BC downscale or RND\n\
 *  AJ version exists\n\
 *  L0 mode\n\
";

Tpardesc L1testPF2_parameters[1]={
{"ipf", 1}};
char L1testPF2_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 generates int1/int2 in outgen mode by user defined sequence !\n\
 * L1 outmon getting p/f\n\
 * L2 inmon getting int1/int2\n\
 * L0 mode\n\
 ";

char L1classlogic2_usagehelp[]=" *------------------------------------------------------------------\n\
 * L1 class logic testing\n\
 * L0 generates in L0 outgen\n\
 * L1 inmon, L2 inmon\n\
 * L0 mode\n\
";

char L1ingener_usagehelp[]=" * ------------------------------------------------------------------\n\
 * check if necessary     \n\
";

char L1outmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L1 Output Monitor mode\n\
 *  Start L1 in recording mode and read SSM to memory.\n\
 *  L1 mode\n\
 ";

char L1inmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L1 Input Monitor mode\n\
 *  Start L1 in recording mode and read SSM to memory.\n\
 *  L1 mode\n\
 ";

char L1ingen_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 Input genereting mode\n\
 * L1 mode\n\
";

char L1L2Connect_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1->L2 connection\n\
 * L1 mode\n\
 ";

char L1FOconnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1-> FO connection\n\
 * L1 mode\n\
 ";

char L1INTconnection_usagehelp[]=" * L1-> FO connection\n\
 * L1 mode\n\
 ";

char L2classlogic_usagehelp[]=" * L2 class logic testing\n\
 * L1 outgen generates l1 strobe and l1data\n\
 * L2 outmon monitors l2 strobe and l2 data\n\
 * L1 mode\n\
 ";

Tpardesc L1testPF3_parameters[1]={
{"ipf", 1}};
char L1testPF3_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 board generating int1,int2 by BC down or RND\n\
 * L0 ssm outmon giving int2,int1\n\
 * L1 ssm outmon giving pf\n\
 * none mode\n\
 ";

Tpardesc L1testPF4_parameters[1]={
{"ipf", 1}};
char L1testPF4_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 board generates int1/2 by BC down or RND\n\
 * L1 board ssm gives inta/b/d -> pf1\n\
 * All analysis on L1 board ssm\n\
 * L1 mode\n\
 ";

char L1rndallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 board generates int1/2 by BC down or RND\n\
 * L1 board ssm gives inta/b/d -> pf1\n\
 * All analysis on L1 board ssm\n\
 * L1 mode\n\
 ";

char L1classlogic_usagehelp[]=" * L1 class logic testing\n\
 * L1 ingen generates l0strobe and l0 data\n\
 * L2 unmon monitors l1 strobe l1 data\n\
 ";

char L2FOconnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L2->FO connection\n\
 * L2 mode\n\
 ";

char L2INTconnection_usagehelp[]=" * L2->INT connection\n\
 * L2 mode\n\
 ";

char L2INT_usagehelp[]=" *------------------------------------------------------------------\n\
 * Testing interface board\n\
 * L2 generates l2a in outgen mode. \n\
 * The correct content of the l2 ssm should be recorded in advance\n\
   It is not going to work:\n\
                    - generation is not stopped when ctp_busy\n\
                    - I cannot enable dll just after ssm start due to sw\n\
   I go via macro\n\
 * L2 mode\n\
 ";

char L2rndallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L2 P/F testing:\n\
 * L0 board generates int1/2 by BC down or RND\n\
 * L2 board ssm gives inta/b/d -> pf1\n\
 * All analysis on L2 board ssm\n\
 * L2 mode\n\
 ";

char L2classlogic2_usagehelp[]=" *-------------------------------------------------------------------\n\
 * L2 class logic testing\n\
 * L2 ingen \n\
 * FO inmon\n\
 * this can be done via script also\n\
";

Tpardesc L2testPF3_parameters[1]={
{"ipf", 1}};
char L2testPF3_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L2 P/F testing:\n\
 * L0 board generating int1,int2 by BC down or RND\n\
 * L0 ssm outmon giving int2,int1\n\
 * L2 ssm outmon giving pf\n\
 * none mode\n\
 ";

char L0outL1inL2in_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 inmon,L2 inmon\n\
 * none mode\n\
 ";

char L0outL1outL2out_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 outmon,L2 outmon\n\
 * none mode\n\
 ";

char L0outL1outL2outFOLTU_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 outmon,L2 outmon,FO\n\
 * L0 mode\n\
 ";

char L0outL1outL2outBusy_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 outmon,L2 outmon,Busy\n\
 * none mode\n\
 ";

char L0inBUout_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 inmon, busy outmon\n\
 * none mode\n\
 ";

char MonallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor all PF at L0,L1,L2\n\
 * none mode\n\
 ";

char FOL1mon_usagehelp[]=" * -----------------------------------------------------------------\n\
 * L2 monitor mode on FO\n\
 * none mode\n\
 ";

char FOLTU_usagehelp[]=" *none mode\n\
";

char L2a2INT_usagehelp[]=" *-------------------------------------------------------------------\n\
 * L1 outmon for int1,int2\n\
 * L2 outmon for L2data1,L2data2\n\
 * INT outmon for CTP readout\n\
 * Compares L2 serial data woth CTP readout\n\
 * interaction record may be added\n\
 * none mode\n\
";

char dumpINTSSM_usagehelp[]=" * Dump Interface SSM to file IntDump.txt\n\
 ";

char checkORBIT_usagehelp[]=" * Create INT list and save it to IntList.txt\n\
 ";

char BUconnect_usagehelp[]=" * BUSY connections\n\
 * busy mode\n\
 ";

char INTL0connection_usagehelp[]=" * INT->L0 connection (only ctp_busy)\n\
 * int mode\n\
 ";

Tpardesc Comp2Channels_parameters[3]={
{"board1", 1},
{"chan", 1},
{"start", 1}};
char Comp2Channels_usagehelp[]=" * Compares 2 channels in the snapshot memory\n\
 ";

char CompallPF_usagehelp[]=" * Compares one by one all pf chanels (14-18)\n\
 ";

char DebugSync_usagehelp[]="-----------------------------------------------------------\n\
Debugging sync by generating ssm in memory.\n\
 ";

Tpardesc genSeq_parameters[3]={
{"board", 1},
{"Period", 1},
{"Start", 1}};
char genSeq_usagehelp[]=" * ---------------------------------------------------------------genSeq()\n\
   Generates sequence of length Length and period Period.\n\
   E.g. it enables to generate array which correspond to orbit channel\n\
";

Tpardesc writeSPn_parameters[4]={
{"board", 1},
{"Start", 1},
{"Period", 1},
{"n", 2}};
char writeSPn_usagehelp[]=" * --------------------------------------------------------------WriteSPn()\n\
 Write int n to ssm structure with period Period from Start. \n\
 Not to hardware !\n\
";

Tpardesc writeSPb_parameters[4]={
{"board", 1},
{"Start", 1},
{"Period", 1},
{"Channel", 1}};
char writeSPb_usagehelp[]=" * --------------------------------------------------------------WriteSPb()\n\
 Write 1 to bit channel with Period from Start.\n\
 Not overwriting other bits.\n\
 ";

Tpardesc writeSPb2_parameters[5]={
{"board", 1},
{"Start", 1},
{"Period", 1},
{"length", 1},
{"Channel", 1}};
char writeSPb2_usagehelp[]=" * --------------------------------------------------------------WriteSPb2()\n\
 Write 11..1 of length length to bit channel with Period from Start.\n\
 Not overwriting other bits.\n\
 ";

Tpardesc writeSPP_parameters[4]={
{"board", 1},
{"Start", 1},
{"Channel", 1},
{"Pattern", 3| 0x80000000}};
char writeSPP_usagehelp[]="-----------------------------------------------------------------WriteSPP()\n\
Write bit pattern Pattern to channel n from Start. \n\
Pattern is string of (0-9),(a-f) which is interpreted as hexadecimal number.\n\
Least significant bits on the left.\n\
";

Tpardesc writeSPF_parameters[4]={
{"board", 1},
{"Start", 1},
{"Channel", 1},
{"Pattern", 3| 0x80000000}};
char writeSPF_usagehelp[]="-----------------------------------------------------------------WriteSPF()\n\
Write bit pattern Pattern to channel n from Start. \n\
Pattern is string with formated input, see form2i() help.\n\
";

Tpardesc form2i_parameters[3]={
{"patin", 3| 0x80000000},
{"patout", 1| 0x80000000},
{"nperiod", 1| 0x80000000}};
char form2i_usagehelp[]=" *----------------------------------------------------------------form2i()\n\
 * Aim: to generate binary pattern\n\
 * Input: string of formatted input: number1anumber2anumber3a\n\
                                       2a10a3\n\
                                      110000000000111\n\
   a - delimiter\n\
   number1 = number of 1, number2- number of 0 ....\n\
 * Output: array of integers [number1,number2,...]\n\
 ";

int checkScopeBoard(char ab);
int setScopeBoard(char ab, int board);
int getScopeSignal(int board, char ab);
int setScopeSignal(int board, char ab, int signal);
int getVMERWScope();
void setVMERWScope(w32 newv, w32 oldv);
void readORBIT_READs();
void i2cread(int channel, int branch);
void setClusters(w32 daqbsy, w32 tc, w32 c1, w32 c2, w32 c3, w32 c4, w32 c5, w32 c6);
void getClusters();
void getDAQbusy();
void getFO(int ix);
void setFO(int ix, w32 cluster, w32 tcluster);
void setFOrocs(int calflag, w32 roc);
w32 swtrigger(int ssm);
w32 getTCSTATUS();
w32 getTCSET();
void setTCSET(w32 tcset012, w32 dets);
void clearTC();
void getClass(int klas);
void setClass(int klas, w32 condition, w32 invert, w32 veto, w32 scaler, w32 l1def, w32 l1invert, w32 l2def);
void disableClasses();
void hw2rates();
void rates2hw();
void getShared();
void setShared(w32 r1, w32 r2, w32 bs1, w32 bs2, w32 int1, w32 int2, w32 intt, w32 l0fun1, w32 l0fun2);
void setShared2(w32 intsel, w32 allrare);
void clearSPY(int board);
void getBCmasks();
void setBCmasks();
void checkBCmasks(int ntimes, int words);
void getPF(int ix);
void getPFc(int ix, int circ);
void setPF(int ix, w32 pfc);
void setPFc(int ix, int circ, w32 A, w32 B, w32 LUT);
void testSYNCH();
void testBCDELAY(int steps);
void setOrbitBChalf(int bit8);
void findNS();
void fdf();
void ReadTemperatures();
void TestLEDS();
void micsleep(int mics);
void initmain();
int getPFHW(int board, int ipf);
void printPFHW();
int printPFHWs(int board);
int setPFHW(int board, int ipf);
int readHWL1class();
void printHWL1class();
int L2a2Interface(int boardl1, int boardl2, int boardint);
int dumpIntSsm(int board);
int dumpL2amesage(int board);
void mysleep(w32 delta);
int setswtrig(char trigtype, w32 BC, w32 detectors);
void clearflags();
int swtrginf(char trigtype, w32 BC, w32 detectors);
int swtrg(int n, char trigtype, w32 BC, w32 detectors);
void gettableSSM();
void getsfSSM(int board);
void getsyncedSSM();
void getsigSSM(int board, int bit, int frombc, int bits);
void finddifSSM(int board, int bit, int frombc);
void getoffsetSSM(int board);
void setoffsetSSM(int board, int newoffset);
void setmodeSSM(int board, char *newmode, char *ltubase);
void printsms();
w32 getswSSM(int board);
void setsmssw(int ix, char *newmode);
int setomSSM(int board, w32 opmo);
int startSSM1(int board);
int stopSSM(int board);
int readSSM(int board);
int writeSSM(int board);
int dumpSSM(int board, char *fname);
void printSSM(int board, int fromadr);
int readSSMDump(int board, char *filename);
int readL0count(int board, int readHW);
void printL0count(int board);
void readHWrate(int board);
void printHWrate(int boards);
void setRate(int class, w32 rate);
void writeHWrate(int board);
int readHWL0class(int board);
void printHWL0class(int board);
int testRate(int board, int overflow, int rate, int downscale);
int L0classoutmonT(int board, int cptdt, int l0strobe, int chan);
int notInCrate(int ix);
w32 getCounter(int board, int reladr);
void getCounters(int accrual);
void clearCounters();
void README();
int FOLTUConnection(int ltu);
int FOL0L1mode();
int FOL2mode();
int L0FOconnection();
int L0FOconnection2();
int L0L1connection();
int L0L2connection();
int L0INTconnection();
int L0ingener();
int L0outmon();
int L0inmon();
int L0testPF(w32 tha1, w32 tha2, w32 thb1, w32 thb2, w32 deltaTa, w32 deltaTb, w32 sbc1, w32 resa, w32 resb, w32 lut12D);
int L0testPF2(int ipf);
int L0rndPF(int ipf);
int L0rndallPF();
int L0classlogic();
int L1testPF2(int ipf);
int L1classlogic2();
int L1ingener();
int L1outmon();
int L1inmon();
int L1ingen();
int L1L2Connect();
int L1FOconnection();
int L1INTconnection();
int L2classlogic();
int L1testPF3(int ipf);
int L1testPF4(int ipf);
int L1rndallPF();
int L1classlogic();
int L2FOconnection();
int L2INTconnection();
int L2INT();
int L2rndallPF();
int L2classlogic2();
int L2testPF3(int ipf);
int L0outL1inL2in();
int L0outL1outL2out();
int L0outL1outL2outFOLTU();
int L0outL1outL2outBusy();
int L0inBUout();
int MonallPF();
int FOL1mon();
int FOLTU();
int L2a2INT();
int dumpINTSSM();
int checkORBIT();
int BUconnect();
int INTL0connection();
int Comp2Channels(int board1, int chan, int start);
int CompallPF();
int DebugSync();
int genSeq(int board, int Period, int Start);
int writeSPn(int board, int Start, int Period, w32 n);
int writeSPb(int board, int Start, int Period, int Channel);
int writeSPb2(int board, int Start, int Period, int length, int Channel);
int writeSPP(int board, int Start, int Channel, char *Pattern);
int writeSPF(int board, int Start, int Channel, char *Pattern);
int form2i(char *patin, int *patout, int *nperiod);

int nnames=260;
Tname allnames[MAXNAMES]={
{"ctp", tSYMNAME, NULL, (w32)BoardSpaceLength, NULL, (w32)BoardBaseAddress, NULL},
{"CODE_ADD", tVMEADR, NULL, 0, NULL, 0x4, NULL},
{"SERIAL_NUMBER", tVMEADR, NULL, 0, NULL, 0x8, NULL},
{"VERSION_ADD", tVMEADR, NULL, 0, NULL, 0xc, NULL},
{"SOFT_RESET", tVMEADR, NULL, 0, NULL, 0x28, NULL},
{"TEMP_START", tVMEADR, NULL, 0, NULL, 0x58, NULL},
{"TEMP_STATUS", tVMEADR, NULL, 0, NULL, 0x5c, NULL},
{"TEMP_READ", tVMEADR, NULL, 0, NULL, 0x60, NULL},
{"FPGAVERSION_ADD", tVMEADR, NULL, 0, NULL, 0x80, NULL},
{"TEST_ADD", tVMEADR, NULL, 0, NULL, 0xc0, NULL},
{"BC_STATUS", tVMEADR, NULL, 0, NULL, 0xc4, NULL},
{"SSMcommand", tVMEADR, NULL, 0, NULL, 0x19c, NULL},
{"SSMstart", tVMEADR, NULL, 0, NULL, 0x1a0, NULL},
{"SSMstop", tVMEADR, NULL, 0, NULL, 0x1a4, NULL},
{"SSMaddress", tVMEADR, NULL, 0, NULL, 0x1a8, NULL},
{"SSMdata", tVMEADR, NULL, 0, NULL, 0x1ac, NULL},
{"SSMstatus", tVMEADR, NULL, 0, NULL, 0x1b0, NULL},
{"SSMenable", tVMEADR, NULL, 0, NULL, 0x1b4, NULL},
{"PLLreset", tVMEADR, NULL, 0, NULL, 0x1bc, NULL},
{"ADC_START", tVMEADR, NULL, 0, NULL, 0xcc, NULL},
{"ADC_DATA", tVMEADR, NULL, 0, NULL, 0xd0, NULL},
{"COPYCOUNT", tVMEADR, NULL, 0, NULL, 0x1d4, NULL},
{"COPYBUSY", tVMEADR, NULL, 0, NULL, 0x1d8, NULL},
{"COPYCLEARADD", tVMEADR, NULL, 0, NULL, 0x1dc, NULL},
{"COPYREAD", tVMEADR, NULL, 0, NULL, 0x1e0, NULL},
{"CLEARCOUNTER", tVMEADR, NULL, 0, NULL, 0x5ac, NULL},
{"SPY_MEMORY", tVMEADR, NULL, 0, NULL, 0x400, NULL},
{"SCOPE_SELECT", tVMEADR, NULL, 0, NULL, 0x4f8, NULL},
{"ADC_SELECT", tVMEADR, NULL, 0, NULL, 0x500, NULL},
{"SYNCH_ADD", tVMEADR, NULL, 0, NULL, 0x504, NULL},
{"PF_COMMON", tVMEADR, NULL, 0, NULL, 0x564, NULL},
{"PFBLOCK_A", tVMEADR, NULL, 0, NULL, 0x568, NULL},
{"FO_CLUSTER", tVMEADR, NULL, 0, NULL, 0x240, NULL},
{"FO_TESTCLUSTER", tVMEADR, NULL, 0, NULL, 0x244, NULL},
{"FO_DELAY_L1CLST", tVMEADR, NULL, 0, NULL, 0x248, NULL},
{"BUSY_DELAY_ADD", tVMEADR, NULL, 0, NULL, 0x80c8, NULL},
{"BUSY_ORBIT_SELECT", tVMEADR, NULL, 0, NULL, 0x80d4, NULL},
{"BUSY_DISB_CTP_BUSY", tVMEADR, NULL, 0, NULL, 0x80d8, NULL},
{"BUSY_CLUSTER", tVMEADR, NULL, 0, NULL, 0x8200, NULL},
{"BUSY_DAQBUSY", tVMEADR, NULL, 0, NULL, 0x821c, NULL},
{"BUSY_CTPDEADTIME", tVMEADR, NULL, 0, NULL, 0x8224, NULL},
{"BUSY_L0L1DEADTIME", tVMEADR, NULL, 0, NULL, 0x8220, NULL},
{"L0_TCSTATUS", tVMEADR, NULL, 0, NULL, 0x91c0, NULL},
{"L0_TCSTART", tVMEADR, NULL, 0, NULL, 0x91c4, NULL},
{"L0_TCCLEAR", tVMEADR, NULL, 0, NULL, 0x91c8, NULL},
{"RATE_DATA", tVMEADR, NULL, 0, NULL, 0x91cc, NULL},
{"RATE_CLEARADD", tVMEADR, NULL, 0, NULL, 0x91d0, NULL},
{"MASK_DATA", tVMEADR, NULL, 0, NULL, 0x91e4, NULL},
{"MASK_CLEARADD", tVMEADR, NULL, 0, NULL, 0x91e8, NULL},
{"L0_TCSET", tVMEADR, NULL, 0, NULL, 0x9400, NULL},
{"L0_CONDITION", tVMEADR, NULL, 0, NULL, 0x9400, NULL},
{"L0_VETO", tVMEADR, NULL, 0, NULL, 0x9600, NULL},
{"DAQ_LED", tVMEADR, NULL, 0, NULL, 0x9600, NULL},
{"L0_MASK", tVMEADR, NULL, 0, NULL, 0x9700, NULL},
{"L0_INVERT", tVMEADR, NULL, 0, NULL, 0x9500, NULL},
{"L0_INTERACT1", tVMEADR, NULL, 0, NULL, 0x94cc, NULL},
{"L0_INTERACT2", tVMEADR, NULL, 0, NULL, 0x94d0, NULL},
{"L0_INTERACTT", tVMEADR, NULL, 0, NULL, 0x94d4, NULL},
{"L0_INTERACTSEL", tVMEADR, NULL, 0, NULL, 0x94d8, NULL},
{"L0_FUNCTION1", tVMEADR, NULL, 0, NULL, 0x94dc, NULL},
{"L0_FUNCTION2", tVMEADR, NULL, 0, NULL, 0x94e0, NULL},
{"RANDOM_1", tVMEADR, NULL, 0, NULL, 0x94e4, NULL},
{"RANDOM_2", tVMEADR, NULL, 0, NULL, 0x94e8, NULL},
{"SCALED_1", tVMEADR, NULL, 0, NULL, 0x94ec, NULL},
{"SCALED_2", tVMEADR, NULL, 0, NULL, 0x94f0, NULL},
{"ALL_RARE_FLAG", tVMEADR, NULL, 0, NULL, 0x94f4, NULL},
{"MASK_MODE", tVMEADR, NULL, 0, NULL, 0x95a4, NULL},
{"L0_BCOFFSET", tVMEADR, NULL, 0, NULL, 0x95a8, NULL},
{"RATE_MODE", tVMEADR, NULL, 0, NULL, 0x9700, NULL},
{"L1_TCSTATUS", tVMEADR, NULL, 0, NULL, 0xa1c0, NULL},
{"L1_TCCLEAR", tVMEADR, NULL, 0, NULL, 0xa1c8, NULL},
{"L1_TCSET", tVMEADR, NULL, 0, NULL, 0xa400, NULL},
{"L1_DEFINITION", tVMEADR, NULL, 0, NULL, 0xa400, NULL},
{"L1_DELAY_L0", tVMEADR, NULL, 0, NULL, 0xa4cc, NULL},
{"L1_INVERT", tVMEADR, NULL, 0, NULL, 0xa500, NULL},
{"ROIP_BUSY", tVMEADR, NULL, 0, NULL, 0xa600, NULL},
{"L2_DEFINITION", tVMEADR, NULL, 0, NULL, 0xb400, NULL},
{"L2_ORBIT_READ", tVMEADR, NULL, 0, NULL, 0xb140, NULL},
{"L2_ORBIT_CLEAR", tVMEADR, NULL, 0, NULL, 0xb144, NULL},
{"L2_TCSTATUS", tVMEADR, NULL, 0, NULL, 0xb1c0, NULL},
{"L2_TCCLEAR", tVMEADR, NULL, 0, NULL, 0xb1c8, NULL},
{"L2_TCSET", tVMEADR, NULL, 0, NULL, 0xb400, NULL},
{"L2_DELAY_L1", tVMEADR, NULL, 0, NULL, 0xb4cc, NULL},
{"INT_ORBIT_READ", tVMEADR, NULL, 0, NULL, 0xc140, NULL},
{"INT_MAX_CLEAR", tVMEADR, NULL, 0, NULL, 0xc144, NULL},
{"INT_FIFO_MAX", tVMEADR, NULL, 0, NULL, 0xc148, NULL},
{"INT_DDL_EMU", tVMEADR, NULL, 0, NULL, 0xc14c, NULL},
{"INT_RC_BLCKMAX", tVMEADR, NULL, 0, NULL, 0xc16c, NULL},
{"INT_BLCKMAX_CLEAR", tVMEADR, NULL, 0, NULL, 0xc170, NULL},
{"INT_TC_SET", tVMEADR, NULL, 0, NULL, 0xc400, NULL},
{"INT_BC_OFFSET", tVMEADR, NULL, 0, NULL, 0xc5a8, NULL},
{"I2C_SET", tVMEADR, NULL, 0, NULL, 0xc164, NULL},
{"I2C_DATA", tVMEADR, NULL, 0, NULL, 0xc168, NULL},
{"I2C_MUXWR", tVMEADR, NULL, 0, NULL, 0xc154, NULL},
{"I2C_MUXRD", tVMEADR, NULL, 0, NULL, 0xc158, NULL},
{"I2C_ADCWR", tVMEADR, NULL, 0, NULL, 0xc15c, NULL},
{"I2C_ADCRD", tVMEADR, NULL, 0, NULL, 0xc160, NULL},
{"CTP_Classes", tFUN, NULL, 0xdead, NULL, 0, CTP_Classes_usagehelp},
{"CTP_Clusters", tFUN, NULL, 0xdead, NULL, 0, CTP_Clusters_usagehelp},
{"Resources", tFUN, NULL, 0xdead, NULL, 0, Resources_usagehelp},
{"Counters", tFUN, NULL, 0xdead, NULL, 0, Counters_usagehelp},
{"CheckTestClass", tFUN, NULL, 0xdead, NULL, 0, CheckTestClass_usagehelp},
{"ScopeAB", tFUN, NULL, 0xdead, NULL, 0, ScopeAB_usagehelp},
{"SSMbrowser", tFUN, NULL, 0xdead, NULL, 0, SSMbrowser_usagehelp},
{"SSMcontrol", tFUN, NULL, 0xdead, NULL, 0, SSMcontrol_usagehelp},
{"checkScopeBoard", tFUN+0x200, (w32 (*)())checkScopeBoard, 0xdead, checkScopeBoard_parameters, 1, checkScopeBoard_usagehelp},
{"setScopeBoard", tFUN+0x200, (w32 (*)())setScopeBoard, 0xdead, setScopeBoard_parameters, 2, setScopeBoard_usagehelp},
{"getScopeSignal", tFUN+0x200, (w32 (*)())getScopeSignal, 0xdead, getScopeSignal_parameters, 2, getScopeSignal_usagehelp},
{"setScopeSignal", tFUN+0x200, (w32 (*)())setScopeSignal, 0xdead, setScopeSignal_parameters, 3, setScopeSignal_usagehelp},
{"getVMERWScope", tFUN+0x200, (w32 (*)())getVMERWScope, 0xdead, NULL, 0, getVMERWScope_usagehelp},
{"setVMERWScope", tFUN+0x400, (w32 (*)())setVMERWScope, 0xdead, setVMERWScope_parameters, 2, setVMERWScope_usagehelp},
{"SaveFile", tFUN, NULL, 0xdead, NULL, 0, SaveFile_usagehelp},
{"LoadFile", tFUN, NULL, 0xdead, NULL, 0, LoadFile_usagehelp},
{"Readhw", tFUN, NULL, 0xdead, NULL, 0, Readhw_usagehelp},
{"Write2hw", tFUN, NULL, 0xdead, NULL, 0, Write2hw_usagehelp},
{"readORBIT_READs", tFUN+0x400, (w32 (*)())readORBIT_READs, 0xdead, NULL, 0, readORBIT_READs_usagehelp},
{"i2cread", tFUN+0x400, (w32 (*)())i2cread, 0xdead, i2cread_parameters, 2, i2cread_usagehelp},
{"setClusters", tFUN+0x400, (w32 (*)())setClusters, 0xdead, setClusters_parameters, 8, setClusters_usagehelp},
{"getClusters", tFUN+0x400, (w32 (*)())getClusters, 0xdead, NULL, 0, getClusters_usagehelp},
{"getDAQbusy", tFUN+0x400, (w32 (*)())getDAQbusy, 0xdead, NULL, 0, getDAQbusy_usagehelp},
{"getFO", tFUN+0x400, (w32 (*)())getFO, 0xdead, getFO_parameters, 1, getFO_usagehelp},
{"setFO", tFUN+0x400, (w32 (*)())setFO, 0xdead, setFO_parameters, 3, setFO_usagehelp},
{"setFOrocs", tFUN+0x400, (w32 (*)())setFOrocs, 0xdead, setFOrocs_parameters, 2, setFOrocs_usagehelp},
{"swtrigger", tFUN+0x100, (w32 (*)())swtrigger, 0xdead, swtrigger_parameters, 1, swtrigger_usagehelp},
{"getTCSTATUS", tFUN+0x100, (w32 (*)())getTCSTATUS, 0xdead, NULL, 0, getTCSTATUS_usagehelp},
{"getTCSET", tFUN+0x100, (w32 (*)())getTCSET, 0xdead, NULL, 0, getTCSET_usagehelp},
{"setTCSET", tFUN+0x400, (w32 (*)())setTCSET, 0xdead, setTCSET_parameters, 2, setTCSET_usagehelp},
{"clearTC", tFUN+0x400, (w32 (*)())clearTC, 0xdead, NULL, 0, clearTC_usagehelp},
{"getClass", tFUN+0x400, (w32 (*)())getClass, 0xdead, getClass_parameters, 1, getClass_usagehelp},
{"setClass", tFUN+0x400, (w32 (*)())setClass, 0xdead, setClass_parameters, 8, setClass_usagehelp},
{"disableClasses", tFUN+0x400, (w32 (*)())disableClasses, 0xdead, NULL, 0, disableClasses_usagehelp},
{"hw2rates", tFUN+0x400, (w32 (*)())hw2rates, 0xdead, NULL, 0, hw2rates_usagehelp},
{"rates2hw", tFUN+0x400, (w32 (*)())rates2hw, 0xdead, NULL, 0, rates2hw_usagehelp},
{"getShared", tFUN+0x400, (w32 (*)())getShared, 0xdead, NULL, 0, getShared_usagehelp},
{"setShared", tFUN+0x400, (w32 (*)())setShared, 0xdead, setShared_parameters, 9, setShared_usagehelp},
{"setShared2", tFUN+0x400, (w32 (*)())setShared2, 0xdead, setShared2_parameters, 2, setShared2_usagehelp},
{"clearSPY", tFUN+0x400, (w32 (*)())clearSPY, 0xdead, clearSPY_parameters, 1, clearSPY_usagehelp},
{"getBCmasks", tFUN+0x400, (w32 (*)())getBCmasks, 0xdead, NULL, 0, getBCmasks_usagehelp},
{"setBCmasks", tFUN+0x400, (w32 (*)())setBCmasks, 0xdead, NULL, 0, setBCmasks_usagehelp},
{"checkBCmasks", tFUN+0x400, (w32 (*)())checkBCmasks, 0xdead, checkBCmasks_parameters, 2, checkBCmasks_usagehelp},
{"getPF", tFUN+0x400, (w32 (*)())getPF, 0xdead, getPF_parameters, 1, getPF_usagehelp},
{"getPFc", tFUN+0x400, (w32 (*)())getPFc, 0xdead, getPFc_parameters, 2, getPFc_usagehelp},
{"setPF", tFUN+0x400, (w32 (*)())setPF, 0xdead, setPF_parameters, 2, setPF_usagehelp},
{"setPFc", tFUN+0x400, (w32 (*)())setPFc, 0xdead, setPFc_parameters, 5, setPFc_usagehelp},
{"testSYNCH", tFUN+0x400, (w32 (*)())testSYNCH, 0xdead, NULL, 0, testSYNCH_usagehelp},
{"testBCDELAY", tFUN+0x400, (w32 (*)())testBCDELAY, 0xdead, testBCDELAY_parameters, 1, testBCDELAY_usagehelp},
{"setOrbitBChalf", tFUN+0x400, (w32 (*)())setOrbitBChalf, 0xdead, setOrbitBChalf_parameters, 1, setOrbitBChalf_usagehelp},
{"findNS", tFUN+0x400, (w32 (*)())findNS, 0xdead, NULL, 0, NULL},
{"fdf", tFUN+0x400, (w32 (*)())fdf, 0xdead, NULL, 0, NULL},
{"ReadTemperatures", tFUN+0x400, (w32 (*)())ReadTemperatures, 0xdead, NULL, 0, NULL},
{"TestLEDS", tFUN+0x400, (w32 (*)())TestLEDS, 0xdead, NULL, 0, NULL},
{"micsleep", tFUN+0x400, (w32 (*)())micsleep, 0xdead, micsleep_parameters, 1, micsleep_usagehelp},
{"initmain", tFUN+0x400, (w32 (*)())initmain, 0xdead, NULL, 0, initmain_usagehelp},
{"getPFHW", tFUN+0x200, (w32 (*)())getPFHW, 0xdead, getPFHW_parameters, 2, getPFHW_usagehelp},
{"printPFHW", tFUN+0x400, (w32 (*)())printPFHW, 0xdead, NULL, 0, printPFHW_usagehelp},
{"printPFHWs", tFUN+0x200, (w32 (*)())printPFHWs, 0xdead, printPFHWs_parameters, 1, printPFHWs_usagehelp},
{"setPFHW", tFUN+0x200, (w32 (*)())setPFHW, 0xdead, setPFHW_parameters, 2, setPFHW_usagehelp},
{"readHWL1class", tFUN+0x200, (w32 (*)())readHWL1class, 0xdead, NULL, 0, readHWL1class_usagehelp},
{"printHWL1class", tFUN+0x400, (w32 (*)())printHWL1class, 0xdead, NULL, 0, printHWL1class_usagehelp},
{"L2a2Interface", tFUN+0x200, (w32 (*)())L2a2Interface, 0xdead, L2a2Interface_parameters, 3, L2a2Interface_usagehelp},
{"dumpIntSsm", tFUN+0x200, (w32 (*)())dumpIntSsm, 0xdead, dumpIntSsm_parameters, 1, dumpIntSsm_usagehelp},
{"dumpL2amesage", tFUN+0x200, (w32 (*)())dumpL2amesage, 0xdead, dumpL2amesage_parameters, 1, dumpL2amesage_usagehelp},
{"mysleep", tFUN+0x400, (w32 (*)())mysleep, 0xdead, mysleep_parameters, 1, NULL},
{"setswtrig", tFUN+0x200, (w32 (*)())setswtrig, 0xdead, setswtrig_parameters, 3, setswtrig_usagehelp},
{"clearflags", tFUN+0x400, (w32 (*)())clearflags, 0xdead, NULL, 0, clearflags_usagehelp},
{"swtrginf", tFUN+0x200, (w32 (*)())swtrginf, 0xdead, swtrginf_parameters, 3, swtrginf_usagehelp},
{"swtrg", tFUN+0x200, (w32 (*)())swtrg, 0xdead, swtrg_parameters, 4, swtrg_usagehelp},
{"gettableSSM", tFUN+0x400, (w32 (*)())gettableSSM, 0xdead, NULL, 0, gettableSSM_usagehelp},
{"getsfSSM", tFUN+0x400, (w32 (*)())getsfSSM, 0xdead, getsfSSM_parameters, 1, getsfSSM_usagehelp},
{"getsyncedSSM", tFUN+0x400, (w32 (*)())getsyncedSSM, 0xdead, NULL, 0, getsyncedSSM_usagehelp},
{"getsigSSM", tFUN+0x400, (w32 (*)())getsigSSM, 0xdead, getsigSSM_parameters, 4, getsigSSM_usagehelp},
{"finddifSSM", tFUN+0x400, (w32 (*)())finddifSSM, 0xdead, finddifSSM_parameters, 3, finddifSSM_usagehelp},
{"getoffsetSSM", tFUN+0x400, (w32 (*)())getoffsetSSM, 0xdead, getoffsetSSM_parameters, 1, getoffsetSSM_usagehelp},
{"setoffsetSSM", tFUN+0x400, (w32 (*)())setoffsetSSM, 0xdead, setoffsetSSM_parameters, 2, setoffsetSSM_usagehelp},
{"setmodeSSM", tFUN+0x400, (w32 (*)())setmodeSSM, 0xdead, setmodeSSM_parameters, 3, setmodeSSM_usagehelp},
{"printsms", tFUN+0x400, (w32 (*)())printsms, 0xdead, NULL, 0, printsms_usagehelp},
{"getswSSM", tFUN+0x100, (w32 (*)())getswSSM, 0xdead, getswSSM_parameters, 1, getswSSM_usagehelp},
{"setsmssw", tFUN+0x400, (w32 (*)())setsmssw, 0xdead, setsmssw_parameters, 2, setsmssw_usagehelp},
{"setomSSM", tFUN+0x200, (w32 (*)())setomSSM, 0xdead, setomSSM_parameters, 2, setomSSM_usagehelp},
{"startSSM1", tFUN+0x200, (w32 (*)())startSSM1, 0xdead, startSSM1_parameters, 1, NULL},
{"stopSSM", tFUN+0x200, (w32 (*)())stopSSM, 0xdead, stopSSM_parameters, 1, stopSSM_usagehelp},
{"readSSM", tFUN+0x200, (w32 (*)())readSSM, 0xdead, readSSM_parameters, 1, readSSM_usagehelp},
{"writeSSM", tFUN+0x200, (w32 (*)())writeSSM, 0xdead, writeSSM_parameters, 1, writeSSM_usagehelp},
{"dumpSSM", tFUN+0x200, (w32 (*)())dumpSSM, 0xdead, dumpSSM_parameters, 2, dumpSSM_usagehelp},
{"printSSM", tFUN+0x400, (w32 (*)())printSSM, 0xdead, printSSM_parameters, 2, printSSM_usagehelp},
{"readSSMDump", tFUN+0x200, (w32 (*)())readSSMDump, 0xdead, readSSMDump_parameters, 2, readSSMDump_usagehelp},
{"readL0count", tFUN+0x200, (w32 (*)())readL0count, 0xdead, readL0count_parameters, 2, readL0count_usagehelp},
{"printL0count", tFUN+0x400, (w32 (*)())printL0count, 0xdead, printL0count_parameters, 1, printL0count_usagehelp},
{"readHWrate", tFUN+0x400, (w32 (*)())readHWrate, 0xdead, readHWrate_parameters, 1, readHWrate_usagehelp},
{"printHWrate", tFUN+0x400, (w32 (*)())printHWrate, 0xdead, printHWrate_parameters, 1, printHWrate_usagehelp},
{"setRate", tFUN+0x400, (w32 (*)())setRate, 0xdead, setRate_parameters, 2, setRate_usagehelp},
{"writeHWrate", tFUN+0x400, (w32 (*)())writeHWrate, 0xdead, writeHWrate_parameters, 1, writeHWrate_usagehelp},
{"readHWL0class", tFUN+0x200, (w32 (*)())readHWL0class, 0xdead, readHWL0class_parameters, 1, readHWL0class_usagehelp},
{"printHWL0class", tFUN+0x400, (w32 (*)())printHWL0class, 0xdead, printHWL0class_parameters, 1, printHWL0class_usagehelp},
{"testRate", tFUN+0x200, (w32 (*)())testRate, 0xdead, testRate_parameters, 4, testRate_usagehelp},
{"L0classoutmonT", tFUN+0x200, (w32 (*)())L0classoutmonT, 0xdead, L0classoutmonT_parameters, 4, L0classoutmonT_usagehelp},
{"notInCrate", tFUN+0x200, (w32 (*)())notInCrate, 0xdead, notInCrate_parameters, 1, NULL},
{"getCounter", tFUN+0x100, (w32 (*)())getCounter, 0xdead, getCounter_parameters, 2, NULL},
{"getCounters", tFUN+0x400, (w32 (*)())getCounters, 0xdead, getCounters_parameters, 1, NULL},
{"clearCounters", tFUN+0x400, (w32 (*)())clearCounters, 0xdead, NULL, 0, NULL},
{"README", tFUN+0x400, (w32 (*)())README, 0xdead, NULL, 0, README_usagehelp},
{"FOLTUConnection", tFUN+0x200, (w32 (*)())FOLTUConnection, 0xdead, FOLTUConnection_parameters, 1, FOLTUConnection_usagehelp},
{"FOL0L1mode", tFUN+0x200, (w32 (*)())FOL0L1mode, 0xdead, NULL, 0, FOL0L1mode_usagehelp},
{"FOL2mode", tFUN+0x200, (w32 (*)())FOL2mode, 0xdead, NULL, 0, FOL2mode_usagehelp},
{"L0FOconnection", tFUN+0x200, (w32 (*)())L0FOconnection, 0xdead, NULL, 0, L0FOconnection_usagehelp},
{"L0FOconnection2", tFUN+0x200, (w32 (*)())L0FOconnection2, 0xdead, NULL, 0, L0FOconnection2_usagehelp},
{"L0L1connection", tFUN+0x200, (w32 (*)())L0L1connection, 0xdead, NULL, 0, L0L1connection_usagehelp},
{"L0L2connection", tFUN+0x200, (w32 (*)())L0L2connection, 0xdead, NULL, 0, L0L2connection_usagehelp},
{"L0INTconnection", tFUN+0x200, (w32 (*)())L0INTconnection, 0xdead, NULL, 0, L0INTconnection_usagehelp},
{"L0ingener", tFUN+0x200, (w32 (*)())L0ingener, 0xdead, NULL, 0, L0ingener_usagehelp},
{"L0outmon", tFUN+0x200, (w32 (*)())L0outmon, 0xdead, NULL, 0, L0outmon_usagehelp},
{"L0inmon", tFUN+0x200, (w32 (*)())L0inmon, 0xdead, NULL, 0, L0inmon_usagehelp},
{"L0testPF", tFUN+0x200, (w32 (*)())L0testPF, 0xdead, L0testPF_parameters, 10, L0testPF_usagehelp},
{"L0testPF2", tFUN+0x200, (w32 (*)())L0testPF2, 0xdead, L0testPF2_parameters, 1, L0testPF2_usagehelp},
{"L0rndPF", tFUN+0x200, (w32 (*)())L0rndPF, 0xdead, L0rndPF_parameters, 1, L0rndPF_usagehelp},
{"L0rndallPF", tFUN+0x200, (w32 (*)())L0rndallPF, 0xdead, NULL, 0, L0rndallPF_usagehelp},
{"L0classlogic", tFUN+0x200, (w32 (*)())L0classlogic, 0xdead, NULL, 0, L0classlogic_usagehelp},
{"L1testPF2", tFUN+0x200, (w32 (*)())L1testPF2, 0xdead, L1testPF2_parameters, 1, L1testPF2_usagehelp},
{"L1classlogic2", tFUN+0x200, (w32 (*)())L1classlogic2, 0xdead, NULL, 0, L1classlogic2_usagehelp},
{"L1ingener", tFUN+0x200, (w32 (*)())L1ingener, 0xdead, NULL, 0, L1ingener_usagehelp},
{"L1outmon", tFUN+0x200, (w32 (*)())L1outmon, 0xdead, NULL, 0, L1outmon_usagehelp},
{"L1inmon", tFUN+0x200, (w32 (*)())L1inmon, 0xdead, NULL, 0, L1inmon_usagehelp},
{"L1ingen", tFUN+0x200, (w32 (*)())L1ingen, 0xdead, NULL, 0, L1ingen_usagehelp},
{"L1L2Connect", tFUN+0x200, (w32 (*)())L1L2Connect, 0xdead, NULL, 0, L1L2Connect_usagehelp},
{"L1FOconnection", tFUN+0x200, (w32 (*)())L1FOconnection, 0xdead, NULL, 0, L1FOconnection_usagehelp},
{"L1INTconnection", tFUN+0x200, (w32 (*)())L1INTconnection, 0xdead, NULL, 0, L1INTconnection_usagehelp},
{"L2classlogic", tFUN+0x200, (w32 (*)())L2classlogic, 0xdead, NULL, 0, L2classlogic_usagehelp},
{"L1testPF3", tFUN+0x200, (w32 (*)())L1testPF3, 0xdead, L1testPF3_parameters, 1, L1testPF3_usagehelp},
{"L1testPF4", tFUN+0x200, (w32 (*)())L1testPF4, 0xdead, L1testPF4_parameters, 1, L1testPF4_usagehelp},
{"L1rndallPF", tFUN+0x200, (w32 (*)())L1rndallPF, 0xdead, NULL, 0, L1rndallPF_usagehelp},
{"L1classlogic", tFUN+0x200, (w32 (*)())L1classlogic, 0xdead, NULL, 0, L1classlogic_usagehelp},
{"L2FOconnection", tFUN+0x200, (w32 (*)())L2FOconnection, 0xdead, NULL, 0, L2FOconnection_usagehelp},
{"L2INTconnection", tFUN+0x200, (w32 (*)())L2INTconnection, 0xdead, NULL, 0, L2INTconnection_usagehelp},
{"L2INT", tFUN+0x200, (w32 (*)())L2INT, 0xdead, NULL, 0, L2INT_usagehelp},
{"L2rndallPF", tFUN+0x200, (w32 (*)())L2rndallPF, 0xdead, NULL, 0, L2rndallPF_usagehelp},
{"L2classlogic2", tFUN+0x200, (w32 (*)())L2classlogic2, 0xdead, NULL, 0, L2classlogic2_usagehelp},
{"L2testPF3", tFUN+0x200, (w32 (*)())L2testPF3, 0xdead, L2testPF3_parameters, 1, L2testPF3_usagehelp},
{"L0outL1inL2in", tFUN+0x200, (w32 (*)())L0outL1inL2in, 0xdead, NULL, 0, L0outL1inL2in_usagehelp},
{"L0outL1outL2out", tFUN+0x200, (w32 (*)())L0outL1outL2out, 0xdead, NULL, 0, L0outL1outL2out_usagehelp},
{"L0outL1outL2outFOLTU", tFUN+0x200, (w32 (*)())L0outL1outL2outFOLTU, 0xdead, NULL, 0, L0outL1outL2outFOLTU_usagehelp},
{"L0outL1outL2outBusy", tFUN+0x200, (w32 (*)())L0outL1outL2outBusy, 0xdead, NULL, 0, L0outL1outL2outBusy_usagehelp},
{"L0inBUout", tFUN+0x200, (w32 (*)())L0inBUout, 0xdead, NULL, 0, L0inBUout_usagehelp},
{"MonallPF", tFUN+0x200, (w32 (*)())MonallPF, 0xdead, NULL, 0, MonallPF_usagehelp},
{"FOL1mon", tFUN+0x200, (w32 (*)())FOL1mon, 0xdead, NULL, 0, FOL1mon_usagehelp},
{"FOLTU", tFUN+0x200, (w32 (*)())FOLTU, 0xdead, NULL, 0, FOLTU_usagehelp},
{"L2a2INT", tFUN+0x200, (w32 (*)())L2a2INT, 0xdead, NULL, 0, L2a2INT_usagehelp},
{"dumpINTSSM", tFUN+0x200, (w32 (*)())dumpINTSSM, 0xdead, NULL, 0, dumpINTSSM_usagehelp},
{"checkORBIT", tFUN+0x200, (w32 (*)())checkORBIT, 0xdead, NULL, 0, checkORBIT_usagehelp},
{"BUconnect", tFUN+0x200, (w32 (*)())BUconnect, 0xdead, NULL, 0, BUconnect_usagehelp},
{"INTL0connection", tFUN+0x200, (w32 (*)())INTL0connection, 0xdead, NULL, 0, INTL0connection_usagehelp},
{"Comp2Channels", tFUN+0x200, (w32 (*)())Comp2Channels, 0xdead, Comp2Channels_parameters, 3, Comp2Channels_usagehelp},
{"CompallPF", tFUN+0x200, (w32 (*)())CompallPF, 0xdead, NULL, 0, CompallPF_usagehelp},
{"DebugSync", tFUN+0x200, (w32 (*)())DebugSync, 0xdead, NULL, 0, DebugSync_usagehelp},
{"genSeq", tFUN+0x200, (w32 (*)())genSeq, 0xdead, genSeq_parameters, 3, genSeq_usagehelp},
{"writeSPn", tFUN+0x200, (w32 (*)())writeSPn, 0xdead, writeSPn_parameters, 4, writeSPn_usagehelp},
{"writeSPb", tFUN+0x200, (w32 (*)())writeSPb, 0xdead, writeSPb_parameters, 4, writeSPb_usagehelp},
{"writeSPb2", tFUN+0x200, (w32 (*)())writeSPb2, 0xdead, writeSPb2_parameters, 5, writeSPb2_usagehelp},
{"writeSPP", tFUN+0x200, (w32 (*)())writeSPP, 0xdead, writeSPP_parameters, 4, writeSPP_usagehelp},
{"writeSPF", tFUN+0x200, (w32 (*)())writeSPF, 0xdead, writeSPF_parameters, 4, writeSPF_usagehelp},
{"form2i", tFUN+0x200, (w32 (*)())form2i, 0xdead, form2i_parameters, 3, form2i_usagehelp}};
