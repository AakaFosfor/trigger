self.baseAddr="0x820000"
self.spaceLength="0xd000"
self.vmeregs=[('CODE_ADD', '0x4', ''), ('SERIAL_NUMBER', '0x8', ''), ('VERSION_ADD', '0xc', ''), ('SOFT_RESET', '0x28', ''), ('TEMP_START', '0x58', ''), ('TEMP_STATUS', '0x5c', ''), ('TEMP_READ', '0x60', ''), ('FPGAVERSION_ADD', '0x80', ''), ('TEST_ADD', '0xc0', ''), ('BC_STATUS', '0xc4', ''), ('SSMcommand', '0x19c', ''), ('SSMstart', '0x1a0', ''), ('SSMstop', '0x1a4', ''), ('SSMaddress', '0x1a8', ''), ('SSMdata', '0x1ac', ''), ('SSMstatus', '0x1b0', ''), ('SSMenable', '0x1b4', ''), ('PLLreset', '0x1bc', ''), ('ADC_START', '0xcc', ''), ('ADC_DATA', '0xd0', ''), ('COPYCOUNT', '0x1d4', ''), ('COPYBUSY', '0x1d8', ''), ('COPYCLEARADD', '0x1dc', ''), ('COPYREAD', '0x1e0', ''), ('CLEARCOUNTER', '0x5ac', ''), ('SPY_MEMORY', '0x400', ''), ('SCOPE_SELECT', '0x4f8', ''), ('ADC_SELECT', '0x500', ''), ('SYNCH_ADD', '0x504', ''), ('PF_COMMON', '0x564', ''), ('PFBLOCK_A', '0x568', ''), ('FO_CLUSTER', '0x240', ''), ('FO_TESTCLUSTER', '0x244', ''), ('FO_DELAY_L1CLST', '0x248', ''), ('BUSY_DELAY_ADD', '0x80c8', ''), ('BUSY_ORBIT_SELECT', '0x80d4', ''), ('BUSY_DISB_CTP_BUSY', '0x80d8', ''), ('BUSY_CLUSTER', '0x8200', ''), ('BUSY_DAQBUSY', '0x821c', ''), ('BUSY_CTPDEADTIME', '0x8224', ''), ('BUSY_L0L1DEADTIME', '0x8220', ''), ('L0_TCSTATUS', '0x91c0', ''), ('L0_TCSTART', '0x91c4', ''), ('L0_TCCLEAR', '0x91c8', ''), ('RATE_DATA', '0x91cc', ''), ('RATE_CLEARADD', '0x91d0', ''), ('MASK_DATA', '0x91e4', ''), ('MASK_CLEARADD', '0x91e8', ''), ('L0_TCSET', '0x9400', ''), ('L0_CONDITION', '0x9400', ''), ('L0_VETO', '0x9600', ''), ('DAQ_LED', '0x9600', ''), ('L0_MASK', '0x9700', ''), ('L0_INVERT', '0x9500', ''), ('L0_INTERACT1', '0x94cc', ''), ('L0_INTERACT2', '0x94d0', ''), ('L0_INTERACTT', '0x94d4', ''), ('L0_INTERACTSEL', '0x94d8', ''), ('L0_FUNCTION1', '0x94dc', ''), ('L0_FUNCTION2', '0x94e0', ''), ('RANDOM_1', '0x94e4', ''), ('RANDOM_2', '0x94e8', ''), ('SCALED_1', '0x94ec', ''), ('SCALED_2', '0x94f0', ''), ('ALL_RARE_FLAG', '0x94f4', ''), ('MASK_MODE', '0x95a4', ''), ('L0_BCOFFSET', '0x95a8', ''), ('RATE_MODE', '0x9700', ''), ('L1_TCSTATUS', '0xa1c0', ''), ('L1_TCCLEAR', '0xa1c8', ''), ('L1_TCSET', '0xa400', ''), ('L1_DEFINITION', '0xa400', ''), ('L1_DELAY_L0', '0xa4cc', ''), ('L1_INVERT', '0xa500', ''), ('ROIP_BUSY', '0xa600', ''), ('L2_DEFINITION', '0xb400', ''), ('L2_ORBIT_READ', '0xb140', ''), ('L2_ORBIT_CLEAR', '0xb144', ''), ('L2_TCSTATUS', '0xb1c0', ''), ('L2_TCCLEAR', '0xb1c8', ''), ('L2_TCSET', '0xb400', ''), ('L2_DELAY_L1', '0xb4cc', ''), ('INT_ORBIT_READ', '0xc140', ''), ('INT_MAX_CLEAR', '0xc144', ''), ('INT_FIFO_MAX', '0xc148', ''), ('INT_DDL_EMU', '0xc14c', ''), ('INT_RC_BLCKMAX', '0xc16c', ''), ('INT_BLCKMAX_CLEAR', '0xc170', ''), ('INT_TC_SET', '0xc400', ''), ('INT_BC_OFFSET', '0xc5a8', ''), ('I2C_SET', '0xc164', ''), ('I2C_DATA', '0xc168', ''), ('I2C_MUXWR', '0xc154', ''), ('I2C_MUXRD', '0xc158', ''), ('I2C_ADCWR', '0xc15c', ''), ('I2C_ADCRD', '0xc160', '')]
self.hiddenfuncs=" Common"
self.funcs=[[None, 'The Classes definition, i.e. for each (1-50) class: \n -enabling/disabling\n -L0,L1,L2 inputs and selectable vetos\n -cluster\n -L0 pre-scaler\n', 'GUI', 'CTP_Classes', [], 'Classes'], [None, "The Clusters definition, i.e. which detectors (LTUs) belong to each cluster.\nCluster definition consist of 'assignment of clusters to\neach Fanout connector'.\n", 'GUI', 'CTP_Clusters', [], 'FOs/Clusters'], [None, 'The Shared resources definition. They are:\n- random generators(2) and BC generators(2) rates\n- 3 Interaction functions (16 bits lookup tables)\n- 2 L0 input functions (16 bits lookup tables)\n- 2 Interaction selectors\n- All/Rare events CTP option\n- 5 Past/Future protection circuits for all trigger levels \n    (PF1-PF4 for physics and PF5 for Test Class)\n', 'GUI', 'Resources', [], 'Shared resources'], [None, 'Displays counters on all CTP boards\n', 'GUI', 'Counters', [], 'Counters'], [None, 'Test class control.\n', 'GUI', 'CheckTestClass', [], 'Test class'], [None, 'Signal selection for front panel \nA,B outputs\n', 'GUI', 'ScopeAB', [], 'Scope Signals'], [None, 'Browse CTP snapshot memories \n', 'GUI', 'SSMbrowser', [], 'SSMbrowser'], [None, 'The CTP snapshot memories control\n', 'GUI', 'SSMcontrol', [], 'SSMcontrol'], ['DbgScopeCalls', "rc: the number of the board (0-10) which has its ab output enabled\n    -1 if there is no enabled board\nNote: by running this subroutine, all boards are checked, and\n      if there is more 'enabled' boards then 1, they are disabled\n      (but the first enabled one)\n", 'int', 'checkScopeBoard', [['ab', 'char', '']]], ['DbgScopeCalls', "Enable 1 board scope output.\nrc: the number of the board (0-10) which has its ab output enabled\n    -1 if there is no enabled board\nNote: by running this subroutine, all boards are checked, and\n      if there is more 'enabled' boards then 1, they are disabled\n      (but the first enabled one)\n", 'int', 'setScopeBoard', [['ab', 'char', ''], ['board', 'int', '']]], ['DbgScopeCalls', "rc: the number of the signal choosen for this board's ab output\n    0x1000+0..31  -> Abis signals\n    0x100 +0..31  -> Bbis signals\n", 'int', 'getScopeSignal', [['board', 'int', ''], ['ab', 'char', '']]], ['DbgScopeCalls', "signal: 0x1000+0..23  -> Abis signals\n        0x100 +0..23  -> Bbis signals\nrc: the number of the signal choosen for this board's ab output\n    -1 in case of error\n", 'int', 'setScopeSignal', [['board', 'int', ''], ['ab', 'char', ''], ['signal', 'int', '']]], ['DbgScopeCalls', 'rc: word with the bits corresponding to CTP boards in VMERW-Scope mode\n    0 -no board in VMERW-Scope mode\n    0x7ff -all boards in VMERW-Scope mode\n', 'int', 'getVMERWScope', []], ['DbgScopeCalls', 'newv: new settings     oldv: old settings\n', 'void', 'setVMERWScope', [['newv', 'w32', ''], ['oldv', 'w32', '']]], ['File', '- Save configuration to WORK/.cfg configuration to file\n', 'GUI', 'SaveFile', [], 'Save2file'], ['File', '- Load configuration from WORK/.cfg configuration to file\nTodo:\n- check hw configuration with the memory-configuration\n- Load (i.e. add) partition configuration (i.e. from .configuration\n  file prepared by partition editor)\n', 'GUI', 'LoadFile', [], 'Load file'], ['File', '- Load configuration from CTP boards\n', 'GUI', 'Readhw', [], 'Readhw'], ['File', '- Write configuration into CTP boards\n', 'GUI', 'Write2hw', [], 'Write2hw'], ['DBGint', 'read/print 2 L2_ORBIT_READ and INT_ORBIT_READ ', 'void', 'readORBIT_READs', []], ['DBGint', 'read voltages from 1 board.\nchannel: 0-7\nbranch:  0-7  ', 'void', 'i2cread', [['channel', 'int', ''], ['branch', 'int', '']]], ['busy', 'Set daqbsy, T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board\n', 'void', 'setClusters', [['daqbsy', 'w32', ''], ['tc', 'w32', ''], ['c1', 'w32', ''], ['c2', 'w32', ''], ['c3', 'w32', ''], ['c4', 'w32', ''], ['c5', 'w32', ''], ['c6', 'w32', '']]], ['busy', 'Read T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board and print it as 1 line\n', 'void', 'getClusters', []], ['busy', 'Read DAQ_BUSY word ', 'void', 'getDAQbusy', []], ['dbghw', "ix: FO1BOARD..FO1BOARD+5   (6 FO boards)\nalways read FO board's CLUSTER, TEST_CLUSTER words\nSTDOUT:\n- no output                if ix FO is not in the crate\ncluster testcluster        for FO in the crate\n", 'void', 'getFO', [['ix', 'int', '']]], ['dbghw', "write to FO board's registers only if modified\nix: FO1BOARD..FO1BOARD+5   (6 FO boards)\n", 'void', 'setFO', [['ix', 'int', ''], ['cluster', 'w32', ''], ['tcluster', 'w32', '']]], ['L0', 'Start SW trigger.\nInput:\nssm: 1   ->start SSM recording in L0 output moinitoring mode before\n           starting trigger\nOperation:\n- clear flags\n- start SSM (optionally)\n- start sw trigger\n- usleep(200) -micsecs\n- read L0_TCSTATUS word\nOutput:\nL0_TCSTATUS word\nToDo: -for whic detector? \n      - ROC bits to be written to FO and INT board\n', 'w32', 'swtrigger', [['ssm', 'int', '']]], ['L0', 'klas: 1-50   -class number\nget L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n    L1_DEFINITION L1_INVERT L2_DEFINITION words for klas\n\nL0_IVERT, L1_INVERT are 0:for classes 1-44 or \ncorresponding board is not in the crate\n', 'void', 'getClass', [['klas', 'int', '']]], ['L0', 'set L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n    L1_DEFINITION L1_INVERT L2_DEFINITION\nwords for klas (1..50)\nATTENTION: i\n1. bit17 (0x10000) of veto is CLASS MASK bit written into bit0 of L0_MASK\n2. invert,l1invert -valid only for class>=45\n', 'void', 'setClass', [['klas', 'int', ''], ['condition', 'w32', ''], ['invert', 'w32', ''], ['veto', 'w32', ''], ['scaler', 'w32', ''], ['l1def', 'w32', ''], ['l1invert', 'w32', ''], ['l2def', 'w32', '']]], ['L0', 'disable all 50 classes, i.e.:\n- set all inputs,vetos as dontcare for all 50 classes i.e.:\nL0_CONDITION = 0xffffffff\nL0_VETO      = 0xfffffff0   (cluster0)\nand 0x0 in:\nL0_INVERT   =0\nL0_PRESCALER=0\n', 'void', 'disableClasses', []], ['L0', 'read all rates (scalers) from hw to Klas structure\n', 'void', 'hw2rates', []], ['L0', 'read all rates (scalers) from hw to Klas structure\n', 'void', 'rates2hw', []], ['L0', 'get rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2 INTSEL1 INTSEL2 allrare\n', 'void', 'getShared', []], ['L0', 'set rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2\n', 'void', 'setShared', [['r1', 'w32', ''], ['r2', 'w32', ''], ['bs1', 'w32', ''], ['bs2', 'w32', ''], ['int1', 'w32', ''], ['int2', 'w32', ''], ['intt', 'w32', ''], ['l0fun1', 'w32', ''], ['l0fun2', 'w32', '']]], ['L0', 'set INTERACTSEL ALL_RARE_FLAG\n', 'void', 'setShared2', [['intsel', 'w32', ''], ['allrare', 'w32', '']]], ['L0', 'check spy memory (256 words from 0x9400 on L0 board )\nOperation: \n- write a, a+1 a+2 ... \n- read back and check\n- write 0s to all the 256 words\n', 'void', 'clearSPY', [['board', 'int', '']]], ['L0', 'read BC masks from HW and print out 3564 4bits words\n', 'void', 'getBCmasks', []], ['L0', 'set BC masks in HW from input line containing 3564 hexa-chars.\n', 'void', 'setBCmasks', []], ['L0', 'set/read/check ntimes\nwords: if 0 than checj whole BCmask memory (3564)\n', 'void', 'checkBCmasks', [['ntimes', 'int', ''], ['words', 'int', '']]], ['L012', 'Print all counters to stdout (1 per line)\nif accrual==1, than print accruals\n', 'void', 'getCounters', [['accrual', 'int', '']]], ['L012', 'Clear all counters\n', 'void', 'clearCounters', []], ['L0', 'get PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n', 'void', 'getPF', [['ix', 'int', '']]], ['L0', 'get PF parameters for 1 circuit \nI:\nL0, L1, or L2 -> ix= 1, 2 or 3\ncirc -> 1..5\nO: on stdout: 3 hexadecimal numbers: PFBLOCK_A, PFBLOCK_B, PFLUT\n', 'void', 'getPFc', [['ix', 'int', ''], ['circ', 'int', '']]], ['L0', 'set PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\npfc: PF_COMMON word\n', 'void', 'setPF', [['ix', 'int', ''], ['pfc', 'w32', '']]], ['L0', 'set PF parameters for 1 circuit \nI:\nL0, L1, or L2 -> ix= 1, 2 or 3\ncirc -> 1..5\nA, B, LUT -3 words to be written\n', 'void', 'setPFc', [['ix', 'int', ''], ['circ', 'int', ''], ['A', 'w32', ''], ['B', 'w32', ''], ['LUT', 'w32', '']]], ['L0', '1. Prepare 24 input signals in SSM, start it in continuous input generator mode.\n2. set step by step (keep 1 sec delay between settings) all 24 SYNCH_ADD\n   from 0 to 15\n', 'void', 'testSYNCH', []], ['busy', 'Set BC_DELAY from 0..31 with step 1, wait 1 sec between\nsteps: number of steps (0..34)\n', 'void', 'testBCDELAY', [['steps', 'int', '']]], ['busy', 'set Orbit on backplane to BC/2 signal.\nbit8: 1 ->set toggling     0->disable toggling\nNecessary for delay measurement on l0/l1/l2 board.\n', 'void', 'setOrbitBChalf', [['bit8', 'int', '']]], ['L0', '', 'void', 'findNS', []], ['L0', '', 'void', 'fdf', []], ['SimpleTests', '', 'void', 'ReadTemperatures', []], ['SimpleTests', '', 'void', 'TestLEDS', []], ['SimpleTests', 'Wait mics microeconds (using system usleep() call) ', 'void', 'micsleep', [['mics', 'int', '']]], ['Common', '   rc: 0 -board ix is in the crate \n       1 -board ix is not in the crate\n', 'int', 'notInCrate', [['ix', 'int', '']]], ['DbgSSMBROWSERcalls', 'return the names+modes of SSMs for present boards:\nstdout:\nname1 mode1 \nname2 mode2 \n...\nmode -mode of the ssm or:\n      _nomode if sms[ix].mode is epmty string\n      notin  board is not in the crate\n      nossm  if board or sms[ix].sm==NULL\n', 'void', 'gettableSSM', []], ['DbgSSMBROWSERcalls', 'return line:\nhighest_syncflag n1 n2...\nn1,n2 -numbers of items (indexes into sms[])\n', 'void', 'getsfSSM', [['board', 'int', '']]], ['DbgSSMBROWSERcalls', 'return line:\nhighest_syncflag n1 n2...\nn1,n2 -numbers of items (indexes into sms[])\n', 'void', 'getsyncedSSM', []], ['DbgSSMBROWSERcalls', "Extract 1 signal to stdout:\nInput:\nboard:   (0...) according to sms global array\nbit:     SSM bit (0-31)\nfrombc: bc number. \n         0 corresponds to word with address sms[board].offset\nbits:    number of bits to be examined (but don't print more then\n         102 lines)\nOutput:\nvalue_of_the_1st_bit      or <0 if error\nbit_number_for_which_value_changed\nbit_number_for_which_value_changed\n...\nErrors:\n-1 -> required SSM not read\n", 'void', 'getsigSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', ''], ['bits', 'int', '']]], ['DbgSSMBROWSERcalls', 'Find signal change.\nInput:\nboard,bit,frombc: as in getsigSSM()\nOutput (on stdout):\n-1 -signal does not change (or memory not accessible)\nn  - pointing to the last bit with the same value, next bit\n     is different\n', 'void', 'finddifSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', '']]], ['DbgSSMBROWSERcalls', 'print sms[board].offset\n', 'void', 'getoffsetSSM', [['board', 'int', '']]], ['DbgSSMBROWSERcalls', 'set sms[board].offset\n', 'void', 'setoffsetSSM', [['board', 'int', ''], ['newoffset', 'int', '']]], ['DbgSSMBROWSERcalls', 'set sms[board].mode, ltubase\nboard: 0..  index into sms[]\nnewmode: file name in CFG/ctp/ssmsigs without .sig suffix\nltubase: valid only for ltu (board>10)\n', 'void', 'setmodeSSM', [['board', 'int', ''], ['newmode', 'char', '*'], ['ltubase', 'char', '*']]], ['DbgSSMBROWSERcalls', 'set sms[board].offset\n', 'void', 'printsms', []], ['DebugSSMcalls', '-------------------------------------------------------------- getswSSM() \nreturn status word of SSM\nLTU: [4] FrontPanel->SSM mode active\n     [3] not used\n     [2] BUSY bit\n     [1..0] operation\nCTP: [8] -BUSY\n     [7..6] Enable SSM Input..Output flag\n     [5..4] ConfSel bits\n     [3..3] InOut flag   0:out   1:in\n     [2..1] Operation bits \n     [0..0] mode bit \nerror: 0xdeadbeaf\n', 'w32', 'getswSSM', [['board', 'int', '']]], ['DebugSSMcalls', '-------------------------------------------------------------- setsmssw() \nset sms[].mode\n', 'void', 'setsmssw', [['ix', 'int', ''], ['newmode', 'char', '*']]], ['DebugSSMcalls', "Set operation & mode. If SSM is BUSY, an attempt is made to stop\nthe recording.\nInput parameteres:\nboard -number of the board (index into global sms array) \n       0..NSSMBOARDS    (busy,L0,1,2,int,fo1,2,3,4,5,6,ltu1,2,3,4)\nopmo  -mode/operation bit for SSMcommand word. symbolic names \n       are defined in ctp.h (as SSMom*)\n\nopmo for LTU boards:\n--------------\n0x0 -VME access, read\n0x1 -VME access, write\n0x2 -RECORDING, After  (cca 26 milsec)\n0x3 -RECORDING, Before (should be stopped by SSMstoprec)\n\nBit opmo[4] (0x10) should be set to 1 for LTU/RECORDING mode\n    (new feature 'FrontPanel->SSM' introduced for LTU 7.10.2005)\n    If not set, signals from LTU-FPGA will be recorded.\n\nopmo for CTP boards:\n--------------\nThe codes above (0-3) are valid, in addition 7 bits (opmo[9..3] are\nmeaningfull, and 2 more codes are added:\n0x4 - GENERATING, single pass\n0x5 - GENERATING, continuous\nopmo[9..8] - bits to be used for selecting SSMenable word\n             10 ->enable Input    01 ->enable Output\nopmo[7..6] - not used\nopmo[5..4] - ConfSel bits  (defined in \n               $VMECFDIR/CFG/ctp/ssmsigs/.sig files)\nopmo[3]      - InOut flag   1:in   0:out (side of FPGA logic)\nExamples: \n0x20d - generate continuously  inputs for board logic\n0x20c - generate 1 pass (27ms) inputs for board logic\n0x102 - record   1 pass (27ms) of board logic outputs\nRC:  0->ok, mode set\n     1->mode not set, possible errors (printed to stdout):\n        -BC signal not connected\n        -Cannot stop recording operation\n     2->bad mode for LTU board\n", 'int', 'setomSSM', [['board', 'int', ''], ['opmo', 'w32', '']]], ['DebugSSMcalls', '', 'int', 'startSSM1', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------- stopSSM()\nOpearation:\n- check if board is in BUSY status\n- stop (recording or generation)\nrc: == 0 OK\n       1 board not busy, no action\n       2 problem with openvme for LTU\n', 'int', 'stopSSM', [['board', 'int', '']]], ['DebugSSMcalls', '--------------------------------------------------------- readSSM()\nread whole SSM into array of unsigned ints\nNote: InOut, ConfSel bits and SSMenable word left unchanged\nInput:\nboard: board according to sms global array\nOutput:\nrc:  0 SSM read into sms[board].sm->\n', 'int', 'readSSM', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------ writeSSM()\nwrite whole sms[].sm into hardware\nNote: InOut, ConfSel bits and SSMenable word left unchanged\nInput:\nboard: board according to sms global array\nrc:    0: no errors found during writing\n', 'int', 'writeSSM', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------ dumpSSM()\nwrite whole sms[].sm into hardware\nInput:\nboard: board according to sms global array\nrc:    0: no errors found during writing\n', 'int', 'dumpSSM', [['board', 'int', ''], ['fname', 'char', '*']]], ['DebugSSMcalls', "print to stdout SSM board from word 'fromadr'\n", 'void', 'printSSM', [['board', 'int', ''], ['fromadr', 'int', '']]]]
