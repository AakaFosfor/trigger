/* generated by comp.py */
#include <stdio.h>
#include "vmewrap.h"
#include "lexan.h"
#include "vmeaistd.h"

char BoardName[]="ctpt";
char BoardBaseAddress[11]="0x820000";
char BoardSpaceLength[11]="0xd000";
char BoardSpaceAddmod[11]="A24";
char readHWL1class_usagehelp[]="--------------------------------------------------------readHWL1class\n\
";

char printHWL1class_usagehelp[]="-------------------------------------------------------printHWL1class\n\
";

Tpardesc getswSSM_parameters[1]={
{"board", 1}};
char getswSSM_usagehelp[]="-------------------------------------------------------------- getswSSM() \n\
return status word of SSM\n\
LTU: [4] FrontPanel->SSM mode active\n\
     [3] not used\n\
     [2] BUSY bit\n\
     [1..0] operation\n\
CTP: [8] -BUSY\n\
     [7..6] Enable SSM Input..Output flag\n\
     [5..4] ConfSel bits\n\
     [3..3] InOut flag   0:out   1:in\n\
     [2..1] Operation bits \n\
     [0..0] mode bit \n\
error: 0xdeadbeaf\n\
";

Tpardesc setsmssw_parameters[2]={
{"ix", 1},
{"newmode", 3| 0x80000000}};
char setsmssw_usagehelp[]="-------------------------------------------------------------- setsmssw() \n\
set sms[].mode\n\
";

Tpardesc setomSSM_parameters[2]={
{"board", 1},
{"opmo", 2}};
char setomSSM_usagehelp[]="Set operation & mode. If SSM is BUSY, an attempt is made to stop\n\
the recording.\n\
Input parameteres:\n\
board -number of the board (index into global sms array) \n\
       0..NSSMBOARDS    (busy,L0,1,2,int,fo1,2,3,4,5,6,ltu1,2,3,4)\n\
opmo  -mode/operation bit for SSMcommand word. symbolic names \n\
       are defined in ctp.h (as SSMom*)\n\
\n\
opmo for LTU boards:\n\
--------------\n\
0x0 -VME access, read\n\
0x1 -VME access, write\n\
0x2 -RECORDING, After  (cca 26 milsec)\n\
0x3 -RECORDING, Before (should be stopped by SSMstoprec)\n\
\n\
Bit opmo[4] (0x10) should be set to 1 for LTU/RECORDING mode\n\
    (new feature 'FrontPanel->SSM' introduced for LTU 7.10.2005)\n\
    If not set, signals from LTU-FPGA will be recorded.\n\
\n\
opmo for CTP boards:\n\
--------------\n\
The codes above (0-3) are valid, in addition 7 bits (opmo[9..3] are\n\
meaningfull, and 2 more codes are added:\n\
0x4 - GENERATING, single pass\n\
0x5 - GENERATING, continuous\n\
opmo[9..8] - bits to be used for selecting SSMenable word\n\
             10 ->enable Input    01 ->enable Output\n\
opmo[7..6] - not used\n\
opmo[5..4] - ConfSel bits  (defined in \n\
               $VMECFDIR/CFG/ctp/ssmsigs/.sig files)\n\
opmo[3]      - InOut flag   1:in   0:out (side of FPGA logic)\n\
Examples: \n\
0x20d - generate continuously  inputs for board logic\n\
0x20c - generate 1 pass (27ms) inputs for board logic\n\
0x102 - record   1 pass (27ms) of board logic outputs\n\
RC:  0->ok, mode set\n\
     1->mode not set, possible errors (printed to stdout):\n\
        -BC signal not connected\n\
        -Cannot stop recording operation\n\
     2->bad mode for LTU board\n\
";

Tpardesc startSSM1_parameters[1]={
{"board", 1}};
Tpardesc stopSSM_parameters[1]={
{"board", 1}};
char stopSSM_usagehelp[]="------------------------------------------------------- stopSSM()\n\
Opearation:\n\
- check if board is in BUSY status\n\
- stop (recording or generation)\n\
rc: == 0 OK\n\
       1 board not busy, no action\n\
       2 problem with openvme for LTU\n\
";

Tpardesc condstopSSM_parameters[4]={
{"board", 1},
{"cntpos", 1},
{"maxloops", 1},
{"sleepafter", 1}};
char condstopSSM_usagehelp[]="Opearation:\n\
- read counter cntpos\n\
- check 'the change of this counter' + check maxloops\n\
- sleep 'sleepafter' micsecs (should be 0 or at least 100)\n\
- stop (recording or generation) -> call stopSSM()\n\
Inputs:\n\
cntpos: position of the counter (starting from 0) for this board\n\
        see 2. column in dimcdistrib/cnames.sorted2 file\n\
maxloops: max. number of loops (1 loop == cca 2 ms)\n\
rc: == 0 OK\n\
   1 board not busy, no action (i.e. SSM was not started before in\n\
     'BEFORE/continuous' mode)\n\
   2 problem with openvme for LTU\n\
  10 timeout (counter did not change even after 'maxloops' reads)\n\
--------------------- ";

Tpardesc readSSM_parameters[1]={
{"board", 1}};
char readSSM_usagehelp[]="--------------------------------------------------------- readSSM()\n\
read whole SSM into array of unsigned ints\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
Output:\n\
rc:  0 SSM read into sms[board].sm->\n\
       i.e. Mega words were read\n\
    >0 only part of SSM was read into sms[board].sm-> \n\
       reason in After or Before mode:\n\
       - SSM stopped early (<26ms)\n\
";

Tpardesc writeSSM_parameters[1]={
{"board", 1}};
char writeSSM_usagehelp[]="------------------------------------------------------ writeSSM()\n\
write whole sms[].sm into hardware\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
";

Tpardesc dumpSSM_parameters[2]={
{"board", 1},
{"fname", 3| 0x80000000}};
char dumpSSM_usagehelp[]="------------------------------------------------------ dumpSSM()\n\
write whole sms[].sm into hardware\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
";

Tpardesc printSSM_parameters[2]={
{"board", 1},
{"fromadr", 1}};
char printSSM_usagehelp[]="print to stdout SSM board from word 'fromadr'\n\
";

Tpardesc readSSMDump_parameters[2]={
{"board", 1},
{"filename", 3| 0x80000000}};
char readSSMDump_usagehelp[]=" Read binary dump written by dumpSSM() to the sms[board].sm\n\
";

Tpardesc readL0count_parameters[2]={
{"board", 1},
{"readHW", 1}};
char readL0count_usagehelp[]="------------------------------------------------readL0count()\n\
 *  1= BUSY\n\
 *  0= ok\n\
 *  redaHW =1 : reads Counters\n\
 *          0 : reads only memory\n\
 ";

Tpardesc printL0count_parameters[1]={
{"board", 1}};
char printL0count_usagehelp[]="-----------------------------------------------printL0count()\n\
 ";

Tpardesc readHWrate_parameters[1]={
{"board", 1}};
char readHWrate_usagehelp[]="-----------------------------------------readHWrate()\n\
 * Reads down sacle factors for every class\n\
 ";

Tpardesc printHWrate_parameters[1]={
{"boards", 1}};
char printHWrate_usagehelp[]="-----------------------------------------printHWrate()\n\
 * Prints presacling factors.\n\
 ";

Tpardesc setRate_parameters[2]={
{"class", 1},
{"rate", 2}};
char setRate_usagehelp[]="-----------------------------------------setRate()\n\
 *  Set rate for class i. 1st class: i=0; \n\
 *  Writes to cpu memory.\n\
 ";

Tpardesc writeHWrate_parameters[1]={
{"board", 1}};
char writeHWrate_usagehelp[]="-----------------------------------------writeHWrate()\n\
 * Writes pre scaling factors to board\n\
 ";

Tpardesc readHWL0class_parameters[1]={
{"board", 1}};
char readHWL0class_usagehelp[]="------------------------------------------------------readHW()\n\
 * Reads Class L0 trigger definition from hardware.\n\
";

Tpardesc printHWL0class_parameters[1]={
{"board", 1}};
char printHWL0class_usagehelp[]="------------------------------------------printHWL0class\n\
 * Print L0 class HW settings\n\
";

Tpardesc testRate_parameters[4]={
{"board", 1},
{"overflow", 1},
{"rate", 1},
{"downscale", 1}};
char testRate_usagehelp[]="-----------------------------------------------------testRate()\n\
 ";

Tpardesc L0classoutmonT_parameters[4]={
{"board", 1},
{"cptdt", 1},
{"l0strobe", 1},
{"chan", 1}};
char L0classoutmonT_usagehelp[]="--------------------------------------------------------L0outmon\n\
 * Cluster emulation in outmon mode\n\
 * What is this ?\n\
";

char gettableSSM_usagehelp[]="return the names+modes of SSMs for present boards:\n\
stdout:\n\
name1 mode1 \n\
name2 mode2 \n\
...\n\
mode -mode of the ssm or:\n\
      _nomode if sms[ix].mode is epmty string\n\
      notin  board is not in the crate\n\
      nossm  if board or sms[ix].sm==NULL\n\
";

Tpardesc getsfSSM_parameters[1]={
{"board", 1}};
char getsfSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

char getsyncedSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

Tpardesc getsigSSM_parameters[4]={
{"board", 1},
{"bit", 1},
{"frombc", 1},
{"bits", 1}};
char getsigSSM_usagehelp[]="Extract 1 signal to stdout:\n\
Input:\n\
board:   (0...) according to sms global array\n\
bit:     SSM bit (0-31)\n\
frombc: bc number. \n\
         0 corresponds to word with address sms[board].offset\n\
bits:    number of bits to be examined (but don't print more then\n\
         102 lines)\n\
Output:\n\
value_of_the_1st_bit      or <0 if error\n\
bit_number_for_which_value_changed\n\
bit_number_for_which_value_changed\n\
...\n\
Errors:\n\
-1 -> required SSM not read\n\
";

Tpardesc finddifSSM_parameters[3]={
{"board", 1},
{"bit", 1},
{"frombc", 1}};
char finddifSSM_usagehelp[]="Find signal change.\n\
Input:\n\
board,bit,frombc: as in getsigSSM()\n\
Output (on stdout):\n\
-1 -signal does not change (or memory not accessible)\n\
n  - pointing to the last bit with the same value, next bit\n\
     is different\n\
";

Tpardesc getoffsetSSM_parameters[1]={
{"board", 1}};
char getoffsetSSM_usagehelp[]="print sms[board].offset\n\
";

Tpardesc setoffsetSSM_parameters[2]={
{"board", 1},
{"newoffset", 1}};
char setoffsetSSM_usagehelp[]="set sms[board].offset\n\
";

Tpardesc setmodeSSM_parameters[3]={
{"board", 1},
{"newmode", 3| 0x80000000},
{"ltubase", 3| 0x80000000}};
char setmodeSSM_usagehelp[]="set sms[board].mode, ltubase\n\
board: 0..  index into sms[]\n\
newmode: file name in CFG/ctp/ssmsigs without .sig suffix\n\
ltubase: valid only for ltu (board>10)\n\
";

char printsms_usagehelp[]="set sms[board].offset\n\
";

Tpardesc getPFHW_parameters[2]={
{"board", 1},
{"ipf", 1}};
char getPFHW_usagehelp[]="--------------------------------------getPFHW()\n\
 ";

char printPFHW_usagehelp[]="-----------------------------------------------------printPFHW()\n\
 ";

Tpardesc printPFHWs_parameters[1]={
{"board", 1}};
char printPFHWs_usagehelp[]=" * Read HW from board and prints\n\
";

Tpardesc setPFHW_parameters[2]={
{"board", 1},
{"ipf", 1}};
char setPFHW_usagehelp[]=" * Write current HardWare PF to board\n\
 ";

Tpardesc getPF_parameters[1]={
{"ix", 1}};
char getPF_usagehelp[]="get PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
";

Tpardesc getPFc_parameters[2]={
{"ix", 1},
{"circ", 1}};
char getPFc_usagehelp[]="get PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
O: on stdout: 3 hexadecimal numbers: PFBLOCK_A, PFBLOCK_B, PFLUT\n\
";

Tpardesc setPF_parameters[2]={
{"ix", 1},
{"pfc", 2}};
char setPF_usagehelp[]="set PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
pfc: PF_COMMON word\n\
";

Tpardesc setPFc_parameters[5]={
{"ix", 1},
{"circ", 1},
{"A", 2},
{"B", 2},
{"LUT", 2}};
char setPFc_usagehelp[]="set PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
A, B, LUT -3 words to be written\n\
";

Tpardesc printPFwc_parameters[1]={
{"deltat", 1}};
char printPFwc_usagehelp[]="Print setings (12 hexa numbers) of PFcircuit for deltat in BCs\n\
First hexa number is 0xffffffff if error\n\
";

Tpardesc notInCrate_parameters[1]={
{"ix", 1}};
Tpardesc findBUSYINP_parameters[2]={
{"fo", 1},
{"foc", 1}};
Tpardesc getCounter_parameters[2]={
{"board", 1},
{"reladr", 1}};
Tpardesc getCounters_parameters[2]={
{"N", 1},
{"accrual", 1}};
Tpardesc findDeadBusysRuns_parameters[1]={
{"time", 1}};
char findDeadBusysRuns_usagehelp[]=" Input: time in milisecs\n\
 For detectors in clusters as defined on busy board \n\
 it calculates and prints average: \n\
  -fraction of the time detectors is busy \n\
  -average deadtime\n\
";

Tpardesc printLastDetectors_parameters[1]={
{"cluster", 2}};
char printLastDetectors_usagehelp[]=" For detectors in clusters as defined on busy board\n\
 it reads LasBusy counter.\n\
 Last busy counts number of cases when detector is releasing busy LAST\n\
 in given cluster.\n\
";

Tpardesc busyprobe_parameters[1]={
{"det", 3| 0x80000000}};
char busyprobe_usagehelp[]="Busy probe option - minimax select word\n\
Select the object you want to study:\n\
0- CTP BUSY\n\
1-24 : detectors\n\
25-30 : clusters\n\
31 test cluster\n\
";

char findDeadBusys_usagehelp[]="Operation:\n\
- read busy timers\n\
- sleep 100ms\n\
- read busy timers \n\
- calculate difference between 2 measurements and compare \n\
  with busy_timer\n\
rc: busy pattern: [0..23] bits set to 1 correspond to Dead busy inputs\n\
";

Tpardesc GenSwtrg_parameters[5]={
{"n", 1},
{"trigtype", 3},
{"roc", 1},
{"BC", 2},
{"detectors", 2}};
Tpardesc checkScopeBoard_parameters[1]={
{"ab", 3}};
Tpardesc setScopeBoard_parameters[2]={
{"ab", 3},
{"board", 1}};
Tpardesc getScopeSignal_parameters[2]={
{"board", 1},
{"ab", 3}};
Tpardesc setScopeSignal_parameters[3]={
{"board", 1},
{"ab", 3},
{"signal", 1}};
Tpardesc setVMERWScope_parameters[2]={
{"newv", 2},
{"oldv", 2}};
Tpardesc getSWLEDS_parameters[1]={
{"ixboard", 1}};
char getSWLEDS_usagehelp[]="Print 1 line string xxxx\n\
where x is the status (0/1) of software LED word\n\
";

Tpardesc setEdge_parameters[3]={
{"board", 1},
{"input", 2},
{"edge", 2}};
char setEdge_usagehelp[]="board:0:busy (the CLK edge for input ORBIT signal) \n\
      1..3:L0/1/2  \n\
input: busy: no sense,  L0,L1:1..24   L2:1..12\n\
edge: 0:Positive 1:Negative\n\
";

char README_usagehelp[]=" Algorithm(1):\n\
  - write to generating board simple pattern: e.g.1000100010001...\n\
  - start receiving board\n\
  - start generating board\n\
  - wait\n\
  - stop all boards\n\
  This fails often due to the wrong bits either at the begining of \n\
  recording in ssmssm or start of generation. \n\
  SO BEFORE CLAIMING WRONG CONNECTION CHECK IT. \n\
  You will see inapropriate bit at the beginning of ssm or at the begining\n\
  of recording.\n\
  To avoid this problem a new algoritm was introduced.\n\
  Algoritm (2):\n\
  - write to the generating board any pattern (even more complcated) BUT\n\
    its length should be divider if the ssm size, i.e multiple of 2.\n\
  - start generating ssm in continuous mode\n\
  - start receiving board \n\
  - stop boards\n\
  By this you avoid problem with the start of generation errors\n\
";

Tpardesc FOLTUConnection_parameters[1]={
{"ltu", 1}};
char FOLTUConnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Connections between FO -> LTUs.\n\
 * FO2LTU() -- ltu1 = top connector -> first in parameters !!!\n\
 * FO mode\n\
 ltu = 11 : 0x811000 tested\n\
     = 12 : 0x812000 testes\n\
";

char FOL0L1mode_usagehelp[]=" * ------------------------------------------------------------------\n\
 * FO L0/L1 logic\n\
 * FO: generates PP,L0,L1,L1data\n\
 * LTU: receives PP,L0,L1,L1data\n\
 * FO2LTU() -- ltu1 = top connector -> first in parameters !!!\n\
 * FO mode\n\
 * RULE for FO->LTU CABLE CONNECTIONS:\n\
 * the lowest LTU VME dial goes to top FO connector(=ltu1)\n\
 * RULE for BUSY CABLE CONNECTIONS:\n\
 * the ltu1 = 1st busy input\n\
";

char FOL2mode_usagehelp[]=" * ------------------------------------------------------------------\n\
 * FO L2 logic\n\
 * FO: Generates L2strobe,L2Data1,L2Data2\n\
 * LTU: receives L2strobe, L2data/\n\
 * FO2LTU() -- ltu1 = top connector -> first in parameters !!!\n\
 * FO mode\n\
";

char L0FOconnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0->FO connection\n\
 * L0 generates: l0clstt,l0clst[6..1],l0strobe,l0data,pp,int[2..1]\n\
 * F0 receives: l0clstt,l0clst[6..1],pp at input\n\
 *              l0data,int are on other board\n\
 *              pp[4..1],l0[4..1] at output\n\
 *              \n\
 * L0 mode             \n\
";

char L0FOconnection2_usagehelp[]=" * Different way of connection test:\n\
  - generating board go to continuous\n\
 * L0 mode\n\
";

char L0L1connection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0->L1 connection\n\
 * L0 mode\n\
 ";

char L0L2connection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0->L2 connection\n\
 * L0 mode\n\
 ";

char L0INTconnection_usagehelp[]=" *------------------------------------------------------------------\n\
 * L0->INT connections\n\
 * L0 mode\n\
 ";

char L0ingener_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L0 class logic NOT FINISHED\n\
 * L0 generates: l0clstt,l0clst[6..1],l0strobe,l0data,pp,int[2..1]\n\
 * F0 receives: l0clstt,l0clst[6..1],pp at input\n\
 *              l0data,int are on other board\n\
 *              pp[4..1],l0[4..1] at output\n\
 * L0 mode     \n\
";

char L0outmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Output Monitor mode\n\
 *  Start L0 in recording mode and read SSM to memory.\n\
 *  L0 mode\n\
 ";

char L0inmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Input Monitor mode\n\
 *  Start L0 in recording mode and read SSM to memory.\n\
 *  L0 mode\n\
 ";

Tpardesc L0testPF_parameters[10]={
{"tha1", 2},
{"tha2", 2},
{"thb1", 2},
{"thb2", 2},
{"deltaTa", 2},
{"deltaTb", 2},
{"sbc1", 2},
{"resa", 2},
{"resb", 2},
{"lut12D", 2}};
char L0testPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  Output Monitor mode: testing L0 PF\n\
 *  Input: almost all p/f settings\n\
 *  Set HW according to input\n\
 *  Examples with SB: \n\
 *            th=1,deltaT=4,sbc1=3,res=0\n\
 *            th=1,deltaT=3,sbc1=6,res=1\n\
 *            th=1,deltaT=2,sbc1=7,res=2\n\
 *            th=1,deltaT=5,sbc1=10,res=1\n\
 *  L0 mode\n\
";

Tpardesc L0testPF2_parameters[1]={
{"ipf", 1}};
char L0testPF2_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Output Monitor mode: testing L0 PF\n\
 *  Input: ipf : circuit\n\
 *  Read HW settings from HW !\n\
 *  Examples with SB: \n\
 *            th=1,deltaT=4,sbc1=3,res=0\n\
 *            th=1,deltaT=3,sbc1=6,res=1\n\
 *            th=1,deltaT=2,sbc1=7,res=2\n\
 *            th=1,deltaT=5,sbc1=10,res=1\n\
 *  L0 mode\n\
";

Tpardesc L0rndPF_parameters[1]={
{"ipf", 1}};
char L0rndPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 Output Monitor mode: testing L0 PF by random HW settings\n\
 *  L0 mode\n\
";

char L0rndallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  Output Monitor mode: testing all 5 L0 PF by random HW settings\n\
 *  L0 mode\n\
";

char L0classlogic_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L0 class logic\n\
 *  Classes generated by BC downscale or RND\n\
 *  AJ version exists\n\
 *  L0 mode\n\
";

Tpardesc L1testPF2_parameters[1]={
{"ipf", 1}};
char L1testPF2_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 generates int1/int2 in outgen mode by user defined sequence !\n\
 * L1 outmon getting p/f\n\
 * L2 inmon getting int1/int2\n\
 * L0 mode\n\
 ";

char L1classlogic2_usagehelp[]=" *------------------------------------------------------------------\n\
 * L1 class logic testing\n\
 * L0 generates in L0 outgen\n\
 * L1 inmon, L2 inmon\n\
 * L0 mode\n\
";

char L1ingener_usagehelp[]=" * ------------------------------------------------------------------\n\
 * check if necessary     \n\
";

char L1outmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L1 Output Monitor mode\n\
 *  Start L1 in recording mode and read SSM to memory.\n\
 *  L1 mode\n\
 ";

char L1inmon_usagehelp[]=" * ------------------------------------------------------------------\n\
 *  L1 Input Monitor mode\n\
 *  Start L1 in recording mode and read SSM to memory.\n\
 *  L1 mode\n\
 ";

char L1ingen_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 Input genereting mode\n\
 * L1 mode\n\
";

char L1L2Connect_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1->L2 connection\n\
 * L1 mode\n\
 ";

char L1FOconnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1-> FO connection\n\
 * L1 mode\n\
 ";

char L1INTconnection_usagehelp[]=" * L1-> FO connection\n\
 * L1 mode\n\
 ";

char L2classlogic_usagehelp[]=" * L2 class logic testing\n\
 * L1 outgen generates l1 strobe and l1data\n\
 * L2 outmon monitors l2 strobe and l2 data\n\
 * L1 mode\n\
 ";

Tpardesc L1testPF3_parameters[1]={
{"ipf", 1}};
char L1testPF3_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 board generating int1,int2 by BC down or RND\n\
 * L0 ssm outmon giving int2,int1\n\
 * L1 ssm outmon giving pf\n\
 * none mode\n\
 ";

Tpardesc L1testPF4_parameters[1]={
{"ipf", 1}};
char L1testPF4_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 board generates int1/2 by BC down or RND\n\
 * L1 board ssm gives inta/b/d -> pf1\n\
 * All analysis on L1 board ssm\n\
 * L1 mode\n\
 ";

char L1rndallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L1 P/F testing:\n\
 * L0 board generates int1/2 by BC down or RND\n\
 * L1 board ssm gives inta/b/d -> pf1\n\
 * All analysis on L1 board ssm\n\
 * L1 mode\n\
 ";

char L1classlogic_usagehelp[]=" * L1 class logic testing\n\
 * L1 ingen generates l0strobe and l0 data\n\
 * L2 unmon monitors l1 strobe l1 data\n\
 ";

char L2FOconnection_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L2->FO connection\n\
 * L2 mode\n\
 ";

char L2INTconnection_usagehelp[]=" * L2->INT connection\n\
 * L2 mode\n\
 ";

char L2INT_usagehelp[]=" *------------------------------------------------------------------\n\
 * Testing interface board\n\
 * L2 generates l2a in outgen mode. \n\
 * The correct content of the l2 ssm should be recorded in advance\n\
   It is not going to work:\n\
                    - generation is not stopped when ctp_busy\n\
                    - I cannot enable dll just after ssm start due to sw\n\
   I go via macro\n\
 * L2 mode\n\
 ";

char L2rndallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L2 P/F testing:\n\
 * L0 board generates int1/2 by BC down or RND\n\
 * L2 board ssm gives inta/b/d -> pf1\n\
 * All analysis on L2 board ssm\n\
 * L2 mode\n\
 ";

char L2classlogic2_usagehelp[]=" *-------------------------------------------------------------------\n\
 * L2 class logic testing\n\
 * L2 ingen \n\
 * FO inmon\n\
 * this can be done via script also\n\
";

Tpardesc L2testPF3_parameters[1]={
{"ipf", 1}};
char L2testPF3_usagehelp[]=" * ------------------------------------------------------------------\n\
 * L2 P/F testing:\n\
 * L0 board generating int1,int2 by BC down or RND\n\
 * L0 ssm outmon giving int2,int1\n\
 * L2 ssm outmon giving pf\n\
 * none mode\n\
 ";

char L0outL1inL2in_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 inmon,L2 inmon\n\
 * none mode\n\
 ";

char L0outL1outL2out_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 outmon,L2 outmon\n\
 * none mode\n\
 ";

char L1outFOs_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 outmon,L2 outmon,FO\n\
 * L0 mode\n\
 ";

char L0outL1outL2outBusy_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 outmon, L1 outmon,L2 outmon,Busy\n\
 * none mode\n\
 ";

char L0inBUout_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor : L0 inmon, busy outmon\n\
 * none mode\n\
 ";

char BCoffset_usagehelp[]=" * generate synchronous sw trigger and check BC in ssm\n\
 * none mode\n\
 ";

char MonallPF_usagehelp[]=" * ------------------------------------------------------------------\n\
 * Monitor all PF at L0,L1,L2\n\
 * none mode\n\
 ";

char FOL1mon_usagehelp[]=" * -----------------------------------------------------------------\n\
 * L2 monitor mode on FO\n\
 * none mode\n\
 ";

char FOLTU_usagehelp[]=" *none mode\n\
";

char L2a2INT_usagehelp[]=" *-------------------------------------------------------------------\n\
 * L1 outmon for int1,int2\n\
 * L2 outmon for L2data1,L2data2\n\
 * INT outmon for CTP readout\n\
 * Compares L2 serial data woth CTP readout\n\
 * interaction record may be added\n\
 * none mode\n\
";

char dumpINTSSM_usagehelp[]=" * Dump Interface SSM to file IntDump.txt\n\
 ";

char BUconnect_usagehelp[]=" * BUSY connections\n\
 * busy mode\n\
 ";

char INTL0connection_usagehelp[]=" * INT->L0 connection (only ctp_busy)\n\
 * int mode\n\
 ";

Tpardesc Comp2Channels_parameters[3]={
{"board1", 1},
{"chan", 1},
{"start", 1}};
char Comp2Channels_usagehelp[]=" * Compares 2 channels in the snapshot memory\n\
 ";

char CompallPF_usagehelp[]=" * Compares one by one all pf chanels (14-18)\n\
 ";

Tpardesc scanOrbit_parameters[1]={
{"board", 1}};
char DebugSync_usagehelp[]="-----------------------------------------------------------\n\
Debugging sync by generating ssm in memory.\n\
 ";

Tpardesc checkToggle_parameters[2]={
{"board", 1},
{"channel", 1}};
char checkToggle_usagehelp[]="--------------------------------------------------------\n\
";

Tpardesc genSeq_parameters[3]={
{"board", 1},
{"Period", 1},
{"Start", 1}};
char genSeq_usagehelp[]=" * ---------------------------------------------------------------genSeq()\n\
   Generates sequence of length Length and period Period.\n\
   E.g. it enables to generate array which correspond to orbit channel\n\
";

Tpardesc writeSPn_parameters[4]={
{"board", 1},
{"Start", 1},
{"Period", 1},
{"n", 2}};
char writeSPn_usagehelp[]=" * --------------------------------------------------------------WriteSPn()\n\
 Write int n to ssm structure with period Period from Start. \n\
 Not to hardware !\n\
";

Tpardesc writeSPb_parameters[4]={
{"board", 1},
{"Start", 1},
{"Period", 1},
{"Channel", 1}};
char writeSPb_usagehelp[]=" * --------------------------------------------------------------WriteSPb()\n\
 Write 1 to bit channel with Period from Start.\n\
 Not overwriting other bits.\n\
 ";

Tpardesc writeSPb2_parameters[5]={
{"board", 1},
{"Start", 1},
{"Period", 1},
{"length", 1},
{"Channel", 1}};
char writeSPb2_usagehelp[]=" * --------------------------------------------------------------WriteSPb2()\n\
 Write 11..1 of length length to bit channel with Period from Start.\n\
 Not overwriting other bits.\n\
 ";

Tpardesc writeSPP_parameters[4]={
{"board", 1},
{"Start", 1},
{"Channel", 1},
{"Pattern", 3| 0x80000000}};
char writeSPP_usagehelp[]="-----------------------------------------------------------------WriteSPP()\n\
Write bit pattern Pattern to channel n from Start. \n\
Pattern is string of (0-9),(a-f) which is interpreted as hexadecimal number.\n\
Least significant bits on the left.\n\
";

Tpardesc writeSPF_parameters[4]={
{"board", 1},
{"Start", 1},
{"Channel", 1},
{"Pattern", 3| 0x80000000}};
char writeSPF_usagehelp[]="-----------------------------------------------------------------WriteSPF()\n\
Write bit pattern Pattern to channel n from Start. \n\
Pattern is string with formated input, see form2i() help.\n\
";

Tpardesc form2i_parameters[3]={
{"patin", 3| 0x80000000},
{"patout", 1| 0x80000000},
{"nperiod", 1| 0x80000000}};
char form2i_usagehelp[]=" *----------------------------------------------------------------form2i()\n\
 * Aim: to generate binary pattern\n\
 * Input: string of formatted input: number1anumber2anumber3a\n\
                                       2a10a3\n\
                                      110000000000111\n\
   a - delimiter\n\
   number1 = number of 1, number2- number of 0 ....\n\
 * Output: array of integers [number1,number2,...]\n\
 ";

Tpardesc bcstat_parameters[2]={
{"board", 1},
{"n", 1}};
char bcstat_usagehelp[]=" Check the stability of bc status by reading it n times.\n\
 board - board number\n\
 n - number of readings\n\
";

Tpardesc bcstat2_parameters[1]={
{"n", 1}};
char bcstat2_usagehelp[]=" Check the stability of bc status by reading it n times.\n\
 All boards.\n\
 n - number of readings\n\
";

char CTP_Classes_usagehelp[]="The Classes definition, i.e. for each (1-50) class: \n\
 -enabling/disabling\n\
 -L0,L1,L2 inputs and selectable vetos\n\
 -cluster\n\
 -L0 pre-scaler\n\
";

char CTP_Clusters_usagehelp[]="The Clusters definition, i.e. which detectors (LTUs) belong to each cluster.\n\
Cluster definition consist of 'assignment of clusters to\n\
each Fanout connector'.\n\
";

char Resources_usagehelp[]="The Shared resources definition. They are:\n\
- random generators(2) and BC generators(2) rates\n\
- 3 Interaction functions (16 bits lookup tables)\n\
- 2 L0 input functions (16 bits lookup tables)\n\
- 2 Interaction selectors\n\
- All/Rare events CTP option\n\
- 5 Past/Future protection circuits for all trigger levels \n\
    (PF1-PF4 for physics and PF5 for Test Class)\n\
";

char Counters_usagehelp[]="Displays counters on all CTP boards\n\
";

char CheckTestClass_usagehelp[]="Test class control.\n\
";

char ScopeAB_usagehelp[]="Signal selection for front panel \n\
A,B outputs\n\
";

char SSMbrowser_usagehelp[]="Browse CTP snapshot memories \n\
";

char SSMcontrol_usagehelp[]="The CTP snapshot memories control\n\
";

char SaveFile_usagehelp[]="- Save configuration to WORK/.cfg configuration to file\n\
";

char LoadFile_usagehelp[]="- Load configuration from WORK/.cfg configuration to file\n\
Todo:\n\
- check hw configuration with the memory-configuration\n\
- Load (i.e. add) partition configuration (i.e. from .configuration\n\
  file prepared by partition editor)\n\
";

char Readhw_usagehelp[]="- Load configuration from CTP boards\n\
";

char Write2hw_usagehelp[]="- Write configuration into CTP boards\n\
";

Tpardesc DAQonoff_parameters[1]={
{"daqon", 1}};
char DAQonoff_usagehelp[]="daqon:0       ->daq active\n\
daqon:0xb     ->daq off (i.e. produce triggers in spite of DDL red diode \n\
                on INT board is on \n\
daqon: other  -> show current status.\n\
NOTE about LEDs on INT board:\n\
DDL interface: \n\
  green:DDL line ready, data not read out \n\
  flashing green: DDL line ready, data are read out\n\
  flashing orange: data are read out, backpressure is sometimes active\n\
                   (DAQ is not able to read everything)\n\
upper DDL LED:\n\
  red: INT is raising CTPBUSY on backlplane, because of full DDL buffers\n\
";

char readORBIT_READs_usagehelp[]="read/print 2 counters: L2_ORBIT_READ and INT_ORBIT_READ ";

char i2creadall_usagehelp[]="Go through all boards in the CTP crate and print:\n\
- I2C values  (4 voltages)\n\
- temperature (1 value in centigrades)\n\
";

Tpardesc setClusters_parameters[8]={
{"daqbsy", 2},
{"tc", 2},
{"c1", 2},
{"c2", 2},
{"c3", 2},
{"c4", 2},
{"c5", 2},
{"c6", 2}};
char setClusters_usagehelp[]="Set daqbsy, T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board\n\
";

char getClusters_usagehelp[]="Read T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board and print it as 1 line\n\
";

char getDAQbusy_usagehelp[]="Read DAQ_BUSY word ";

Tpardesc getFO_parameters[1]={
{"ix", 1}};
char getFO_usagehelp[]="ix: FO1BOARD..FO1BOARD+5   (6 FO boards)\n\
always read FO board's CLUSTER, TEST_CLUSTER words\n\
STDOUT:\n\
- no output                if ix FO is not in the crate\n\
cluster testcluster        for FO in the crate\n\
";

Tpardesc setFO_parameters[3]={
{"ix", 1},
{"cluster", 2},
{"tcluster", 2}};
char setFO_usagehelp[]="write to FO board's registers only if modified\n\
ix: FO1BOARD..FO1BOARD+5   (i.e. 5-10, 6 FO boards)\n\
cluster: 0x44332211      11 - bits [5..0]: clusters fed through 1st connector\n\
tcluster: 0xXCT4321\n\
X   : bits[31..28]: toggle signal on connector 4..1\n\
C   : bit[20]       calibration flag for sw trigger\n\
T   : bits[19..16]: sw trigger (test class) for connector 4..1\n\
4   : bits[15..12]: RoC for connector 4\n\
";

Tpardesc setFOrocs_parameters[2]={
{"calflag", 1},
{"roc", 2}};
char setFOrocs_usagehelp[]="set cal. flag and roc on ALL the FO boards\n\
";

Tpardesc swtrigger_parameters[1]={
{"ssm", 1}};
char swtrigger_usagehelp[]="Start SW trigger.\n\
Input:\n\
ssm: 1   ->start SSM recording in L0 output moinitoring mode before\n\
           starting trigger\n\
Operation:\n\
- clear flags\n\
- start SSM (optionally)\n\
- start sw trigger\n\
- usleep(200) -micsecs\n\
- read L0_TCSTATUS word\n\
Output:\n\
L0_TCSTATUS word\n\
ToDo: -for whic detector? \n\
      - ROC bits to be written to FO and INT board\n\
";

char getTCSTATUS_usagehelp[]="ret: TCSTATUS bits from L0,1,2 boards:\n\
Bits:\n\
4-0  L0_TCSTATUS bits\n\
5    L1_TCSTATUS bit3 (L1ack flag)\n\
7-6  L2_TCSTATUS bits (L2Aack and L2Rack)\n\
";

char getTCSET_usagehelp[]="ret: TC_SET bits from L0,1,2 boards:\n\
Bits:\n\
18-0  L0_TC_SET bits\n\
19   L1_TC_SET bit18 (P/F veto)\n\
20   L2_TC_SET bit24 (P/F/veto)\n\
";

Tpardesc setTCSET_parameters[2]={
{"tcset012", 2},
{"dets", 2}};
char setTCSET_usagehelp[]="tcset012 -extended mening (bits 18,19 -see getTCSET() )\n\
";

char clearTC_usagehelp[]="operation: clear TC flags on all the boards\n\
";

Tpardesc getClass_parameters[1]={
{"klas", 1}};
char getClass_usagehelp[]="klas: 1-50   -class number\n\
get L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n\
    L1_DEFINITION L1_INVERT L2_DEFINITION words for klas\n\
\n\
L0_INVERT, L1_INVERT are 0:for classes 1-44 or \n\
corresponding board is not in the crate\n\
";

Tpardesc setClass_parameters[8]={
{"klas", 1},
{"condition", 2},
{"invert", 2},
{"veto", 2},
{"scaler", 2},
{"l1def", 2},
{"l1invert", 2},
{"l2def", 2}};
char setClass_usagehelp[]="set L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n\
    L1_DEFINITION L1_INVERT L2_DEFINITION\n\
words for klas (1..50)\n\
ATTENTION: \n\
1. bit17 (0x10000) of veto is CLASS MASK bit written into bit0 of L0_MASK\n\
2. invert,l1invert -valid only for class>=45\n\
";

char disableClasses_usagehelp[]="disable all 50 classes, i.e.:\n\
- set all inputs,vetos as dontcare for all 50 classes i.e.:\n\
L0_CONDITION = 0xffffffff\n\
L0_VETO      = 0xfffffff0   (cluster0)\n\
and 0x0 in:\n\
L0_INVERT   =0\n\
L0_PRESCALER=0\n\
";

char hw2rates_usagehelp[]="read all rates (scalers) from hw to Klas structure\n\
";

char rates2hw_usagehelp[]="write all rates (scalers) from Klas structure to hw\n\
";

char getShared_usagehelp[]="get rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2 INTSEL1 INTSEL2 allrare\n\
";

Tpardesc setShared_parameters[9]={
{"r1", 2},
{"r2", 2},
{"bs1", 2},
{"bs2", 2},
{"int1", 2},
{"int2", 2},
{"intt", 2},
{"l0fun1", 2},
{"l0fun2", 2}};
char setShared_usagehelp[]="set rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2\n\
";

Tpardesc setShared2_parameters[2]={
{"intsel", 2},
{"allrare", 2}};
char setShared2_usagehelp[]="set INTERACTSEL ALL_RARE_FLAG\n\
";

Tpardesc clearSPY_parameters[1]={
{"board", 1}};
char clearSPY_usagehelp[]="check spy memory (256 words from 0x9400 on L0 board )\n\
Operation: \n\
- write a, a+1 a+2 ... \n\
- read back and check\n\
- write 0s to all the 256 words\n\
";

char getBCmasks_usagehelp[]="read BC masks from HW and print out 3564 4bits words\n\
";

char setBCmasks_usagehelp[]="set BC masks in HW from input line containing 3564 hexa-chars.\n\
";

Tpardesc checkBCmasks_parameters[2]={
{"ntimes", 1},
{"words", 1}};
char checkBCmasks_usagehelp[]="set/read/check ntimes\n\
words: if 0 than checj whole BCmask memory (3564)\n\
";

char testSYNCH_usagehelp[]="1. Prepare 24 input signals in SSM, start it in continuous input generator mode.\n\
2. set step by step (keep 1 sec delay between settings) all 24 SYNCH_ADD\n\
   from 0 to 15\n\
";

Tpardesc testBCDELAY_parameters[1]={
{"steps", 1}};
char testBCDELAY_usagehelp[]="Set BC_DELAY from 0..31 with step 1, wait 1 sec between\n\
steps: number of steps (0..34)\n\
";

Tpardesc orbitscan_parameters[1]={
{"steps", 1}};
char orbitscan_usagehelp[]="Set BC_DELAY from 0..31 with step 1, wait 300 sec between\n\
steps: number of steps \n\
Output: Table: delay Edgeflag\n\
";

Tpardesc setOrbitBChalf_parameters[1]={
{"bit8", 1}};
char setOrbitBChalf_usagehelp[]="set Orbit on backplane to BC/2 signal.\n\
bit8: 1 ->set toggling     0->disable toggling\n\
Necessary for delay measurement on l0/l1/l2 board.\n\
";

char dumpCounters_usagehelp[]="Dump choosen counters to file $VMEWORKDIR/counters.dump\n\
\n\
";

Tpardesc micsleep_parameters[1]={
{"mics", 1}};
char micsleep_usagehelp[]="Wait mics microeconds (using system usleep() call) ";

Tpardesc RNDsync_parameters[1]={
{"mask", 1}};
char RNDsync_usagehelp[]="Synchronise/desynchronise random generators\n\
mask:\n\
3 synchronise RND1 and RND2 generators on L0 board\n\
1 desynchronise RND1 and RND2 generators on L0 board\n\
";

char initmain_usagehelp[]="   rc: 0 -board ix is in the crate \n\
       1 -board ix is not in the crate\n\
";

Tpardesc vmeWR_parameters[2]={
{"board", 1},
{"loops", 1}};
char vmeWR_usagehelp[]="loops =0 : infinite loop\n\
Generates a lot of vme activity.\n\
";

Tpardesc testOrbit_parameters[1]={
{"board", 1}};
char testOrbit_usagehelp[]=" Tests distance between orbits and pulse lemgth.\n\
";

Tpardesc checkSSM_parameters[1]={
{"board", 1}};
char readSSMs_usagehelp[]="Read ssms from the WORK and align them,\n\
";

Tpardesc testStart_parameters[1]={
{"board", 1}};
char testStart_usagehelp[]="Used for measuring the ssm start by scope.\n\
";

Tpardesc testStop_parameters[1]={
{"board", 1}};
char testStop_usagehelp[]="Used for measuring stop ssm time by scope.\n\
";

Tpardesc correlate_parameters[6]={
{"from", 1},
{"to", 1},
{"board1", 1},
{"chan1", 1},
{"board2", 1},
{"chan2", 1}};
char correlate_usagehelp[]="Correlates two channels of 2 boards od ssm.\n\
";

Tpardesc trdssmtrigger_parameters[2]={
{"vmeadd", 1},
{"timeout", 1}};
char trdssmtrigger_usagehelp[]="vmeadd: vme address on FO\n\
         in pedja notation to be used as trigger\n\
e.g.: to trigger on serial number vmeadd= 0x2\n\
timeout: number of loops to wait\n\
         if timeout == 0, than infinite loop\n\
busy: inmon\n\
l0: outmon\n\
l1: outmon\n\
l2: inmon\n\
fo:inmono1\n\
\n\
NO ALIGNMENT os snapshots.\n\
";

Tpardesc L2a2Interface_parameters[3]={
{"boardl1", 1},
{"boardl2", 1},
{"boardint", 1}};
char L2a2Interface_usagehelp[]="-----------------------------------------------L2a2Interface()\n\
 *  analyze interface board data\n\
 *  L2alist - list of CTP readout from L2 board\n\
 *  INTlist - list of CTP readout and IR data from Interface board\n\
 ";

Tpardesc dumpIntSsm_parameters[1]={
{"board", 1}};
char dumpIntSsm_usagehelp[]="--------------------------------------------------dumpINTSSM()\n\
 * Dumps Interface board ssm. Word is in output if any bit nonzero.\n\
 * SSM should be read before\n\
 ";

Tpardesc dumpL2amesage_parameters[1]={
{"board", 1}};
char dumpL2amesage_usagehelp[]=" * get L2 message\n\
 ";

Tpardesc BCoffset2_parameters[2]={
{"bc0", 1},
{"ntimes", 1}};
char genSW_usagehelp[]="   Generate software triggers\n\
";

int readHWL1class();
void printHWL1class();
w32 getswSSM(int board);
void setsmssw(int ix, char *newmode);
int setomSSM(int board, w32 opmo);
int startSSM1(int board);
int stopSSM(int board);
int condstopSSM(int board, int cntpos, int maxloops, int sleepafter);
int readSSM(int board);
int writeSSM(int board);
int dumpSSM(int board, char *fname);
void printSSM(int board, int fromadr);
int readSSMDump(int board, char *filename);
int readL0count(int board, int readHW);
void printL0count(int board);
void readHWrate(int board);
void printHWrate(int boards);
void setRate(int class, w32 rate);
void writeHWrate(int board);
int readHWL0class(int board);
void printHWL0class(int board);
int testRate(int board, int overflow, int rate, int downscale);
int L0classoutmonT(int board, int cptdt, int l0strobe, int chan);
void gettableSSM();
void getsfSSM(int board);
void getsyncedSSM();
void getsigSSM(int board, int bit, int frombc, int bits);
void finddifSSM(int board, int bit, int frombc);
void getoffsetSSM(int board);
void setoffsetSSM(int board, int newoffset);
void setmodeSSM(int board, char *newmode, char *ltubase);
void printsms();
int getPFHW(int board, int ipf);
void printPFHW();
int printPFHWs(int board);
int setPFHW(int board, int ipf);
void dumpCTP();
void getPF(int ix);
void getPFc(int ix, int circ);
void setPF(int ix, w32 pfc);
void setPFc(int ix, int circ, w32 A, w32 B, w32 LUT);
void printPFwc(int deltat);
int notInCrate(int ix);
int findBUSYINP(int fo, int foc);
w32 getCounter(int board, int reladr);
void getCounters(int N, int accrual);
void clearCounters();
w32 findDeadBusysRuns(int time);
void printLastDetectors(w32 cluster);
void busyprobe(char *det);
w32 findDeadBusys();
int GenSwtrg(int n, char trigtype, int roc, w32 BC, w32 detectors);
int checkScopeBoard(char ab);
int setScopeBoard(char ab, int board);
int getScopeSignal(int board, char ab);
int setScopeSignal(int board, char ab, int signal);
int getVMERWScope();
void setVMERWScope(w32 newv, w32 oldv);
void getSWLEDS(int ixboard);
void setEdge(int board, w32 input, w32 edge);
void README();
int FOLTUConnection(int ltu);
int FOL0L1mode();
int FOL2mode();
int L0FOconnection();
int L0FOconnection2();
int L0L1connection();
int L0L2connection();
int L0INTconnection();
int L0ingener();
int L0outmon();
int L0inmon();
int L0testPF(w32 tha1, w32 tha2, w32 thb1, w32 thb2, w32 deltaTa, w32 deltaTb, w32 sbc1, w32 resa, w32 resb, w32 lut12D);
int L0testPF2(int ipf);
int L0rndPF(int ipf);
int L0rndallPF();
int L0classlogic();
int L1testPF2(int ipf);
int L1classlogic2();
int L1ingener();
int L1outmon();
int L1inmon();
int L1ingen();
int L1L2Connect();
int L1FOconnection();
int L1INTconnection();
int L2classlogic();
int L1testPF3(int ipf);
int L1testPF4(int ipf);
int L1rndallPF();
int L1classlogic();
int L2FOconnection();
int L2INTconnection();
int L2INT();
int L2rndallPF();
int L2classlogic2();
int L2testPF3(int ipf);
int L0outL1inL2in();
int L0outL1outL2out();
int L1outFOs();
int L0outL1outL2outBusy();
int L0inBUout();
int BCoffset();
int MonallPF();
int FOL1mon();
int FOLTU();
int L2a2INT();
int dumpINTSSM();
int BUconnect();
int INTL0connection();
int Comp2Channels(int board1, int chan, int start);
int CompallPF();
void scanOrbit(int board);
int DebugSync();
int checkToggle(int board, int channel);
int genSeq(int board, int Period, int Start);
int writeSPn(int board, int Start, int Period, w32 n);
int writeSPb(int board, int Start, int Period, int Channel);
int writeSPb2(int board, int Start, int Period, int length, int Channel);
int writeSPP(int board, int Start, int Channel, char *Pattern);
int writeSPF(int board, int Start, int Channel, char *Pattern);
int form2i(char *patin, int *patout, int *nperiod);
void bcstat(int board, int n);
void bcstat2(int n);
void DAQonoff(int daqon);
void readORBIT_READs();
void i2creadall();
void setClusters(w32 daqbsy, w32 tc, w32 c1, w32 c2, w32 c3, w32 c4, w32 c5, w32 c6);
void getClusters();
void getDAQbusy();
void getFO(int ix);
void setFO(int ix, w32 cluster, w32 tcluster);
void setFOrocs(int calflag, w32 roc);
w32 swtrigger(int ssm);
w32 getTCSTATUS();
w32 getTCSET();
void setTCSET(w32 tcset012, w32 dets);
void clearTC();
void getClass(int klas);
void setClass(int klas, w32 condition, w32 invert, w32 veto, w32 scaler, w32 l1def, w32 l1invert, w32 l2def);
void disableClasses();
void hw2rates();
void rates2hw();
void getShared();
void setShared(w32 r1, w32 r2, w32 bs1, w32 bs2, w32 int1, w32 int2, w32 intt, w32 l0fun1, w32 l0fun2);
void setShared2(w32 intsel, w32 allrare);
void clearSPY(int board);
void getBCmasks();
void setBCmasks();
void checkBCmasks(int ntimes, int words);
void testSYNCH();
void testBCDELAY(int steps);
void orbitscan(int steps);
void setOrbitBChalf(int bit8);
void findNS();
void fdf();
void dumpCounters();
void ReadTemperatures();
void TestLEDS();
void micsleep(int mics);
void RNDsync(int mask);
void initmain();
int vmeWR(int board, int loops);
int testOrbit(int board);
void checkSSM(int board);
int readSSMs();
void checkSSMs();
int testStart(int board);
int testStop(int board);
int correlate(int from, int to, int board1, int chan1, int board2, int chan2);
int trdssmtrigger(int vmeadd, int timeout);
int L2a2Interface(int boardl1, int boardl2, int boardint);
int dumpIntSsm(int board);
int dumpL2amesage(int board);
void BCoffset2(int bc0, int ntimes);
void genSW();

int nnames=301;
Tname allnames[MAXNAMES]={
{"ctp", tSYMNAME, NULL, (w32)BoardSpaceLength, 0.0, NULL, (w32)BoardBaseAddress, NULL},
{"CODE_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x4, NULL},
{"SERIAL_NUMBER", tVMEADR, NULL, 0, 0.0, NULL, 0x8, NULL},
{"VERSION_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0xc, NULL},
{"SOFT_RESET", tVMEADR, NULL, 0, 0.0, NULL, 0x28, NULL},
{"TEMP_START", tVMEADR, NULL, 0, 0.0, NULL, 0x58, NULL},
{"TEMP_STATUS", tVMEADR, NULL, 0, 0.0, NULL, 0x5c, NULL},
{"TEMP_READ", tVMEADR, NULL, 0, 0.0, NULL, 0x60, NULL},
{"FPGAVERSION_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x80, NULL},
{"TEST_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x7e0, NULL},
{"BC_STATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xc4, NULL},
{"SSMcommand", tVMEADR, NULL, 0, 0.0, NULL, 0x19c, NULL},
{"SSMstart", tVMEADR, NULL, 0, 0.0, NULL, 0x1a0, NULL},
{"SSMstop", tVMEADR, NULL, 0, 0.0, NULL, 0x1a4, NULL},
{"SSMaddress", tVMEADR, NULL, 0, 0.0, NULL, 0x1a8, NULL},
{"SSMdata", tVMEADR, NULL, 0, 0.0, NULL, 0x1ac, NULL},
{"SSMstatus", tVMEADR, NULL, 0, 0.0, NULL, 0x1b0, NULL},
{"SSMenable", tVMEADR, NULL, 0, 0.0, NULL, 0x1b4, NULL},
{"PLLreset", tVMEADR, NULL, 0, 0.0, NULL, 0x1bc, NULL},
{"ADC_START", tVMEADR, NULL, 0, 0.0, NULL, 0xcc, NULL},
{"ADC_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0xd0, NULL},
{"SOFT_LED", tVMEADR, NULL, 0, 0.0, NULL, 0x15c, NULL},
{"COPYCOUNT", tVMEADR, NULL, 0, 0.0, NULL, 0x1d4, NULL},
{"COPYBUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x1d8, NULL},
{"COPYCLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x1dc, NULL},
{"COPYREAD", tVMEADR, NULL, 0, 0.0, NULL, 0x1e0, NULL},
{"CLEARCOUNTER", tVMEADR, NULL, 0, 0.0, NULL, 0x5ac, NULL},
{"SPY_MEMORY", tVMEADR, NULL, 0, 0.0, NULL, 0x400, NULL},
{"SCOPE_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x4f8, NULL},
{"ADC_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x500, NULL},
{"SYNCH_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x504, NULL},
{"PF_COMMON", tVMEADR, NULL, 0, 0.0, NULL, 0x564, NULL},
{"PFBLOCK_A", tVMEADR, NULL, 0, 0.0, NULL, 0x568, NULL},
{"PFBLOCK_B", tVMEADR, NULL, 0, 0.0, NULL, 0x56c, NULL},
{"PFLUT", tVMEADR, NULL, 0, 0.0, NULL, 0x570, NULL},
{"FO_CLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x240, NULL},
{"FO_TESTCLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x244, NULL},
{"FO_DELAY_L1CLST", tVMEADR, NULL, 0, 0.0, NULL, 0x248, NULL},
{"FO_FILTER_L1", tVMEADR, NULL, 0, 0.0, NULL, 0x84, NULL},
{"BUSY_DELAY_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x84c8, NULL},
{"BUSY_ORBIT_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x80d4, NULL},
{"BUSY_DISB_CTP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x80d8, NULL},
{"BUSYMAX_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x8168, NULL},
{"BUSYMINI_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x816c, NULL},
{"MINIMAX_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x8570, NULL},
{"MINIMAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0x8174, NULL},
{"MINIMAX_LIMIT", tVMEADR, NULL, 0, 0.0, NULL, 0x8578, NULL},
{"BUSYLAST_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x857c, NULL},
{"BUSY_CLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x8600, NULL},
{"BUSY_DAQBUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x861c, NULL},
{"BUSY_L0L1DEADTIME", tVMEADR, NULL, 0, 0.0, NULL, 0x8620, NULL},
{"BUSY_CTPDEADTIME", tVMEADR, NULL, 0, 0.0, NULL, 0x8624, NULL},
{"BUSY_OVERLAP", tVMEADR, NULL, 0, 0.0, NULL, 0x8640, NULL},
{"L0_CLEAR_RND", tVMEADR, NULL, 0, 0.0, NULL, 0x90c8, NULL},
{"L0_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0x91c0, NULL},
{"L0_TCSTART", tVMEADR, NULL, 0, 0.0, NULL, 0x91c4, NULL},
{"L0_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0x91c8, NULL},
{"RATE_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x91cc, NULL},
{"RATE_CLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x91d0, NULL},
{"MASK_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x91e4, NULL},
{"MASK_CLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x91e8, NULL},
{"L0_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0x9400, NULL},
{"L0_CONDITION", tVMEADR, NULL, 0, 0.0, NULL, 0x9400, NULL},
{"L0_VETO", tVMEADR, NULL, 0, 0.0, NULL, 0x9600, NULL},
{"DAQ_LED", tVMEADR, NULL, 0, 0.0, NULL, 0x9600, NULL},
{"L0_MASK", tVMEADR, NULL, 0, 0.0, NULL, 0x9700, NULL},
{"L0_INVERT", tVMEADR, NULL, 0, 0.0, NULL, 0x9500, NULL},
{"L0_INTERACT1", tVMEADR, NULL, 0, 0.0, NULL, 0x94cc, NULL},
{"L0_INTERACT2", tVMEADR, NULL, 0, 0.0, NULL, 0x94d0, NULL},
{"L0_INTERACTT", tVMEADR, NULL, 0, 0.0, NULL, 0x94d4, NULL},
{"L0_INTERACTSEL", tVMEADR, NULL, 0, 0.0, NULL, 0x94d8, NULL},
{"L0_FUNCTION1", tVMEADR, NULL, 0, 0.0, NULL, 0x94dc, NULL},
{"L0_FUNCTION2", tVMEADR, NULL, 0, 0.0, NULL, 0x94e0, NULL},
{"RANDOM_1", tVMEADR, NULL, 0, 0.0, NULL, 0x94e4, NULL},
{"RANDOM_2", tVMEADR, NULL, 0, 0.0, NULL, 0x94e8, NULL},
{"SCALED_1", tVMEADR, NULL, 0, 0.0, NULL, 0x94ec, NULL},
{"SCALED_2", tVMEADR, NULL, 0, 0.0, NULL, 0x94f0, NULL},
{"ALL_RARE_FLAG", tVMEADR, NULL, 0, 0.0, NULL, 0x94f4, NULL},
{"L0_ENA_CRND", tVMEADR, NULL, 0, 0.0, NULL, 0x94fc, NULL},
{"MASK_MODE", tVMEADR, NULL, 0, 0.0, NULL, 0x95a4, NULL},
{"L0_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0x95a8, NULL},
{"RATE_MODE", tVMEADR, NULL, 0, 0.0, NULL, 0x9700, NULL},
{"L1_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xa1c0, NULL},
{"L1_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xa1c8, NULL},
{"L1_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xa400, NULL},
{"L1_DEFINITION", tVMEADR, NULL, 0, 0.0, NULL, 0xa400, NULL},
{"L1_DELAY_L0", tVMEADR, NULL, 0, 0.0, NULL, 0xa4cc, NULL},
{"L1_INVERT", tVMEADR, NULL, 0, 0.0, NULL, 0xa500, NULL},
{"ROIP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0xa600, NULL},
{"L2_DEFINITION", tVMEADR, NULL, 0, 0.0, NULL, 0xb400, NULL},
{"L2_ORBIT_READ", tVMEADR, NULL, 0, 0.0, NULL, 0xb140, NULL},
{"L2_ORBIT_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xb144, NULL},
{"L2_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xb1c0, NULL},
{"L2_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xb1c8, NULL},
{"L2_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xb400, NULL},
{"L2_DELAY_L1", tVMEADR, NULL, 0, 0.0, NULL, 0xb4cc, NULL},
{"L2_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0xb5a8, NULL},
{"INT_ORBIT_READ", tVMEADR, NULL, 0, 0.0, NULL, 0xc140, NULL},
{"INT_MAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xc144, NULL},
{"INT_FIFO_MAX", tVMEADR, NULL, 0, 0.0, NULL, 0xc148, NULL},
{"INT_DDL_EMU", tVMEADR, NULL, 0, 0.0, NULL, 0xc14c, NULL},
{"INT_DISB_CTP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0xc150, NULL},
{"I2C_MUXWR", tVMEADR, NULL, 0, 0.0, NULL, 0xc154, NULL},
{"I2C_MUXRD", tVMEADR, NULL, 0, 0.0, NULL, 0xc158, NULL},
{"I2C_ADCWR", tVMEADR, NULL, 0, 0.0, NULL, 0xc174, NULL},
{"I2C_ADCRD", tVMEADR, NULL, 0, 0.0, NULL, 0xc160, NULL},
{"I2C_SET", tVMEADR, NULL, 0, 0.0, NULL, 0xc164, NULL},
{"I2C_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0xc168, NULL},
{"INT_RC_BLCKMAX", tVMEADR, NULL, 0, 0.0, NULL, 0xc16c, NULL},
{"INT_BLCKMAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xc170, NULL},
{"INT_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xc400, NULL},
{"INT_TEST_COUNT", tVMEADR, NULL, 0, 0.0, NULL, 0xc404, NULL},
{"INT_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0xc5a8, NULL},
{"readHWL1class", tFUN+0x200, (w32 (*)())readHWL1class, 0xdead, 0.0, NULL, 0, readHWL1class_usagehelp},
{"printHWL1class", tFUN+0x400, (w32 (*)())printHWL1class, 0xdead, 0.0, NULL, 0, printHWL1class_usagehelp},
{"getswSSM", tFUN+0x100, (w32 (*)())getswSSM, 0xdead, 0.0, getswSSM_parameters, 1, getswSSM_usagehelp},
{"setsmssw", tFUN+0x400, (w32 (*)())setsmssw, 0xdead, 0.0, setsmssw_parameters, 2, setsmssw_usagehelp},
{"setomSSM", tFUN+0x200, (w32 (*)())setomSSM, 0xdead, 0.0, setomSSM_parameters, 2, setomSSM_usagehelp},
{"startSSM1", tFUN+0x200, (w32 (*)())startSSM1, 0xdead, 0.0, startSSM1_parameters, 1, NULL},
{"stopSSM", tFUN+0x200, (w32 (*)())stopSSM, 0xdead, 0.0, stopSSM_parameters, 1, stopSSM_usagehelp},
{"condstopSSM", tFUN+0x200, (w32 (*)())condstopSSM, 0xdead, 0.0, condstopSSM_parameters, 4, condstopSSM_usagehelp},
{"readSSM", tFUN+0x200, (w32 (*)())readSSM, 0xdead, 0.0, readSSM_parameters, 1, readSSM_usagehelp},
{"writeSSM", tFUN+0x200, (w32 (*)())writeSSM, 0xdead, 0.0, writeSSM_parameters, 1, writeSSM_usagehelp},
{"dumpSSM", tFUN+0x200, (w32 (*)())dumpSSM, 0xdead, 0.0, dumpSSM_parameters, 2, dumpSSM_usagehelp},
{"printSSM", tFUN+0x400, (w32 (*)())printSSM, 0xdead, 0.0, printSSM_parameters, 2, printSSM_usagehelp},
{"readSSMDump", tFUN+0x200, (w32 (*)())readSSMDump, 0xdead, 0.0, readSSMDump_parameters, 2, readSSMDump_usagehelp},
{"readL0count", tFUN+0x200, (w32 (*)())readL0count, 0xdead, 0.0, readL0count_parameters, 2, readL0count_usagehelp},
{"printL0count", tFUN+0x400, (w32 (*)())printL0count, 0xdead, 0.0, printL0count_parameters, 1, printL0count_usagehelp},
{"readHWrate", tFUN+0x400, (w32 (*)())readHWrate, 0xdead, 0.0, readHWrate_parameters, 1, readHWrate_usagehelp},
{"printHWrate", tFUN+0x400, (w32 (*)())printHWrate, 0xdead, 0.0, printHWrate_parameters, 1, printHWrate_usagehelp},
{"setRate", tFUN+0x400, (w32 (*)())setRate, 0xdead, 0.0, setRate_parameters, 2, setRate_usagehelp},
{"writeHWrate", tFUN+0x400, (w32 (*)())writeHWrate, 0xdead, 0.0, writeHWrate_parameters, 1, writeHWrate_usagehelp},
{"readHWL0class", tFUN+0x200, (w32 (*)())readHWL0class, 0xdead, 0.0, readHWL0class_parameters, 1, readHWL0class_usagehelp},
{"printHWL0class", tFUN+0x400, (w32 (*)())printHWL0class, 0xdead, 0.0, printHWL0class_parameters, 1, printHWL0class_usagehelp},
{"testRate", tFUN+0x200, (w32 (*)())testRate, 0xdead, 0.0, testRate_parameters, 4, testRate_usagehelp},
{"L0classoutmonT", tFUN+0x200, (w32 (*)())L0classoutmonT, 0xdead, 0.0, L0classoutmonT_parameters, 4, L0classoutmonT_usagehelp},
{"gettableSSM", tFUN+0x400, (w32 (*)())gettableSSM, 0xdead, 0.0, NULL, 0, gettableSSM_usagehelp},
{"getsfSSM", tFUN+0x400, (w32 (*)())getsfSSM, 0xdead, 0.0, getsfSSM_parameters, 1, getsfSSM_usagehelp},
{"getsyncedSSM", tFUN+0x400, (w32 (*)())getsyncedSSM, 0xdead, 0.0, NULL, 0, getsyncedSSM_usagehelp},
{"getsigSSM", tFUN+0x400, (w32 (*)())getsigSSM, 0xdead, 0.0, getsigSSM_parameters, 4, getsigSSM_usagehelp},
{"finddifSSM", tFUN+0x400, (w32 (*)())finddifSSM, 0xdead, 0.0, finddifSSM_parameters, 3, finddifSSM_usagehelp},
{"getoffsetSSM", tFUN+0x400, (w32 (*)())getoffsetSSM, 0xdead, 0.0, getoffsetSSM_parameters, 1, getoffsetSSM_usagehelp},
{"setoffsetSSM", tFUN+0x400, (w32 (*)())setoffsetSSM, 0xdead, 0.0, setoffsetSSM_parameters, 2, setoffsetSSM_usagehelp},
{"setmodeSSM", tFUN+0x400, (w32 (*)())setmodeSSM, 0xdead, 0.0, setmodeSSM_parameters, 3, setmodeSSM_usagehelp},
{"printsms", tFUN+0x400, (w32 (*)())printsms, 0xdead, 0.0, NULL, 0, printsms_usagehelp},
{"getPFHW", tFUN+0x200, (w32 (*)())getPFHW, 0xdead, 0.0, getPFHW_parameters, 2, getPFHW_usagehelp},
{"printPFHW", tFUN+0x400, (w32 (*)())printPFHW, 0xdead, 0.0, NULL, 0, printPFHW_usagehelp},
{"printPFHWs", tFUN+0x200, (w32 (*)())printPFHWs, 0xdead, 0.0, printPFHWs_parameters, 1, printPFHWs_usagehelp},
{"setPFHW", tFUN+0x200, (w32 (*)())setPFHW, 0xdead, 0.0, setPFHW_parameters, 2, setPFHW_usagehelp},
{"dumpCTP", tFUN+0x400, (w32 (*)())dumpCTP, 0xdead, 0.0, NULL, 0, NULL},
{"getPF", tFUN+0x400, (w32 (*)())getPF, 0xdead, 0.0, getPF_parameters, 1, getPF_usagehelp},
{"getPFc", tFUN+0x400, (w32 (*)())getPFc, 0xdead, 0.0, getPFc_parameters, 2, getPFc_usagehelp},
{"setPF", tFUN+0x400, (w32 (*)())setPF, 0xdead, 0.0, setPF_parameters, 2, setPF_usagehelp},
{"setPFc", tFUN+0x400, (w32 (*)())setPFc, 0xdead, 0.0, setPFc_parameters, 5, setPFc_usagehelp},
{"printPFwc", tFUN+0x400, (w32 (*)())printPFwc, 0xdead, 0.0, printPFwc_parameters, 1, printPFwc_usagehelp},
{"notInCrate", tFUN+0x200, (w32 (*)())notInCrate, 0xdead, 0.0, notInCrate_parameters, 1, NULL},
{"findBUSYINP", tFUN+0x200, (w32 (*)())findBUSYINP, 0xdead, 0.0, findBUSYINP_parameters, 2, NULL},
{"getCounter", tFUN+0x100, (w32 (*)())getCounter, 0xdead, 0.0, getCounter_parameters, 2, NULL},
{"getCounters", tFUN+0x400, (w32 (*)())getCounters, 0xdead, 0.0, getCounters_parameters, 2, NULL},
{"clearCounters", tFUN+0x400, (w32 (*)())clearCounters, 0xdead, 0.0, NULL, 0, NULL},
{"findDeadBusysRuns", tFUN+0x100, (w32 (*)())findDeadBusysRuns, 0xdead, 0.0, findDeadBusysRuns_parameters, 1, findDeadBusysRuns_usagehelp},
{"printLastDetectors", tFUN+0x400, (w32 (*)())printLastDetectors, 0xdead, 0.0, printLastDetectors_parameters, 1, printLastDetectors_usagehelp},
{"busyprobe", tFUN+0x400, (w32 (*)())busyprobe, 0xdead, 0.0, busyprobe_parameters, 1, busyprobe_usagehelp},
{"findDeadBusys", tFUN+0x100, (w32 (*)())findDeadBusys, 0xdead, 0.0, NULL, 0, findDeadBusys_usagehelp},
{"GenSwtrg", tFUN+0x200, (w32 (*)())GenSwtrg, 0xdead, 0.0, GenSwtrg_parameters, 5, NULL},
{"checkScopeBoard", tFUN+0x200, (w32 (*)())checkScopeBoard, 0xdead, 0.0, checkScopeBoard_parameters, 1, NULL},
{"setScopeBoard", tFUN+0x200, (w32 (*)())setScopeBoard, 0xdead, 0.0, setScopeBoard_parameters, 2, NULL},
{"getScopeSignal", tFUN+0x200, (w32 (*)())getScopeSignal, 0xdead, 0.0, getScopeSignal_parameters, 2, NULL},
{"setScopeSignal", tFUN+0x200, (w32 (*)())setScopeSignal, 0xdead, 0.0, setScopeSignal_parameters, 3, NULL},
{"getVMERWScope", tFUN+0x200, (w32 (*)())getVMERWScope, 0xdead, 0.0, NULL, 0, NULL},
{"setVMERWScope", tFUN+0x400, (w32 (*)())setVMERWScope, 0xdead, 0.0, setVMERWScope_parameters, 2, NULL},
{"getSWLEDS", tFUN+0x400, (w32 (*)())getSWLEDS, 0xdead, 0.0, getSWLEDS_parameters, 1, getSWLEDS_usagehelp},
{"setEdge", tFUN+0x400, (w32 (*)())setEdge, 0xdead, 0.0, setEdge_parameters, 3, setEdge_usagehelp},
{"README", tFUN+0x400, (w32 (*)())README, 0xdead, 0.0, NULL, 0, README_usagehelp},
{"FOLTUConnection", tFUN+0x200, (w32 (*)())FOLTUConnection, 0xdead, 0.0, FOLTUConnection_parameters, 1, FOLTUConnection_usagehelp},
{"FOL0L1mode", tFUN+0x200, (w32 (*)())FOL0L1mode, 0xdead, 0.0, NULL, 0, FOL0L1mode_usagehelp},
{"FOL2mode", tFUN+0x200, (w32 (*)())FOL2mode, 0xdead, 0.0, NULL, 0, FOL2mode_usagehelp},
{"L0FOconnection", tFUN+0x200, (w32 (*)())L0FOconnection, 0xdead, 0.0, NULL, 0, L0FOconnection_usagehelp},
{"L0FOconnection2", tFUN+0x200, (w32 (*)())L0FOconnection2, 0xdead, 0.0, NULL, 0, L0FOconnection2_usagehelp},
{"L0L1connection", tFUN+0x200, (w32 (*)())L0L1connection, 0xdead, 0.0, NULL, 0, L0L1connection_usagehelp},
{"L0L2connection", tFUN+0x200, (w32 (*)())L0L2connection, 0xdead, 0.0, NULL, 0, L0L2connection_usagehelp},
{"L0INTconnection", tFUN+0x200, (w32 (*)())L0INTconnection, 0xdead, 0.0, NULL, 0, L0INTconnection_usagehelp},
{"L0ingener", tFUN+0x200, (w32 (*)())L0ingener, 0xdead, 0.0, NULL, 0, L0ingener_usagehelp},
{"L0outmon", tFUN+0x200, (w32 (*)())L0outmon, 0xdead, 0.0, NULL, 0, L0outmon_usagehelp},
{"L0inmon", tFUN+0x200, (w32 (*)())L0inmon, 0xdead, 0.0, NULL, 0, L0inmon_usagehelp},
{"L0testPF", tFUN+0x200, (w32 (*)())L0testPF, 0xdead, 0.0, L0testPF_parameters, 10, L0testPF_usagehelp},
{"L0testPF2", tFUN+0x200, (w32 (*)())L0testPF2, 0xdead, 0.0, L0testPF2_parameters, 1, L0testPF2_usagehelp},
{"L0rndPF", tFUN+0x200, (w32 (*)())L0rndPF, 0xdead, 0.0, L0rndPF_parameters, 1, L0rndPF_usagehelp},
{"L0rndallPF", tFUN+0x200, (w32 (*)())L0rndallPF, 0xdead, 0.0, NULL, 0, L0rndallPF_usagehelp},
{"L0classlogic", tFUN+0x200, (w32 (*)())L0classlogic, 0xdead, 0.0, NULL, 0, L0classlogic_usagehelp},
{"L1testPF2", tFUN+0x200, (w32 (*)())L1testPF2, 0xdead, 0.0, L1testPF2_parameters, 1, L1testPF2_usagehelp},
{"L1classlogic2", tFUN+0x200, (w32 (*)())L1classlogic2, 0xdead, 0.0, NULL, 0, L1classlogic2_usagehelp},
{"L1ingener", tFUN+0x200, (w32 (*)())L1ingener, 0xdead, 0.0, NULL, 0, L1ingener_usagehelp},
{"L1outmon", tFUN+0x200, (w32 (*)())L1outmon, 0xdead, 0.0, NULL, 0, L1outmon_usagehelp},
{"L1inmon", tFUN+0x200, (w32 (*)())L1inmon, 0xdead, 0.0, NULL, 0, L1inmon_usagehelp},
{"L1ingen", tFUN+0x200, (w32 (*)())L1ingen, 0xdead, 0.0, NULL, 0, L1ingen_usagehelp},
{"L1L2Connect", tFUN+0x200, (w32 (*)())L1L2Connect, 0xdead, 0.0, NULL, 0, L1L2Connect_usagehelp},
{"L1FOconnection", tFUN+0x200, (w32 (*)())L1FOconnection, 0xdead, 0.0, NULL, 0, L1FOconnection_usagehelp},
{"L1INTconnection", tFUN+0x200, (w32 (*)())L1INTconnection, 0xdead, 0.0, NULL, 0, L1INTconnection_usagehelp},
{"L2classlogic", tFUN+0x200, (w32 (*)())L2classlogic, 0xdead, 0.0, NULL, 0, L2classlogic_usagehelp},
{"L1testPF3", tFUN+0x200, (w32 (*)())L1testPF3, 0xdead, 0.0, L1testPF3_parameters, 1, L1testPF3_usagehelp},
{"L1testPF4", tFUN+0x200, (w32 (*)())L1testPF4, 0xdead, 0.0, L1testPF4_parameters, 1, L1testPF4_usagehelp},
{"L1rndallPF", tFUN+0x200, (w32 (*)())L1rndallPF, 0xdead, 0.0, NULL, 0, L1rndallPF_usagehelp},
{"L1classlogic", tFUN+0x200, (w32 (*)())L1classlogic, 0xdead, 0.0, NULL, 0, L1classlogic_usagehelp},
{"L2FOconnection", tFUN+0x200, (w32 (*)())L2FOconnection, 0xdead, 0.0, NULL, 0, L2FOconnection_usagehelp},
{"L2INTconnection", tFUN+0x200, (w32 (*)())L2INTconnection, 0xdead, 0.0, NULL, 0, L2INTconnection_usagehelp},
{"L2INT", tFUN+0x200, (w32 (*)())L2INT, 0xdead, 0.0, NULL, 0, L2INT_usagehelp},
{"L2rndallPF", tFUN+0x200, (w32 (*)())L2rndallPF, 0xdead, 0.0, NULL, 0, L2rndallPF_usagehelp},
{"L2classlogic2", tFUN+0x200, (w32 (*)())L2classlogic2, 0xdead, 0.0, NULL, 0, L2classlogic2_usagehelp},
{"L2testPF3", tFUN+0x200, (w32 (*)())L2testPF3, 0xdead, 0.0, L2testPF3_parameters, 1, L2testPF3_usagehelp},
{"L0outL1inL2in", tFUN+0x200, (w32 (*)())L0outL1inL2in, 0xdead, 0.0, NULL, 0, L0outL1inL2in_usagehelp},
{"L0outL1outL2out", tFUN+0x200, (w32 (*)())L0outL1outL2out, 0xdead, 0.0, NULL, 0, L0outL1outL2out_usagehelp},
{"L1outFOs", tFUN+0x200, (w32 (*)())L1outFOs, 0xdead, 0.0, NULL, 0, L1outFOs_usagehelp},
{"L0outL1outL2outBusy", tFUN+0x200, (w32 (*)())L0outL1outL2outBusy, 0xdead, 0.0, NULL, 0, L0outL1outL2outBusy_usagehelp},
{"L0inBUout", tFUN+0x200, (w32 (*)())L0inBUout, 0xdead, 0.0, NULL, 0, L0inBUout_usagehelp},
{"BCoffset", tFUN+0x200, (w32 (*)())BCoffset, 0xdead, 0.0, NULL, 0, BCoffset_usagehelp},
{"MonallPF", tFUN+0x200, (w32 (*)())MonallPF, 0xdead, 0.0, NULL, 0, MonallPF_usagehelp},
{"FOL1mon", tFUN+0x200, (w32 (*)())FOL1mon, 0xdead, 0.0, NULL, 0, FOL1mon_usagehelp},
{"FOLTU", tFUN+0x200, (w32 (*)())FOLTU, 0xdead, 0.0, NULL, 0, FOLTU_usagehelp},
{"L2a2INT", tFUN+0x200, (w32 (*)())L2a2INT, 0xdead, 0.0, NULL, 0, L2a2INT_usagehelp},
{"dumpINTSSM", tFUN+0x200, (w32 (*)())dumpINTSSM, 0xdead, 0.0, NULL, 0, dumpINTSSM_usagehelp},
{"BUconnect", tFUN+0x200, (w32 (*)())BUconnect, 0xdead, 0.0, NULL, 0, BUconnect_usagehelp},
{"INTL0connection", tFUN+0x200, (w32 (*)())INTL0connection, 0xdead, 0.0, NULL, 0, INTL0connection_usagehelp},
{"Comp2Channels", tFUN+0x200, (w32 (*)())Comp2Channels, 0xdead, 0.0, Comp2Channels_parameters, 3, Comp2Channels_usagehelp},
{"CompallPF", tFUN+0x200, (w32 (*)())CompallPF, 0xdead, 0.0, NULL, 0, CompallPF_usagehelp},
{"scanOrbit", tFUN+0x400, (w32 (*)())scanOrbit, 0xdead, 0.0, scanOrbit_parameters, 1, NULL},
{"DebugSync", tFUN+0x200, (w32 (*)())DebugSync, 0xdead, 0.0, NULL, 0, DebugSync_usagehelp},
{"checkToggle", tFUN+0x200, (w32 (*)())checkToggle, 0xdead, 0.0, checkToggle_parameters, 2, checkToggle_usagehelp},
{"genSeq", tFUN+0x200, (w32 (*)())genSeq, 0xdead, 0.0, genSeq_parameters, 3, genSeq_usagehelp},
{"writeSPn", tFUN+0x200, (w32 (*)())writeSPn, 0xdead, 0.0, writeSPn_parameters, 4, writeSPn_usagehelp},
{"writeSPb", tFUN+0x200, (w32 (*)())writeSPb, 0xdead, 0.0, writeSPb_parameters, 4, writeSPb_usagehelp},
{"writeSPb2", tFUN+0x200, (w32 (*)())writeSPb2, 0xdead, 0.0, writeSPb2_parameters, 5, writeSPb2_usagehelp},
{"writeSPP", tFUN+0x200, (w32 (*)())writeSPP, 0xdead, 0.0, writeSPP_parameters, 4, writeSPP_usagehelp},
{"writeSPF", tFUN+0x200, (w32 (*)())writeSPF, 0xdead, 0.0, writeSPF_parameters, 4, writeSPF_usagehelp},
{"form2i", tFUN+0x200, (w32 (*)())form2i, 0xdead, 0.0, form2i_parameters, 3, form2i_usagehelp},
{"bcstat", tFUN+0x400, (w32 (*)())bcstat, 0xdead, 0.0, bcstat_parameters, 2, bcstat_usagehelp},
{"bcstat2", tFUN+0x400, (w32 (*)())bcstat2, 0xdead, 0.0, bcstat2_parameters, 1, bcstat2_usagehelp},
{"CTP_Classes", tFUN, NULL, 0xdead, 0.0, NULL, 0, CTP_Classes_usagehelp},
{"CTP_Clusters", tFUN, NULL, 0xdead, 0.0, NULL, 0, CTP_Clusters_usagehelp},
{"Resources", tFUN, NULL, 0xdead, 0.0, NULL, 0, Resources_usagehelp},
{"Counters", tFUN, NULL, 0xdead, 0.0, NULL, 0, Counters_usagehelp},
{"CheckTestClass", tFUN, NULL, 0xdead, 0.0, NULL, 0, CheckTestClass_usagehelp},
{"ScopeAB", tFUN, NULL, 0xdead, 0.0, NULL, 0, ScopeAB_usagehelp},
{"SSMbrowser", tFUN, NULL, 0xdead, 0.0, NULL, 0, SSMbrowser_usagehelp},
{"SSMcontrol", tFUN, NULL, 0xdead, 0.0, NULL, 0, SSMcontrol_usagehelp},
{"SaveFile", tFUN, NULL, 0xdead, 0.0, NULL, 0, SaveFile_usagehelp},
{"LoadFile", tFUN, NULL, 0xdead, 0.0, NULL, 0, LoadFile_usagehelp},
{"Readhw", tFUN, NULL, 0xdead, 0.0, NULL, 0, Readhw_usagehelp},
{"Write2hw", tFUN, NULL, 0xdead, 0.0, NULL, 0, Write2hw_usagehelp},
{"DAQonoff", tFUN+0x400, (w32 (*)())DAQonoff, 0xdead, 0.0, DAQonoff_parameters, 1, DAQonoff_usagehelp},
{"readORBIT_READs", tFUN+0x400, (w32 (*)())readORBIT_READs, 0xdead, 0.0, NULL, 0, readORBIT_READs_usagehelp},
{"i2creadall", tFUN+0x400, (w32 (*)())i2creadall, 0xdead, 0.0, NULL, 0, i2creadall_usagehelp},
{"setClusters", tFUN+0x400, (w32 (*)())setClusters, 0xdead, 0.0, setClusters_parameters, 8, setClusters_usagehelp},
{"getClusters", tFUN+0x400, (w32 (*)())getClusters, 0xdead, 0.0, NULL, 0, getClusters_usagehelp},
{"getDAQbusy", tFUN+0x400, (w32 (*)())getDAQbusy, 0xdead, 0.0, NULL, 0, getDAQbusy_usagehelp},
{"getFO", tFUN+0x400, (w32 (*)())getFO, 0xdead, 0.0, getFO_parameters, 1, getFO_usagehelp},
{"setFO", tFUN+0x400, (w32 (*)())setFO, 0xdead, 0.0, setFO_parameters, 3, setFO_usagehelp},
{"setFOrocs", tFUN+0x400, (w32 (*)())setFOrocs, 0xdead, 0.0, setFOrocs_parameters, 2, setFOrocs_usagehelp},
{"swtrigger", tFUN+0x100, (w32 (*)())swtrigger, 0xdead, 0.0, swtrigger_parameters, 1, swtrigger_usagehelp},
{"getTCSTATUS", tFUN+0x100, (w32 (*)())getTCSTATUS, 0xdead, 0.0, NULL, 0, getTCSTATUS_usagehelp},
{"getTCSET", tFUN+0x100, (w32 (*)())getTCSET, 0xdead, 0.0, NULL, 0, getTCSET_usagehelp},
{"setTCSET", tFUN+0x400, (w32 (*)())setTCSET, 0xdead, 0.0, setTCSET_parameters, 2, setTCSET_usagehelp},
{"clearTC", tFUN+0x400, (w32 (*)())clearTC, 0xdead, 0.0, NULL, 0, clearTC_usagehelp},
{"getClass", tFUN+0x400, (w32 (*)())getClass, 0xdead, 0.0, getClass_parameters, 1, getClass_usagehelp},
{"setClass", tFUN+0x400, (w32 (*)())setClass, 0xdead, 0.0, setClass_parameters, 8, setClass_usagehelp},
{"disableClasses", tFUN+0x400, (w32 (*)())disableClasses, 0xdead, 0.0, NULL, 0, disableClasses_usagehelp},
{"hw2rates", tFUN+0x400, (w32 (*)())hw2rates, 0xdead, 0.0, NULL, 0, hw2rates_usagehelp},
{"rates2hw", tFUN+0x400, (w32 (*)())rates2hw, 0xdead, 0.0, NULL, 0, rates2hw_usagehelp},
{"getShared", tFUN+0x400, (w32 (*)())getShared, 0xdead, 0.0, NULL, 0, getShared_usagehelp},
{"setShared", tFUN+0x400, (w32 (*)())setShared, 0xdead, 0.0, setShared_parameters, 9, setShared_usagehelp},
{"setShared2", tFUN+0x400, (w32 (*)())setShared2, 0xdead, 0.0, setShared2_parameters, 2, setShared2_usagehelp},
{"clearSPY", tFUN+0x400, (w32 (*)())clearSPY, 0xdead, 0.0, clearSPY_parameters, 1, clearSPY_usagehelp},
{"getBCmasks", tFUN+0x400, (w32 (*)())getBCmasks, 0xdead, 0.0, NULL, 0, getBCmasks_usagehelp},
{"setBCmasks", tFUN+0x400, (w32 (*)())setBCmasks, 0xdead, 0.0, NULL, 0, setBCmasks_usagehelp},
{"checkBCmasks", tFUN+0x400, (w32 (*)())checkBCmasks, 0xdead, 0.0, checkBCmasks_parameters, 2, checkBCmasks_usagehelp},
{"testSYNCH", tFUN+0x400, (w32 (*)())testSYNCH, 0xdead, 0.0, NULL, 0, testSYNCH_usagehelp},
{"testBCDELAY", tFUN+0x400, (w32 (*)())testBCDELAY, 0xdead, 0.0, testBCDELAY_parameters, 1, testBCDELAY_usagehelp},
{"orbitscan", tFUN+0x400, (w32 (*)())orbitscan, 0xdead, 0.0, orbitscan_parameters, 1, orbitscan_usagehelp},
{"setOrbitBChalf", tFUN+0x400, (w32 (*)())setOrbitBChalf, 0xdead, 0.0, setOrbitBChalf_parameters, 1, setOrbitBChalf_usagehelp},
{"findNS", tFUN+0x400, (w32 (*)())findNS, 0xdead, 0.0, NULL, 0, NULL},
{"fdf", tFUN+0x400, (w32 (*)())fdf, 0xdead, 0.0, NULL, 0, NULL},
{"dumpCounters", tFUN+0x400, (w32 (*)())dumpCounters, 0xdead, 0.0, NULL, 0, dumpCounters_usagehelp},
{"ReadTemperatures", tFUN+0x400, (w32 (*)())ReadTemperatures, 0xdead, 0.0, NULL, 0, NULL},
{"TestLEDS", tFUN+0x400, (w32 (*)())TestLEDS, 0xdead, 0.0, NULL, 0, NULL},
{"micsleep", tFUN+0x400, (w32 (*)())micsleep, 0xdead, 0.0, micsleep_parameters, 1, micsleep_usagehelp},
{"RNDsync", tFUN+0x400, (w32 (*)())RNDsync, 0xdead, 0.0, RNDsync_parameters, 1, RNDsync_usagehelp},
{"initmain", tFUN+0x400, (w32 (*)())initmain, 0xdead, 0.0, NULL, 0, initmain_usagehelp},
{"vmeWR", tFUN+0x200, (w32 (*)())vmeWR, 0xdead, 0.0, vmeWR_parameters, 2, vmeWR_usagehelp},
{"testOrbit", tFUN+0x200, (w32 (*)())testOrbit, 0xdead, 0.0, testOrbit_parameters, 1, testOrbit_usagehelp},
{"checkSSM", tFUN+0x400, (w32 (*)())checkSSM, 0xdead, 0.0, checkSSM_parameters, 1, NULL},
{"readSSMs", tFUN+0x200, (w32 (*)())readSSMs, 0xdead, 0.0, NULL, 0, readSSMs_usagehelp},
{"checkSSMs", tFUN+0x400, (w32 (*)())checkSSMs, 0xdead, 0.0, NULL, 0, NULL},
{"testStart", tFUN+0x200, (w32 (*)())testStart, 0xdead, 0.0, testStart_parameters, 1, testStart_usagehelp},
{"testStop", tFUN+0x200, (w32 (*)())testStop, 0xdead, 0.0, testStop_parameters, 1, testStop_usagehelp},
{"correlate", tFUN+0x200, (w32 (*)())correlate, 0xdead, 0.0, correlate_parameters, 6, correlate_usagehelp},
{"trdssmtrigger", tFUN+0x200, (w32 (*)())trdssmtrigger, 0xdead, 0.0, trdssmtrigger_parameters, 2, trdssmtrigger_usagehelp},
{"L2a2Interface", tFUN+0x200, (w32 (*)())L2a2Interface, 0xdead, 0.0, L2a2Interface_parameters, 3, L2a2Interface_usagehelp},
{"dumpIntSsm", tFUN+0x200, (w32 (*)())dumpIntSsm, 0xdead, 0.0, dumpIntSsm_parameters, 1, dumpIntSsm_usagehelp},
{"dumpL2amesage", tFUN+0x200, (w32 (*)())dumpL2amesage, 0xdead, 0.0, dumpL2amesage_parameters, 1, dumpL2amesage_usagehelp},
{"BCoffset2", tFUN+0x400, (w32 (*)())BCoffset2, 0xdead, 0.0, BCoffset2_parameters, 2, NULL},
{"genSW", tFUN+0x400, (w32 (*)())genSW, 0xdead, 0.0, NULL, 0, genSW_usagehelp}};
