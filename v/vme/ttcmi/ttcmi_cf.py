self.baseAddr="0xf00000"
self.spaceLength="0x100000"
self.vmeregs=[('ch1_ref', '0x12', '0x04000000'), ('ch2_ref', '0x14', '0x04000000'), ('ch3_ref', '0x16', '0x04000000'), ('ch1_freq_low', '0x18', '0x04000000'), ('ch1_freq_high', '0x1a', '0x04000000'), ('ident_id', '0x8', '0x04000000'), ('card_id', '0x24', '0x04000000'), ('board_id', '0x3a', '0x04000000'), ('BSET', '0x10', ''), ('BCLEAR', '0x14', ''), ('PROGRAM_ID', '0xc', ''), ('WORKING_MODE', '0x7fa78', ''), ('BST_Machine_Mode', '0x7fa9c', ''), ('TTCrx_status', '0x7faa0', ''), ('BC1_QPLL_STATUS', '0x7fbe8', ''), ('BC2_QPLL_STATUS', '0x7fbb8', ''), ('BCref_QPLL_STATUS', '0x7fb98', ''), ('BCmain_QPLL_STATUS', '0x7fb7c', ''), ('BC1_QPLL_MODE', '0x7fbf0', ''), ('BC2_QPLL_MODE', '0x7fbc0', ''), ('BCref_QPLL_MODE', '0x7fba0', ''), ('BCmain_QPLL_MODE', '0x7fb80', ''), ('ORBX_COUNTER', '0x7facc', ''), ('ORBX_POLARITY', '0x7fae0', ''), ('ORBX_LENGTH', '0x7fad8', ''), ('ORBX_COARSE_DELAY', '0x7fadc', ''), ('BC1_MAN_SELECT', '0x7fbfc', ''), ('BC2_MAN_SELECT', '0x7fbcc', ''), ('BCref_MAN_SELECT', '0x7fbac', ''), ('BCmain_MAN_SELECT', '0x7fb8c', ''), ('ORBmain_MAN_SELECT', '0x7faec', ''), ('ORB1_MAN_SELECT', '0x7fb6c', ''), ('ORB2_MAN_SELECT', '0x7fb2c', ''), ('BC_DELAY25_BC1', '0x7D000', ''), ('BC_DELAY25_BC2', '0x7D004', ''), ('BC_DELAY25_BCREF', '0x7D008', ''), ('BC_DELAY25_BCMAIN', '0x7D00C', ''), ('BC_DELAY25_GCR', '0x7D014', ''), ('ORBIN_DELAY25_ORB1', '0x7D020', ''), ('ORBIN_DELAY25_ORB2', '0x7D024', ''), ('ORBIN_DELAY25_GCR', '0x7D034', ''), ('ORBOUT_DELAY25_ORB1', '0x7D040', ''), ('ORBOUT_DELAY25_ORB2', '0x7D044', ''), ('ORBOUT_DELAY25_ORBMAIN', '0x7D048', ''), ('ORBOUT_DELAY25_GCR', '0x7D054', ''), ('DELAY25_REG', '0x7D200', ''), ('PERIOD_COUNTER_RESET', '0x7FA48', ''), ('PERIOD_COUNTER_ENABLE', '0x7FA64', ''), ('ORB2_DAC', '0x7FAFC', ''), ('ORB1_DAC', '0x7FB3C', ''), ('ORB1_PERIOD_FIFO_RD', '0x7FB40', ''), ('ORB2_PERIOD_FIFO_RD', '0x7FB00', ''), ('ORBmain_PERIOD_FIFO_RD', '0x7FAC0', ''), ('ORB1_COARSE_DELAY', '0x7FB5C', ''), ('ORB2_COARSE_DELAY', '0x7FB1C', ''), ('ORBmain_COARSE_DELAY', '0x7FADC', '')]
self.hiddenfuncs=""
self.funcs=[['calib', 'fifoadr: addr. of ORB1_PERIOD_FIFO_RD\n', 'int', 'read1000', [['fifoadr', 'w32', ''], ['del', 'int', '']]], ['calib', 'orb:\n0: ORB1/BC1 -BPTX monitoring\n1: ORB2/BC2 -\n2: ORBmain=ORB1 BCmain= BC1   ALICE clock BEAM1\n4: ORBmain=ORB2 BCmain= BC2   ALICE clock BEAM2\n\nSet BC_DELAY25_BC1/2/MAIN to their final values before using this!\n16.3.2011:\nall 3 Set to 29,28,27 - ORB1/BC1 calibration is not working\n    for <=26 is OK\nSimilarly for ORB2/BC2: with BC_DELAY25_BC2>27 calibration is not working\n(i.e. all read1000() returns >0 )\nHere is the table with 0 in BC_DELAY25_BC1/2/main:\n   bad regions[ns]\n0:  9-9.5    (# of bad readings in region: <5)\n1: 21.5-22    detto\n2: 8.5-9.5   <90\n\ni2cset_delay -removed DLL resync, now ok:\nHere is the table with 29 in BC_DELAY25_BC1/2/main:\n   bad regions[ns]\n0:  24        (# of bad readings in region: <=1)\n1:  10        16   \n2:  24        1  (when BC1corde changed 8500->8650 then 100 bad readings)\n4:  10.5      1\n', 'void', 'calibrate', [['orb', 'int', ''], ['fromdel', 'int', ''], ['todel', 'int', '']]], ['delays', 'set delayadd with halfns value (in steps of 0.5 ns):\n#define BC_DELAY25_BC1             0x7D000\n#define BC_DELAY25_BC2             0x7D004\n#define BC_DELAY25_BCREF           0x7D008\n#define BC_DELAY25_BCMAIN          0x7D00C\n#define BC_DELAY25_GCR             0x7D014\n#define ORBIN_DELAY25_ORB1         0x7D020\n#define ORBIN_DELAY25_ORB2         0x7D024\n#define ORBIN_DELAY25_GCR          0x7D034\n#define ORBOUT_DELAY25_ORB1        0x7D040\n#define ORBOUT_DELAY25_ORB2        0x7D044\n#define ORBOUT_DELAY25_ORBMAIN     0x7D048\n#define ORBOUT_DELAY25_GCR         0x7D054\n', 'void', 'i2cset_delay', [['delayadd', 'w32', ''], ['halfns', 'int', '']]], ['delays', 'read BC_DEALY25_* registers\n', 'void', 'printBC_DELAYS', []], ['delays', '#define ORB1_COARSE_DELAY          0x7FB5C\n#define ORB2_COARSE_DELAY          0x7FB1C\n#define ORBmain_COARSE_DELAY       0x7FADC\n', 'void', 'setOrbitCoarse', [['addr', 'w32', ''], ['coarse', 'int', '']]], [None, 'Input: maino: \n1 -> BC1/Orbit1\n2 -> BC2/Orbit2\n3 -> BCref/int BCmain synch. orbit generator\n4 -> internal 40.078MHz/int BCmain synch. orbit generator\nOutput:\n- clock is changed + log messages written into DAQ infoLogger\nNote (todo?):\nBCREF/\nlocalBC/\n', 'void', 'setbcorbitMain', [['maino', 'int', '']]], ['Resets', 'chip:\n0: Delay25 chips\n1: no efect\n2: BC1-QPLL chip\n2: BC2-QPLL chip\n2: BCref-QPLL chip\n2: BCmain-QPLL chip\n6: TTCrx chips\n7: whole board\nOperation:\n1. read+print BSET word\nset BSET bit\n2. read+print BSET word\nset BCLEAR bit\n3. read+print BSET word\n', 'void', 'resetQPLL', [['chip', 'int', '']]], ['Resets', 'resync DEALY25 chip (write 0x40 -> BC_DELAY25_GCR)\n', 'void', 'resyncDLL', []], [None, 'Set orbit delay in BCs in 3 ORBX_COARSE_DELAY registers.\n0    - minimum shift\n3563 -maximum allowed shift\n4000 - show current setting\n', 'void', 'setorbitdelay', [['bcs', 'int', '']]], [None, 'Read and print ORBX_COUNTER (X: main 2 1) registers ', 'void', 'readorbitcnts', []], [None, '- reset CORDE board\n- set RF boards (0x5 for BC and 0x70 for Orbit)\n- set polarity/length for all 3 RF2TTC outputs: MAIN/ORB2/ORB1\n- set BC1/2 and Orbit1/2 delays\n', 'void', 'writeall', []], [None, 'PROGRAM_ID:8102008\nch1_ref:0x5\nch2_ref:0x5\nch3_ref:0x70\nrc:0 vsp:1\nch1_ref:0x5\nch2_ref:0x5\nch3_ref:0x70\npolarity0: 0x7fae0:0x1   0x7fad8 0x26 delay:0\npolarity1: 0x7fb20:0x1   0x7fb18 0x26 delay:0\npolarity2: 0x7fb60:0x1   0x7fb58 0x26 delay:0\nWORKING_MODE (bits 0..6 (0:man,1:auto)for: BC1/2/r/main Orb1/2/m:0 \nBST_Machine_Mode:7\nBC 1/2/ref selection (Int/Ext):EEE\nBC/ORB main_MAN_SELECT: 0 2\nBCmain_MAN_SELECT:\n0:40.078MHz int clock, 1: BCref, 2: BC2in, 3: BC1in\nORBmain_MAN_SELECT:\n0:Orbit1, 1:Orbit2, 2:int BCmain sync. orbit generator\n', 'void', 'readall', []], [None, 'used for measurement at the end of 2008.\n', 'void', 'monitorstatus', []], [None, 'read QPLL* and TTCrx status bits.\nRC: 0xTAB\nT: bit 8. 1: TTCrx ok\nA: [7..6] BC1 error,locked (i.e. 01 correct)\n   [5..4] BC2\nB: [3..2] BCref\n   [1..0] BCmain\nI.e. 0x155 is correct status of all 9 bits\n     0x1aa error in both BC, was not locked. NEXT READING is 0x155 !\n', 'w32', 'readstatus', []], ['L012', '', 'w32', 'getCounter', [['board', 'int', ''], ['reladr', 'int', ''], ['customer', 'int', '']]], ['L012', '', 'void', 'getCounters', [['N', 'int', ''], ['accrual', 'int', ''], ['customer', 'int', '']]], ['L012', '', 'void', 'clearCounters', [['customer', 'int', '']]], ['SimpleTests', 'rc: 0: if L0 borad firmware >0xAB\n    boardversion if firmware <=0xAB \n', 'int', 'l0AB', []], ['INT', "daqon:0       ->daq active\ndaqon:0xb     ->daq off (i.e. produce triggers in spite of DDL red diode \n                on INT board is on \ndaqon: other  -> show current status.\nNOTE about LEDs on INT board:\nDDL interface: \n  green:DDL line ready, data not read out \n  flashing green: DDL line ready, data are read out\n  flashing orange: data are read out, backpressure is sometimes active\n                   (DAQ is not able to read everything)\nupper DDL LED on INT board fron panel:\n  red: INT is raising CTPBUSY on backlplane, because of full DDL buffers\nINT_DDL_EMU word in normal mode (i.e. DAQ active):\n     DDLfiLF  DDLfiBEN  DDLfiDIR\n0x20:      0         1         0  data can't be sent (DDL not enabled from DIU)\n0x30:      0         1         1  data sent\n0x70:      1         1         1  data not sent (backpressure)\n", 'void', 'DAQonoff', [['daqon', 'int', '']]]]
