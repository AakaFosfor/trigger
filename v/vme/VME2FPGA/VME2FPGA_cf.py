self.baseAddr="0x0"
self.spaceLength="0x1000"
self.vmeregs=[('CODE_ADD', '0x4', ''), ('SERIAL_NUMBER', '0x8', ''), ('VERSION_ADD', '0xC', ''), ('SOFT_RESET', '0x28', ''), ('TEMP_START', '0x58', ''), ('TEMP_STATUS', '0x5c', ''), ('TEMP_READ', '0x60', '')]
self.hiddenfuncs=""
self.funcs=[['Monitor', " Graphical interface to MonitorLoad. Measure FPGA signals 'Ntimes' waiting\n before measurement 'Tscale' times in arbitrary units, so Tscale should be \n set up by set and try. Time interval between measurements is estimated\n as (Time after measurement - time at start)/Ntimes. \n", 'GUI', 'MonitLoad', [], 'MonitLoad'], ['FPGA', '\nGet Status of FPGA. \n\n', 'void', 'GetStatusFPGA', []], ['Monitor', '\n  C code to MonitLoad. Can be called also indepedently.\n  It loads FPGA and monitor signals without outputing them,\n  which leads to maximum time information.\n ', 'void', 'MonitorLoad', [['Ntimes', 'int', ''], ['Tscale', 'int', '']]], ['FPGA', '\nLoads FPGA from Flash memory\n\n', 'void', 'LoadFPGA', []], ['Monitor', '\n Monitors FPGA by reading status word.\n Ntimes: number of times you want to read status word.\n Tinterval: time interval between reading status word in microseconds. \n\n', 'void', 'MonitorStatusFPGA', [['Ntimes', 'int', ''], ['Tinterval', 'int', '']]], ['Monitor', '\n Loops infinitelly reading status and detect change\n ', 'void', 'MonitorChange', []], ['FlMem', '\nGet Status of Flash memory.\n', 'void', 'GetStatusFM', []], ['FlMem', '\nResets Flash Memory.\n', 'void', 'ResetFM', []], ['FlMem', '\nLoads Flash Memory from the file on disk.\n', 'void', 'LoadFM', []], ['FlMem', '\nReads the input configuration file from disk\nand saves it to array.\n', 'int', 'ReadInputFile', []], ['FlMem', '\nReads Content of Flash Memory and compares it\nwith the file on disk.\n', 'void', 'CheckContent', []], ['FlMem', '\nErases Flash Memory.\n', 'void', 'EraseFM', []], ['FlMem', 'Check against 1\n', 'int', 'Check1', []], ['FlMem', '', 'int', 'ReadFlashMem', []], ['FlMemChecks', 'write to FM at address address.\n', 'int', 'WriteFM', [['address', 'w32', ''], ['word', 'w32', '']]], ['FlMemChecks', 'INCR=1 - read from address drom actual address\nINCR=0 - read address\n', 'int', 'ReadFM', [['address', 'w32', ''], ['INCR', 'int', '']]], ['FlMemChecks', 'Writing pattern pat.\npat>0xff : pat goes from 0 to 255 in cycle.\nfile = 1 - read from config file\nfile = 0 - uses generated pattern\n', 'int', 'LoadFM0', [['pat', 'int', ''], ['Nwords', 'int', ''], ['file', 'int', '']]], ['FlMemChecks', 'Writing pattern pat.\npat>0xff : pat goes from 0 to 255 in cycle.\nfile = 1 - read from config file\nfile = 0 - uses generated pattern\nDifferent way of writing to FM:\n I do not increase at last step.\n I do increase with reset.\n', 'int', 'LoadFMErr', [['pat', 'int', ''], ['Nwords', 'int', ''], ['file', 'int', '']]], ['FlMemChecks', '  Correct errors stored in AddErr and DatErr.\n', 'int', 'Correct', []], ['FlMemChecks', 'Uses the Unlock Bypass Mode\n', 'int', 'LoadFMUB', [['pat', 'int', ''], ['Nwords', 'int', '']]], ['FlMemChecks', 'Check against 0 or what is written in LoadFM0.\n', 'int', 'Check0', [['Nwords', 'int', '']]], ['FlMemChecks', '', 'int', 'Comb', []], ['FlMemChecks', 'Monitars data lines after write or read\n', 'void', 'Monitor', [['Ntimes', 'int', '']]], ['VMETests', 'Large number of readings\n', 'void', 'VMEwrite', [['Pedjaddress', 'w32', ''], ['Ntimes', 'int', ''], ['word', 'w32', '']]], ['VMETests', 'Increasing address in big loop by reading and checking \nin it jumps.\n', 'void', 'ReadLoop', [['Nloops', 'int', '']]], ['VMETests', 'Increasing address in big loop by writing reset and checking \nin it jumps.\n', 'void', 'WriteLoop', [['Nloops', 'int', '']]], ['VME', 'VME write. Use Pedja address.\n', 'void', 'wvme', [['address', 'w32', ''], ['word', 'w32', '']]], ['VME', 'VME read.Use Pedja address.\n', 'w32', 'rvme', [['address', 'w32', '']]], ['VME', '', 'void', 'testcode', []], ['VME', '', 'void', 'temp', []], ['VME', '', 'void', 'testver', []]]
