self.baseAddr="0x810000"
self.spaceLength="0x800"
self.vmeregs=[('CODE_ADD', '0x4', ''), ('SERIAL_NUMBER', '0x8', ''), ('VERSION_ADD', '0xC', ''), ('SOFT_RESET', '0x28', ''), ('TEMP_START', '0x58', ''), ('TEMP_STATUS', '0x5c', ''), ('TEMP_READ', '0x60', ''), ('MASTER_MODE', '0x64', ''), ('LTUVERSION_ADD', '0x80', ''), ('TEST_ADD', '0xc0', ''), ('BC_STATUS', '0xc4', ''), ('ADC_SELECT', '0x4c0', ''), ('BC_DELAY_ADD', '0x4c8', ''), ('ADC_START', '0xcc', ''), ('ADC_DATA', '0xd0', ''), ('ERROR_ENABLE', '0xd4', ''), ('ERROR_STATUS', '0xd8', ''), ('ERROR_SELECTOR', '0xdc', ''), ('ERROR_DEMAND', '0xe0', ''), ('ERROR_RATE', '0x4e4', ''), ('ORBIT_CLEAR', '0xe8', ''), ('EMULATION_START', '0xec', ''), ('QUIT_SET', '0xf0', ''), ('BREAK_SET', '0xf4', ''), ('LAST_BC', '0x4f8', ''), ('PREPULSE_BC', '0x4fc', ''), ('CALIBRATION_BC', '0x500', ''), ('GAP_BC', '0x504', ''), ('ORBIT_BC', '0x508', ''), ('L1_DELAY', '0x50c', ''), ('L2_DELAY', '0x510', ''), ('TRG_TOGGLE', '0x5c4', ''), ('ORBIT_TIME', '0x5c0', ''), ('PP_TIME', '0x5c4', ''), ('TTC_DATA', '0x5c8', ''), ('RATE_LIMIT', '0x5cc', ''), ('SLM_ADD_CLEAR', '0x114', ''), ('SLM_DATA', '0x118', ''), ('EMU_STATUS', '0x11c', ''), ('START_SET', '0x520', ''), ('SOFT_TRIGGER', '0x124', ''), ('RANDOM_NUMBER', '0x528', ''), ('COUNT_PERIOD', '0x52c', ''), ('TTC_INTERFACE', '0x530', ''), ('STDALONE_MODE', '0x534', ''), ('BUSY_ENABLE', '0x138', ''), ('BUSY_STATUS', '0x13c', ''), ('SW_BUSY', '0x140', ''), ('L1_FORMAT', '0x544', ''), ('L1MAX_CLEAR', '0x148', ''), ('L2MAX_CLEAR', '0x14c', ''), ('SCOPE_SELECT', '0x550', ''), ('BACKPLANE_EN', '0x554', ''), ('MINIMAX_SELECT', '0x570', ''), ('MINIMAX_LIMIT', '0x578', ''), ('FIFO_MAX', '0x158', ''), ('SOFT_LED', '0x15c', ''), ('BUSYMAX_DATA', '0x168', ''), ('BUSYMINI_DATA', '0x16c', ''), ('MINIMAX_CLEAR', '0x174', ''), ('PIPELINE_CLEAR', '0x198', ''), ('SSMcommand', '0x19c', ''), ('SSMstart', '0x1a0', ''), ('SSMstop', '0x1a4', ''), ('SSMaddress', '0x1a8', ''), ('SSMdata', '0x1ac', ''), ('SSMstatus', '0x1b0', ''), ('TIMING_TEST', '0x1b8', ''), ('PLL_RESET', '0x1bc', ''), ('TIMING_TEST', '0x1b8', ''), ('TTC_STATUS', '0x1c8', ''), ('COPYCOUNT', '0x1d4', ''), ('COPYBUSY', '0x1d8', ''), ('COPYCLEARADD', '0x1dc', ''), ('COPYREAD', '0x1e0', ''), ('CLEARCOUNTER', '0x5ac', ''), ('CODE_ADD', '0x4', ''), ('SERIAL_NUMBER', '0x8', ''), ('VERSION_ADD', '0xC', ''), ('SOFT_RESET', '0x28', ''), ('TEMP_START', '0x58', ''), ('TEMP_STATUS', '0x5c', ''), ('TEMP_READ', '0x60', ''), ('MASTER_MODE', '0x64', ''), ('LTUVERSION_ADD', '0x80', ''), ('TEST_ADD', '0xc0', ''), ('BC_STATUS', '0xc4', ''), ('BC_DELAY_ADD', '0x4c8', ''), ('ADC_START', '0xcc', ''), ('ADC_DATA', '0xd0', ''), ('SCOPE_SELECT', '0x550', ''), ('SOFT_LED', '0x15c', ''), ('SSMcommand', '0x19c', ''), ('SSMstart', '0x1a0', ''), ('SSMstop', '0x1a4', ''), ('SSMaddress', '0x1a8', ''), ('SSMdata', '0x1ac', ''), ('SSMstatus', '0x1b0', ''), ('PLL_RESET', '0x1bc', ''), ('COPYCOUNT', '0x1d4', ''), ('COPYBUSY', '0x1d8', ''), ('COPYCLEARADD', '0x1dc', ''), ('COPYREAD', '0x1e0', ''), ('CLEARCOUNTER', '0x5ac', ''), ('ADC_SELECT', '0x480', ''), ('PATTERN_SEL', '0x484', ''), ('SEQ_PERIOD', '0x488', ''), ('SEQ_DATA', '0x48c', ''), ('RANDOM_RATE', '0x490', ''), ('SYN_EDGE', '0x494', ''), ('DELAY_1', '0x498', ''), ('DELAY_2', '0x49c', ''), ('CLEAR_ERR1', '0x4a0', ''), ('CLEAR_ERR2', '0x4a4', ''), ('ERROR_STATUS', '0x200', '')]
self.hiddenfuncs=""
self.funcs=[['ExpertConf', 'Set parameter name to value\n', 'int', 'setOption', [['name', 'char', '*'], ['value', 'char', '*']]], ['Configuration', "Set 'L0 mode' :\n'L0 over fibre'         if ttcint is 8\n'L0 over cable'         if ttcint is 0\n\nThis routine sets the TTC_INTERFACE register. It calculates\n2 least sifnificant bits (from BC_DELAY_ADD register). Bits 2..3 are\ntaken from ttcint parameter.\nsetTTCint() should be invoked ALWAYS AFTER BC_DELAY_ADD change.\nThe 4 least significant bits of this register are used for setting:\n- 12.5ns delay for Orbit and/or L1\n- the polarity of L1 output      \n- 'L0 over TTC' mode\n\nTTC_INTERFACE bits:\n0  'Delay Orbit' flag. 0: no delay, 1: 12.5ns delay\n1  'Delay L1' flag. 0: no delay, 1: 12.5ns delay\n   Both bits depends on BC_DELAY_ADD.\n2   L1 polarity.    0: positive (TTCex, default)   1: negative (TTCvi)\n3  'L0 over TTC' flag. \n   0:  normal mode (only L1 as 1 bit over A-TTC channel)\n   1:  'L0overTTC' mode. In this mode: \n   - L0 is sent over coaxial cable as in normal mode. In addition,\n        it is sent over A-TTC channel as 2 bits '10' in 2 BC clocks\n   - L1 is sent as 2 bits '11' over A-TTCchannel\n", 'void', 'setTTCint', [['ttcint', 'w32', '']]], ['Configuration', 'set BC_DELAY_ADD (0..31 in ns). setTTCint is activated after BC_DELAY_ADD\nwritten.\n', 'int', 'fpgainit', []], ['Configuration', "- initialise TTCvi for operation in STANDALONE mode\n- reset TTCrx over fibre (TTCrxready goes OFF for ~6ms)\n- set Control register 3 in TTCrx (over fibre), enabling Dout strobe \n- set FineDelay1,FineDelay2 and CoarseDelay TTCrx registers \n- send FEEreset (after more than 1 second)\n- check BUSY signal and print Warnings and/or Errors:\n  Warning: BUSY is ON before TTCrx reset\n  Error: BUSY not raised during 'TTCrx READY' off\n  Warning: BUSY not raised during 'QPLL LOCKED' off (if QPLL clock is used)\n  Error: BUSY ON 10milsecs after FEEreset\n", 'int', 'TTCinit', []], ['ConfiguratioH', '- initialise TTCvi \n- reset TTCrx (over fibre)\n- set Control register 3 in TTCrx (over fibre), enabling Dout strobe\nInput: stdalone=1 if values valid for standalone are to be loaded\n                0 if global configuration is required \n       secs: number of seconds to wait till FEE becomes ready\n', 'int', 'TTCinitgs', [['stdalone', 'int', ''], ['secs', 'int', '']]], ['Configuration', 'Show shared memory content. Shared memory variables can be \nmodified by Load from memory/Save buttons in Defaults editor.\n', 'void', 'printltuDefaults', []], ['Configuration', 'Set Prepulse delay directly on TTCvi board. \nWarning: delay is set only on TTCviboard (i.e. it is not changed\nin memory, which means, TTCinit will set it back to value\nstored in shared memory (see Defaults editor)\n', 'int', 'ttcPPdelay', [['bc', 'int', '']]], ['Configuration', 'Set delay registers directly in TTCrx, without resetting TTCrx.\nInput:\nFine1ps, Fine2ps: required Fine delays on TTCrx chip in ps\nCoarse: the required content of TTCrx Coarse register\n', 'int', 'ttcDelays', [['Fine1ps', 'int', ''], ['Fine2ps', 'int', ''], ['Coarse', 'int', '']]], ['Configuration', "-send 'Front End Electronics reset command' through TTC B-channel.\n The header '0x8' is reserved for this command (e.g. 0x3 is allocated\n for L2accept header).\n", 'int', 'ttcFEEreset', []], ['Configuration', "-send 'Front End Electronics user defined command' through TTC B-channel.\nCommand field: number 8-15 \nCommand '8' is altready reserved for ttcFEEreset\n", 'int', 'ttcFEEcmd', [['Command', 'int', '']]], ['Configuration', '', 'GUI', 'setGLOBAL', [], 'setGLOBAL'], ['Configuration', '', 'GUI', 'setSTDALONE', [], 'setSTDALONE'], ['SimpleTests', 'returns temperature on the board in centigrades (-100 if error) ', 'int', 'ReadTemperature', []], ['ConfiguratioH', '', 'int', 'getgltuver', []], ['SimpleTests', 'Return average busy time (busy/L0) during 100milsecs\n', 'int', 'measureBusy100ms', []], ['SimpleTests', 'Measure busy between 2 mouse clicks\n', 'int', 'measureBusy', []], ['SLM', '', 'void', 'SLMsetstart', [['sel', 'w32', '']]], ['SLM', '', 'int', 'SLMgetstart', []], ['SLM', '', 'int', 'SLMswstart', [['n', 'int', ''], ['milsecs', 'int', '']]], ['SLM', '', 'int', 'SLMstart', []], ['SLM', '', 'void', 'ERenadis', [['enadis', 'int', '']]], ['SLM', '', 'void', 'ERsetselector', [['selector', 'w32', '']]], ['SLM', '', 'void', 'ERdemand', [['demand', 'w32', '']]], ['SLM', '', 'int', 'SLMreadasci', [['filen', 'char', '*'], ['slmdata', 'w32', '*']]], ['SLM', '', 'int', 'SLMload', [['filen', 'char', '*']]], ['SLM', '', 'int', 'SLMquit', []], ['SLM', '', 'int', 'SLMwaitemuend', [['micsec', 'int', '']]], ['ConfiguratioH', '', 'void', 'setBUSY', [['binputs', 'w32', '']]], ['FrontPanel', '', 'void', 'setAB', [['A', 'w32', ''], ['B', 'w32', '']]], ['SSM', '', 'int', 'SSMsetom', [['opmo', 'w32', '']]], ['SSM', '', 'void', 'SSMstartrec', [['mode', 'w32', '']]], ['SSM', '', 'void', 'SSMstoprec', []], ['SSM', '', 'int', 'SSMdump', []], ['SSM', '', 'void', 'SSMschedule', [['whenmode', 'w32', '']]], ['SSM', '', 'int', 'SSMclearac', []], ['SSM', '', 'void', 'SSMclear', []], ['Configuration', 'Automatic synchronisation of CTP and LTU signal transitions. \nBefore this measurement is started,\narrange the following:\n- this LTU is in GLOBAL mode\n- L1 Data signal (CTP input connector) is continuously toggled\n  by BCclock frequency/2\n', 'GUI', 'ADC_Scan', [], 'ADC_Scan'], [None, 'Signal selection for front panel \nA,B outputs\n', 'GUI', 'ScopeAB', [], 'Scope Signals'], [None, 'Counters monitor ', 'GUI', 'Counters', [], 'Counters'], ['FrontPanel', '', 'void', 'getCounters', [['N', 'int', ''], ['increments', 'int', '']]], ['FrontPanel', '', 'void', 'clearCounters', []], ['LVDST', " \nTp - Transition of the Synchronised Pattern Signal\nFrom here you will be able to make a ADC scan for the \npattern signal. The pattern is setted to be TOGGLE. \nThe aim of this function is to find something known \nas the exclusion zone of the BC_DELAY_ADD register. \nThis zone correspond to the worst possible setting for that \nregister. This is an hardware dependence constant.\n\nprint option\n\t0  --> Print some comments\n\t1  --> Don't print anything\n\n ", 'int', 'Tp_transition', [['print', 'int', '']]], ['LVDST', '\nTs - The best setting for the BC_DELAY_ADD register\n ', 'int', 'Ts_transition', []], ['LVDST', '\nFor Pattern delay measurement. \nThe aim of this function is to find the correct settings for the\nDELAY_1 register. This function uses the results from previous Syn functions.\n', 'int', 'D_pattern_delay', [['print', 'int', '']]], ['LVDST', "WindowFinding function.\nDelay done in Nano-seconds. We will start from the best possible point according \nto the cable. This value is obtained by the CableSignalSyn function.\n\nkFrom and kTo     this defind the measure range.\n\t\t  A full test will be from kFrom=0 to kTo=31\n\nseqTpye \n\t--> 1  for sequence pattern  0x800000\n\t--> 2  for sequence patter   0xaaaaaa\n\t--> 3  for random pattern\n\nrunType \n\t-->1    This correspond to a normal run (53 secs) \n\t\tType time=0 and timeUnits='n'\n        --> 0   Time and timeUnits defind by the user.\n                timeUnits   's' for seconds\n\t\t  \t    'h' for hours\ne.g. runType=0, time=1 and timeUnits='s' correspond to 1 sec run for each measure\n\n\nNOTE: To stop this program, please press CONTROL + X\n", 'void', 'Find_Window', [['fromSetting', 'int', ''], ['toSetting', 'int', ''], ['seqType', 'int', ''], ['runType', 'int', ''], ['time', 'int', ''], ['timeUnits', 'char', '']]], ['LVDST', 'findHistory function.\nFollowing up the previous measurement, i.e. the sampling window determination, this function\nreads the error counter in a regular interval of 1 minute. The idea here is to show whether \nthe errors occurred in a burst or they were spread evenly over the entire period of measurement.\n\nkFrom and kTo     this defind the measure range.\n                  A full test will be from kFrom=0 to kTo=31\n\nseqTpye\n        --> 1  for sequence pattern  0x800000\n        --> 2  for sequence patter   0xaaaaaa\n        --> 3  for random pattern\n\ntimeSteps is the entire period of measurement. If timeSteps is equal to 3,\nthe measurement will last for 3 minutes.\n\nNOTE: To stop this program, please press CONTROL + X\n', 'void', 'Find_History', [['fromSetting', 'int', ''], ['toSetting', 'int', ''], ['seqType', 'int', ''], ['timeSteps', 'int', '']]], ['SimpleTests', 'Click to Stop/Start blinking\nfront panel LEDs\n  ', 'void', 'TestLEDS', []], ['ConfiguratioH', 'Print 1 line string xxxx\nwhere x is the status (0/1) of software LED word\n', 'void', 'getSWLEDS', []]]
