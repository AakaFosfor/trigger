/* ctp_proxy:
16.12.2007:
- infoLogger added (only 1 message: see generateXOD()).
  facility  "CTP"
  stream    "" or part.name if available
  system    TRG (default set in /opt/infoLogger)
- xcounters added (uses offline tag:CTP_xcounters) -not tested: 
  todo: uncomment xcountersStart/Stop
17.12.
DAQlogbook_verbose(1);      -to be removed later
- EOR actions: uses online tag CTP_runconfig
18.12.
EOD failure: does not cause ctp_proxy to go to ERRROR state. BUT e.g.
failure in load2HW leaves ctp_proxy in ERROR state -it can have serious
consequences for active partitions (if any)
18.12
prepareRunConfig/registerRunConfig
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "infolog.h"
#ifdef CPLUSPLUS
#include <dic.hxx>
#ifndef TEST
extern "C" {
#include "DAQlogbook.h"
}
#endif
#else
#include <dic.h>
#ifndef TEST
#include "DAQlogbook.h"
#endif
#endif

#include "vmewrap.h"
#include "vmeblib.h"
#include "ctp.h"
#include "ssmctp.h"
#include "Tpartition.h"
#include "ctp_proxy.h"
//#include "../ltu/ltu.h"     from ltu.h file:
#define LTUNCOUNTERS   21
#define COPYCOUNT      0x1d4   /*dummy wr. copy counters CMD */
#define COPYCLEARADD   0x1dc   /*dummy wr. clear copy mem. add. */
#define COPYREAD       0x1e0   /*ro copy memory data */

#define FOMODE 0 

extern int quit;
extern char partmode[];

// Partition HW is the final configuration which is loaded to hw.
// HW = part[0]+part[1] + .... +part[5]
Hardware HW, HWold;
Tpartition *AllPartitions[MNPART]; //=Started + Loaded
Tpartition *StartedPartitions[MNPART]; // = Started only
/*----------------------------------------------void getNAllPartitions();
*/
int getNAllPartitions() {
int i,rc=0;
for(i=0; i<MNPART; i++) {
  if(AllPartitions[i]!=NULL) 
    rc++;
}; return(rc);
}
/*----------------------------------------------void printStartedTp();
*/
void printStartedTp() {
int i;
for(i=0; i<MNPART; i++) {
  if(StartedPartitions[i]!=NULL) 
    printf("   %d: %s\n", i, StartedPartitions[i]->name);
}; printf("\n");
}
/*----------------------------------------------void printAllTp();
*/
void printAllTp() {
int i;
for(i=0; i<MNPART; i++) {
  if(AllPartitions[i]!=NULL) 
    printf("   %d: %s\n", i, AllPartitions[i]->name);
}; printf("\n");
}
/*------------------------------------------------------ checkInputs()
*/
int checkInputs(Tpartition *part){
return(0);
}
/*---------------------------------------------------finditem2checkRBIF()
  Find item to check in rbif.
  Called by: checkpairRBIF
*/
int finditem2checkRBIF(int icheck,int *item1,int *item2){
 int i1,i2;
 switch(icheck){  // find what to check
  case ixrnd1:
        i1=ixrnd1;i2=ixrnd2;break;
  case ixrnd2:
        i1=ixrnd1;i2=ixrnd2;break;
  case ixbc1:
        i1=ixbc1;i2=ixbc2;break;
  case ixbc2:
        i1=ixbc1;i2=ixbc2;break;
  case ixintfun1:
        i1=ixintfun1;i2=ixintfun2;break;
  case ixintfun2:
        i1=ixintfun1;i2=ixintfun2;break;
  case ixl0fun1:
        i1=ixl0fun1;i2=ixl0fun2;break;
  case ixl0fun2:
        i1=ixl0fun1;i2=ixl0fun2;break;
  default:
       printf("checkpairRBIF: internal error: item %i doeas not exist.\n",icheck);
       return 1;
 } 
 *item1=i1;
 *item2=i2;
 return 0;
}
/*------------------------------------------------------ checkpairRBIF()
 Purpose: to check availibilty of resources for pair of items in RBIF, 
         i.e: (rnd1,rnd2),(bc1,bc2),(int1,int2)
*/
int checkpairRBIF(int icheck,TRBIF *cumrbif,TRBIF *prbif){
 int i1,i2,ix,iused;
 ix=prbif->rbifuse[icheck];   // position in hw where saved 
 if(ix == notused) return 0;  // not used in part
 if(ix != nothwal){           // hw alloceted, check if ok
   if(cumrbif->rbifuse[ix] == notused){ // add to cum
      cumrbif->rbifuse[ix] = ix;
      cumrbif->rbif[ix] = prbif->rbif[icheck];
      return 0;
   }else{   // check if values equal
      if(cumrbif->rbif[ix] != prbif->rbif[icheck]){
         printf("checkpairRBIF: internal error: %x rbif already allocated./n",ix);
         return 1;
      }else return 0;      
   }
 }
 // Here only new partition should come
 if(finditem2checkRBIF(icheck,&i1,&i2)) return 1;
 iused=(cumrbif->rbifuse[i1]==notused)+((cumrbif->rbifuse[i2]==notused)<<1);
 //if(DBGcumRBIF)printf("checkPairRBIF-------------------->%i %i %i %i\n",icheck,i1,i2,iused);
 switch(iused){
  case 3:  // none used
           cumrbif->rbifuse[i1]=i1;
           cumrbif->rbif[i1]=prbif->rbif[icheck];
           prbif->rbifuse[icheck]=i1;
           return 0;
  case 2: // i1 used
          if(cumrbif->rbif[i1] == prbif->rbif[icheck]){ 
          //new resource eqal to existing
            prbif->rbifuse[icheck]=i1; 
            return 0;
          }else{  // store to free i2
            cumrbif->rbifuse[i2]=i2;
            cumrbif->rbif[i2]=prbif->rbif[icheck];
            prbif->rbifuse[icheck]=i2;
            return 0;
          }
  case 1: // i2 used
          if(cumrbif->rbif[i2] == prbif->rbif[icheck]){ 
          //new resource eqal to existing
            prbif->rbifuse[icheck]=i2; 
            return 0;
          }else{  // store to free i1
            cumrbif->rbifuse[i1]=i1;
            cumrbif->rbif[i1]=prbif->rbif[icheck];
            prbif->rbifuse[icheck]=i1;
            return 0;
          }
  case 0: // resource not available
          if(cumrbif->rbif[i1] == prbif->rbif[icheck]){
            prbif->rbifuse[icheck]=i1;
            return 0;
          }else if(cumrbif->rbif[i2] == prbif->rbif[icheck]){
            prbif->rbifuse[icheck]=i2;
            return 0;
          }else{
           printf("checkpairRBIF: resource %i not available\n",icheck);
           return 2;
          }
  default:
          printf("checkpairRBIF: internal error; iused=%i\n",iused);
          return 1;
 }
}
/*-------------------------------------------------------------------
Check BCmasks resource.
Last bcmask overrites everything.
WORKS WHEN ONLY ONE partiiton uses bcmasks 
*/
int checkBCMASKS(TRBIF *cumrbif,TRBIF *prbif){
 int i;
  if(prbif->BCMASKuse[0]){
   strcpy(cumrbif->BCMASK,prbif->BCMASK);
  }
 for(i=0;i<4;i++){
   cumrbif->BCMASKuse[i]=1;  
 } 
 return 0;
}
/*------------------------------------------------------ cumRBIF()
Operation: Take partition and add its RBIF to cumrbif
rc: 0: ok
    1: cannot cumulate, error message printed, cumrbif not changed
    todo: intsel,bcmask
*/
int cumRBIF(Tpartition *part, TRBIF *cumrbif) {
TRBIF rbifloc;
copyTRBIF(&rbifloc, cumrbif);
if(checkpairRBIF(ixrnd1,&rbifloc,part->rbif))goto ERR1;
if(checkpairRBIF(ixrnd2,&rbifloc,part->rbif))goto ERR1;
if(checkpairRBIF(ixbc1,&rbifloc,part->rbif))goto ERR1;
if(checkpairRBIF(ixbc2,&rbifloc,part->rbif))goto ERR1;
if(checkpairRBIF(ixl0fun1,&rbifloc,part->rbif))goto ERR1;
if(checkpairRBIF(ixl0fun2,&rbifloc,part->rbif))goto ERR1;
if(checkpairRBIF(ixintfun1,&rbifloc,part->rbif))goto ERR1;
if(checkpairRBIF(ixintfun2,&rbifloc,part->rbif))goto ERR1;
if(checkBCMASKS(&rbifloc,part->rbif))goto ERR1;
copyTRBIF(cumrbif, &rbifloc);
return(0);
ERR1:
prtError("cumRBIF error");
return(1);
}
/*------------------------------------------------------checkRBIF()
  Purpose: to check if any free RBIF
  Parameters: 
       input:*part pointer to partition which is examined
       output:?
  Globals: ?
  Return: error code = 0 if ok
                      = 1 RBIF are not free
                      = 2 AllPartitions over resources (intError)
  Called by: checkResources
  Comment: 
   - go through AllPartitions classes and find which resources are necessary
   - at last go through new partition classes and check if *part can be 
     added to AllPartitions
*/
int checkRBIF(Tpartition *part, Tpartition *parray[]){
int ixp,flag;
TRBIF myrbif; 
Tpartition *part1;
cleanTRBIF(&myrbif);
// go through existing partitions:
// BCMASK test to be added, at the moment new pertition rewrites everything
for(ixp=0;ixp<MNPART;ixp++){
  if((part1=parray[ixp])==NULL) continue;
  if(cumRBIF(part1, &myrbif)) {   //int error
    intError("Active partitions' resources over available resources");
    return 2; 
  };
};
flag=0;
if(parray==StartedPartitions)flag=1;
// now check if new part. can be added:
if(cumRBIF(part, &myrbif)) {
  char *msg="Partition cannot be added due to lack of resources";
  if(flag)intError(msg); else prtError(msg);
  return(1);
};
//copyTRBIF(&HW.rbif,&myrbif);
return 0;
}
/*------------------------------------------------------checkClusters()
  Purpose: to check if any free clusters
  Parameters: 
        input: *part: pointer to partition which is examined
  Globals: 
        input AllPartitions[];
  Return: error code = 0 if ok
                       1 not enough clusters
                       2 any other error
  Called by: checkResources()
*/
int checkClusters(Tpartition *part){
 int i,nclust,nPart;
 nofclustTpartition(part,&nclust);
 for(i=0;i<MNPART;i++){
  if(AllPartitions[i]){
   nofclustTpartition(AllPartitions[i],&nPart);
   nclust=nclust+nPart;
  }
 }
 printf("checkClusters: # of clusters %i\n",nclust);
 if(nclust>6){
  printf("CheckClusters: not enough clusters: %i\n",nclust);
  return 1;
 }
 return 0;
}
/*------------------------------------------------------checkDetectors()
 Purpose: check if detectors of new partition are amongs detectors
          of existing partitions
 Parameters: 
       input: *part: pointer to partition which is examined
 Globals: 
       input: AllPartitions[]
 Return: 0 if ok
         1 detector of *part is already in at least 1 partition
 Called by: CheckResources() 
 Comment: stop at first error
*/
int checkDetectors(Tpartition *part){
 int i,j,flag;
Tpartition *loadedp;
 for(i=0;i<MNPART;i++){
  loadedp= AllPartitions[i];
  if(loadedp == NULL) continue;
   for(j=0;j<NDETEC;j++){
    if(loadedp->Detector2Clust[j] == 0) continue;
    if(checkdetTpartition(part,j,&flag)) return 2;
    if(flag){
      char emsg[ERRMSGL];
      sprintf(emsg, 
        "%s not loaded. Detector %s(%i) already used in partition %s\n",
        part->name, validLTUs[j].name,j, loadedp->name);
      infolog_trgboth(LOG_FATAL, emsg);
      return 1;
    }
   }
  }
 return 0;
}
/*------------------------------------------------------checkResources()
  Purpose: check conflict of resources of new *part against partitions
           saved in AllPartitions[]
  Parameter: 
        input: *part: pointer to partition which is examined
  Globals: 
        input: AllPartitions[]
  Return: 0 if ok
          1 if not enough resources 
          2 any other error
  Called by: ctp_StartPartition() 
  Comment: Checked items: 
     -are detectors from new *part already in existing partitions ?
     -are the free clusters ?
     -are there free classes ?
     -are there free RBIF ?
     -are rhere free PastFut ?
     - ?     
*/
int checkResources(Tpartition *part){
  int ret=0;
  //printf("checkResources: checking ... \n");
  // Detectors in different partitions
  if((ret=checkDetectors(part)))return ret;
  //Cluster resources
  if((ret=checkClusters(part))) return ret;
  // RBIF resources 
  if((ret=checkRBIF(part,AllPartitions))) return ret;
  // PF resources
  if((ret=checkInputs(part))) return ret;
  // PF resources

  return 0;
}
/*-----------------------------------------------------addRBIF2HW()
Merge all partitions' shared resources to HW
- first do 'dry run' (HW not changed)
- if OK change HW 
RET: 0: merge OK     1:not merged, HW not changed
*/
int addRBIF2HW(Tpartition *parray[]) {
int ip;
Tpartition *part;
TRBIF rbifloc;   // for check before HW is changed
copyTRBIF(&rbifloc, HW.rbif);
for(ip=0;ip<MNPART;ip++){           //loop over partitions
  if(parray[ip] == NULL) continue;
  //printf("Partition %i \n",ip);
  part=parray[ip];
  if(cumRBIF(part, &rbifloc)) goto ERR1;
  // todo: MASKS:
};
copyTRBIF(HW.rbif, &rbifloc);
return(0);
ERR1:return(1);
}
/*---------------------------------------------------- findfreeHWCluster()
Loop over all partitions' ClusterTables
return: 1-6
        0 - no free cluster
*/
w32 findfreeHWCluster() {
int ip,icl;
w32 ret;
int fc[NCLUST]={0,0,0,0,0,0};   // part.# 1-6 which uses this hwcluster:
Tpartition *part;
for(ip=0;ip<MNPART;ip++){           //loop over partitions
  if(AllPartitions[ip] == NULL) continue;
  part=AllPartitions[ip]; 
  if(DBGaf2HW) printf("findfreeHWCluster: Partition %i \n",ip);
  //bad idea if((part->hwallocated)&0x1==0) continue;  // new partition
  // better to count with  new partition (it may have already some cluster allocated)
  for(icl=0; icl<NCLUST; icl++) {
    if(part->ClusterTable[icl]!=0) {  // hw cluster icl allocated for part (!=0)
      if( fc[icl] != 0) {             // and in the same time 
        if( fc[icl] != (ip+1) ) {
          intError("findfreeHWCluster:");
        };
      } else {
        fc[icl]= ip+1;   // icl kept by ip
      };
    };
  };
};
ret=0;
if(DBGaf2HW) printf("  partitions keeping clusters 1-6:\n");
for(icl=0; icl<NCLUST; icl++) {
  if( fc[icl]==0 ) {ret= icl+1;   // free cluster
    break;
  } else {
    if(DBGaf2HW) 
      printf("  HWcluster(1-6) %d kept by part. %d\n", icl+1, fc[icl]);
  };
};
if(DBGaf2HW) printf(  "  Returning:%d\n", ret);
return(ret);
}
/*---------------------------------------------------- findHWCluster()
Input: part, pcluster:1-6.
return: hw cluster (1-6)
        0: intError (should be found, but was not)
*/
w32 findHWCluster(Tpartition *part, w32 pcluster) {
w32 icl,icluster;
for(icl=0; icl<NCLUST; icl++) {
  if(part->ClusterTable[icl]==pcluster) {
    icluster= icl+1; return(icluster);
  };
};
if((part->hwallocated&0x1)==0x1) {// this part. has already its clus allocated
  char emsg[ERRMSGL];
  sprintf(emsg, "findHWCluster: pcluster %d not found", pcluster);
  intError(emsg);
  printf("ClusterTable (cluster numbers used in .pcfg file):");
  for(icl=0; icl<NCLUST; icl++) {
    printf(" %d",part->ClusterTable[icl]);
  }; printf("\n");
} else {
  char emsg[ERRMSGL];
  sprintf(emsg, "findHWCluster:partname:%s hwallocated:0x%x pcluster:%d", 
    part->name, part->hwallocated, pcluster);
};
return(0);
}
/*---------------------------------------------------- rNNNN.rcfg */
void getruncfgname(w32 run, char *runcfg) {
char *environ;
environ= getenv("VMEWORKDIR"); strcpy(runcfg, environ);
sprintf(runcfg, "%s/WORK/RCFG/r%d.rcfg", runcfg, run);
}
/*---------------------------------------------------updateDAQClusters()
rc: 0: ok   >0 stop the run
2:  indets= getInputDets(HW.klas[hwclass]);   error
3: cannot update trigger config with .rcfg file
4: DAQlogbook_update_cluster() failed
9: DAQlogbook update unsuccessful
10 internal error
*/
int updateDAQClusters(Tpartition *partit) {
int idet, iclu, iclass, rc;
int rco;    // 0: DAQlogbook opened    -1: not opened
int rcdaqlog=0;    // rc from updateDAQClusters(). 0: ok  >1 stop the run
w32 daqonoff;
w32 masks[NCLUST];      // detectors in each CLUSTER
w32 inpmasks[NCLUST];   // input detectors feeding each CLUSTER
unsigned long long classmasks[NCLUST];  // classes for each CLUSTER
unsigned long long ULL1=1;
char *vmesite;
char DAQlogbookDB[120]="", emsg[ERRMSGL];
/* only if we need verbose output:
DAQlogbook_verbose(1);     */
vmesite=getenv("VMESITE");
if(vmesite !=NULL) {
  if(strcmp(vmesite,"ALICE")==0) {
    strcpy(DAQlogbookDB, "daq:daq@aldaqdb/LOGBOOK");
  } else if(strcmp(vmesite,"SERVER")==0) {
    strcpy(DAQlogbookDB, "daq:daq@pcald30/LOGBOOK");
  } else {
    strcpy(DAQlogbookDB, "");
  };
};
sprintf(emsg, "Opening DAQlogbook:%s", DAQlogbookDB);
prtLog(emsg);
{
#define MAXALIGNMENTLEN 4000
        char alignment[MAXALIGNMENTLEN];
        getctp_alignment(alignment, MAXALIGNMENTLEN);
        if(alignment=='\0') {
          infolog_trgboth(LOG_FATAL, "Alignment info in DAQlogbook is empty");
        };
        prtLog(alignment);
//-------
};
#ifdef TEST
  prtLog("updateDAQClusters: no attemt for DAQlogbook:  TEST mode.");
  rco=0;
#else
rco= DAQlogbook_open(DAQlogbookDB);
if(rco==-1) {
  prtError("DAQlogbook_open failed");
  infolog_trg(LOG_FATAL, "DAQlogbook_open failed");
}else{
  prtLog("DAQlogbook opened succesfuly.");
}
#endif
if(partit->run_number<10) { return(0); };
for(iclu=0;iclu<NCLUST;iclu++){
  masks[iclu]=0;
  inpmasks[iclu]=0;
  classmasks[iclu]=0;
};
//--------------------- masks:
for(idet=0;idet<NDETEC;idet++){
  int pclu, pclust, hwclust;
  pclust= partit->Detector2Clust[idet]; // det. can belong to more clusters!
  if(pclust ==0) continue;
  // idet is in pclust, find HWclust:
  for(pclu=0; pclu<NCLUST; pclu++) {
    if(pclust & (1<<pclu)) {
      hwclust= findHWCluster(partit, pclu+1);
      if(hwclust>0) {
        masks[hwclust-1]= masks[hwclust-1] | (1<<idet);
      };
    };
  };
};
if(DBGlogbook) 
  printf("updateDAQClusters:masks[0-5]:0x:%x %x %x %x %x %x\n",
  masks[0], masks[1], masks[2], masks[3], masks[4], masks[5]);
//--------------------- classmasks and inpmasks:
for(iclass=0; iclass<NCLASS; iclass++) {
  int hwclass; w32 indets; TKlas *klas;
  if((klas=partit->klas[iclass]) == NULL) continue;
  hwclass= partit->klas[iclass]->hwclass;  // 0..49
  if(hwclass>49) {
    intError("updateDAQClusters: hwclass>49"); rcdaqlog=10;
  };
  iclu= (HW.klas[hwclass]->l0vetos & 0x7)-1;
  classmasks[iclu]= classmasks[iclu] | (ULL1<<hwclass);
  indets= getInputDets(HW.klas[hwclass]);
  if(indets<0) rcdaqlog=2;   
  if(DBGlogbook) printf("updateDAQClusters:hwallocated:%d iclu:%d iclass:%i indets:0x%x\n",
    partit->hwallocated, iclu, iclass, indets);
  inpmasks[iclu]= inpmasks[iclu] | indets;
};
daqonoff= vmer32(INT_DDL_EMU) &0xf;
for(iclu=0;iclu<NCLUST;iclu++){
  if(masks[iclu]==0) continue;
  if(daqonoff==0) { // ctp readout active, set TRIGGER bit17 
    masks[iclu]= masks[iclu] | (1<<17);
  };
  printf("updateDAQClusters:run#:%d cluster:%d det/inp/class mask:0x:%x %x %llx\n", 
    partit->run_number, iclu+1, masks[iclu], inpmasks[iclu], classmasks[iclu]);
#ifndef TEST
  if(rco!=-1) {
    int rc;
    rc=DAQlogbook_update_cluster(partit->run_number, iclu+1, 
      masks[iclu], partit->name, inpmasks[iclu], classmasks[iclu]);
    if(rc!=0) {
      prtError("DAQlogbook_update_cluster failed");
      rcdaqlog=4;
    };
  };
#endif
};
{
  int len;
  char *mem;
  FILE *ifile;
  char name[80];
  //--------------------- WORK/RCFG/rNNN.rcfg file -> DAQlogbook
  /*Operation:
    malloc,read,update DAQlogbook, free, remove
  */
  //sprintf(name,"WORK/RCFG/r%d.rcfg", partit->run_number);
  //getruncfgname(partit->run_number, name);
  sprintf(name, "/tmp/r%d.rcfg", partit->run_number);
  len= detectfile(name, 9);    // wait max. 5 secs for file
  /*sprintf(emsg, "updateDAQClusters: Run: %d file:%s len:%d",
    partit->run_number, name, len); prtLog(emsg); */
  /*if(len<=0) {
    printf("%s not found, trying /tmp/r%d.rcfg\n",name, partit->run_number);
    printf("%s not found, trying /tmp/r%d.rcfg\n",name, partit->run_number);
  }; */
  if(len>0) {
    ifile= fopen(name,"r");
    if(ifile==NULL) {
      sprintf(emsg, "updateDAQClusters: File: %s not opened\n",name);
      prtError(emsg);
      //rcdaqlog=3;
    } else {
      int ix, rl;
      //sprintf(emsg, "updateDAQClusters: Run: %d file:%s opened",
      //  partit->run_number, name); prtLog(emsg);
      mem= (char *)malloc(len+1);
      ix=0; mem[0]='\0';
      rl=fread((void *)mem, 1, len, ifile); mem[rl]='\0';
      if(rl != len) {
        sprintf(emsg, "updateDAQClusters: File: %s read error\n",name); prtError(emsg);
      };  
      //printf("%s\n", mem);
#ifndef TEST
      if(rco!=-1) {
//#define MAXALIGNMENTLEN 4000
        char alignment[MAXALIGNMENTLEN];
        getctp_alignment(alignment, MAXALIGNMENTLEN);
        if(alignment=='\0') {
          infolog_trgboth(LOG_FATAL, "Alignment info in DAQlogbook is empty");
        };
        prtLog(alignment);
        rc= DAQlogbook_update_triggerConfig(partit->run_number, mem);
        //rc= DAQlogbook_update_triggerConfig(partit->run_number, mem, alignment);

      };
#else
      rc=0;
#endif
      fclose(ifile); free(mem); 
      rl= remove(name);
      sprintf(emsg, "updateDAQClusters: Run: %d file:%s\nDAQlogbook_update_triggerConfig() rc:%d\n",
        partit->run_number, name, rc);
      //if(rc != 0) {
      prtLog(emsg);
      //};
      if(rl != 0) {
        sprintf(emsg, "updateDAQClusters: File: %s not removed\n",name); prtError(emsg);
      };
    };
  } else {
    sprintf(emsg, "updateDAQClusters: Partition:%s file %s not found.\n", partit->name, name);
    prtError(emsg);
    infolog_trg(LOG_ERROR, emsg);
#ifdef TEST
#else
    rcdaqlog=3;
#endif
  };
};
//-------------------------------- close
#ifndef TEST
  rc= DAQlogbook_close();
  if(rc==-1) {
    prtError("DAQlogbook_close failed");
  };
if(rcdaqlog==0) {
  if(rco!=0) rcdaqlog=9;
};
#endif
return(rcdaqlog);
}
/*---------------------------------------------------clusterPart2HW()
  Purpose: to convert clustercodes in partition frame to
           cluster codes in Hardware frame
  Parameters: 
        input: pclustcodes - in *part structure  0..5
               1 detector can belong to more clusters!
        output: hclustcode - clustercode in HW structure
  Globals: none
  Returns: error code = 0 if ok
                        1 if error
  Comment: assignment of clusters in HW 
*/
w32 clusterPart2HW(w32 pclustercodes,Tpartition *part,w32 *hclustcodes){
 w32 pclust;
 int i,j;
 *hclustcodes=0;
 if(DBGaf2HW) printf("  pclustercodes:%x\n", pclustercodes);
 for(i=0;i<NCLUST;i++){
   // find clusters in pclustcode             
   if((pclustercodes) & (1<<i))pclust=i+1;  //pclust cannot be 0
   else continue;
   if(DBGaf2HW) printf("  clusterPart2HW:part:%s pclust=%i\n",
       part->name, pclust);
   // Convert pcluster name ->> hw cluster
   j=findHWCluster(part, pclust);
   if(j==0) {
     if(part->hwallocated&0x1) {
        char emsg[ERRMSGL];
        sprintf(emsg, "hw cluster not found for part-cluster %d of 'old' partition %s", pclust, part->name);
       intError(emsg);
     };
     j=findfreeHWCluster();
   } else {
   };
   if(j==0) {
     prtError("free cluster not found"); 
     return(1);
   };
   j--;   // now: j is hwcluster -1
   /* ----?
   j=0;                              
   while((pclust != part->ClusterTable[j]) && (j<NCLUST))j++;
   if(j>=NCLUST){
    if(DBGaf2HW) printf("clusterPart2HW: incompatible clusters in TKlas and clusters(FO).\
j:%d .But this was already checked in readDatabaseTpartition , so some bug.\n",j);
    return 1;
   }
   */
   *hclustcodes=*hclustcodes+(1<<j); 
   // allocate j+1 hwcluster for partition part with pclust:
   part->ClusterTable[j]= pclust;
 }; return 0;
}
/*-----------------------------------------------------addFO2HW()
 Purpose: add FO words to HW
 Globals: input AllPartitions[]
          output HW
 Operation:
 - for part in AllPartitions:
     for det in 'Detectors in part':
       set HW.fo[ifo] (according to det)
       set HW.busy if valid BUSY input (found in validLTUs table) 
     set part->hwallocated[0x1] -clusters for this part allocated in HW

 Returns: error code =0 if ok

     //THIS GOS to addFO2hw: new part, so we are creating ClusterTable:
     part->ClusterTable[icluster]=pcluster;
      icluster=hwcluster;   
      hwcluster++;         //todo: here we should find free hw cluster!
*/
int addFO2HW(Tpartition *parray[]){
int ip,idet,ifo,iconnector;
w32 pclustercodes,hclustercodes;
Tpartition *part;
for(ip=0;ip<MNPART;ip++){         // loop over partitions
 if(parray[ip] == NULL) continue;
 part=parray[ip];
 if(DBGaf2HW) printf("addFO2HW: part:%s\n",part->name);
 for(idet=0;idet<NDETEC;idet++){    //loop over detectors in partition
   int bsyinp, ihwclu;
   if((pclustercodes = part->Detector2Clust[idet])==0) continue;
   // partition cluster name ->> hardware cluster code 
   // (and allocate this hw cluster if necessary):
   if(clusterPart2HW(pclustercodes,part,&hclustercodes)) return 1;
   if(DBGaf2HW) 
     printf("  addFO2HW: idet:%d pcc=0x%x hcc=0x%x\n",
       idet,pclustercodes,hclustercodes);
   if(Detector2Connector(idet,&ifo,&iconnector)) return 1;
   if((part->MaskedDetectors & (1<<idet))==0) {
     /* we should never get here (detector removed already in applyMask): */
     char emsg[ERRMSGL];
     sprintf(emsg,"addFO2HW: det:%d masked(excluded), why checked? \n",idet);
     intError(emsg);
     continue;
   }; 
   for(ihwclu=0; ihwclu<NCLUST; ihwclu++) {
     w32 hclustercode;
     hclustercode= 1<<ihwclu;
     if( hclustercode & hclustercodes) {
       HW.fo[ifo].cluster= HW.fo[ifo].cluster | (hclustercode<<(8*iconnector));
       // set HW.busy for connected detectors:
       if((bsyinp=validLTUs[idet].busyinp)) {  //BUSY line connected too:
         HW.busy.set_cluster[ihwclu+1]=    // 0: test 1..6 hw clusts
           HW.busy.set_cluster[ihwclu+1] | (1<<(bsyinp-1));
         if(DBGbusy) printf(
           "addFO2HW: det:%d bsyinp:%d cluster:0x%x/%d set_cluster:0x%x\n", 
           idet, bsyinp, hclustercode,ihwclu+1, 
           HW.busy.set_cluster[ihwclu+1]);
       };
       if(DBGaf2HW) {
         printf("  addFO2HW: det: %i fo/foc:%d/%d hclustcode=0x%x \n",
           idet,ifo,iconnector,hclustercode);
       };
     };
   };
 };
 if(DBGaf2HW) printf("  addFO2HW: hwallocated:%x\n",
     part->hwallocated);
 if(part->hwallocated==0) {
   part->hwallocated= 0x1;
   if(DBGaf2HW)printf("  new part:-bit 'clusters allocated' set to 0x1\n");
 } else if(part->hwallocated==0x3) {;
   if(DBGaf2HW)printf("  old part:-bit 'clusters allocated' was already set\n");
 } else {
   intError("hwallocated !=0,3");
 };
}
return 0;
}
/*-----------------------------------------------------addClasses2HW()
  Purpose: add classes to HW
  Parameters: none
  Globals: input AllPartitions[]: there are 2 types of partitions:
           - new (not assigned hw)
           - partitions, which already have assigned clusters/classes
           output HW
  Returns : error code : 0=ok
  Operation:
  Comment: assignment of partition cluster to hw cluster is arbitrary
           I assume: partition cluster names are numbers 1..6 as in
           part->l0veto word. Partition does not know to which cluster
           in HW it goes if loaded 1st time.
           Loaded partition keeps its classes/clusters when another
           partition is loaded (i.e. the same hw is used for partition,
           from Start to End of run.
           Asignment to hardware clusters is from 1 as the partition
           clusters of new partitions are coming.
           The partition delete (stop the run) releases its clusters,
           so they can be used for another partition.
           Table is stored in part->ClusterTable[]        
*/  
int addClasses2HW(Tpartition *parray[]){
 int i,ip,pclass,hwclass;
 Tpartition *part;
 TKlas *klas;
 // merge classes from partitions *parray[]
if(DBGac2HW) {printf("addClasses2HW: ALl partititons:\n"); printAllTp(); };
 // First loop over 'old' partitions (to keep the same hw for running partitions):
 for(ip=0;ip<MNPART;ip++){           //loop over old partitions
   if(parray[ip] == NULL) continue;
   part=parray[ip]; if((part->hwallocated&0x2)==0) continue;
   if(DBGac2HW) printf("  old Partition %i hwallocated:%x \n",
       ip,part->hwallocated);
   pclass=0;                         // loop over classes in partition
   for(pclass=0; pclass<NCLASS; pclass++) {
     if((klas=part->klas[pclass]) == NULL) continue;
     if(DBGac2HW) printf(" hwallocated. pclass: %i \n",pclass);
     hwclass= part->klas[pclass]->hwclass;  // 0..49
     if(hwclass>49) intError("addClasses2HW: hwclass>49");
     /* If partition cluster (pcluster) is different 
     from hw cluster correct it in HW.klas[]->l0vetos and 
     l1/2defininition words: */
     //pcluster = (klas->l0vetos) & 0x7;   //partition cluster name
     //icluster= findHWCluster(part, pcluster);
     copymodTKlas(HW.klas[hwclass],klas, part);
     HW.klas[hwclass]->hwclass = 1;      
   };
   if(DBGac2HW) printf("  addClasses2HW: hwallocated not changed, it is:%x\n",
     part->hwallocated);
 };
 // Now loop over 'new' partitions (to allocate the rest of resources)
 for(ip=0;ip<MNPART;ip++){           //loop over new partitions
   if(parray[ip] == NULL) continue;
   part=parray[ip]; if((part->hwallocated&0x2)==0x2) continue;
   if(DBGac2HW) printf("  new Partition: %i \n",ip);
   // loop over classes in partition
   for(pclass=0; pclass<NCLASS; pclass++) {
     w32 l0inv, l1inv, l2inv; int startn;
     if((klas=part->klas[pclass]) == NULL) continue;
     l0inv= part->klas[pclass]->l0inverted;
     l1inv= part->klas[pclass]->l1inverted;
     l2inv= part->klas[pclass]->l2definition & 0xfff000;
     if( (l0inv != 0) || (l1inv !=0) || (l2inv !=0) ) { startn= 44;
     } else { startn=0; };
     for(hwclass=startn; hwclass<NCLASS; hwclass++) {
       //printf("loop hw=%i p=%i %i\n",hwclass,pclass,HW.klas[hwclass]->hwclass);
       if(HW.klas[hwclass]->hwclass==0) goto OKHWCL1;   // free hw found
     };
     intError("addClasses2HW: free class not found (should not happen here)");
     OKHWCL1:
     part->klas[pclass]->hwclass= hwclass;  // remember which is used by pclass
     if(DBGac2HW)printf("  addClasses2HW: hwclass set (reserved)for log.class %d\n", hwclass);
     copymodTKlas(HW.klas[hwclass],klas, part);
     HW.klas[hwclass]->hwclass = 1;         // reserve it and
     //printTKlas(HW.klas[hwclass],hwclass);
   };
   if(DBGac2HW) printf("  addClasses2HW: hwallocated before set to 0x3:%x\n",
     part->hwallocated);
   part->hwallocated= 0x3;
   printHardware(&HW);
   if(DBGac2HW) {
     printf("  addCLasses2HW: ClusterTable for new part:%d:", ip);
     for(i=0;i<NCLUST;i++)printf("0x%x ",part->ClusterTable[i]);
     printf("\n"); 
   };
 }; // over all new partitions
 return 0;
}
/*----------------------------------------------------addPartiitons2HW()
  Purpose: ro unite (merge,join) parray[] to HW structure
  Patameters: none
  Globals: input: parray[]
           output: HW
  Returns: 0 if ok; 
           1 if error
  Comment: ClusterTable has to be cleared on every call
*/
int addPartitions2HW(Tpartition *parray[]){
 cleanHardware(&HW);
 if(addRBIF2HW(parray)) return 1;
 if(addFO2HW(parray)) return 1; // must be before addClasses2HW (to alloc clusters)
 if(addClasses2HW(parray)) return 1;
 // addBUSY -not necessary -done in addFO2HW   dont forget mask -is considered in addFO2HW
 // addPastFut
 /* 2 phases: clusters (in addFO2HW) and classes (in addClasses2HW)
 for(ip=0;ip<MNPART;ip++){           //mark 'hw allocated'
   if(parray[ip] == NULL) continue;
   parray[ip]->hwallocated=1;
 };*/
 return 0;
}
/*------------------------------------------- addStartedPartitions2HW(){
*/
int addStartedPartitions2HW(){
 cleanHardware(&HW);
 if(addRBIF2HW(StartedPartitions)) return 1;
 if(addFO2HW(StartedPartitions)) return 1; // must be before addClasses2HW (to alloc clusters)
 if(addClasses2HW(StartedPartitions)) return 1;
 return 0;
}
//-----------------------------------------------------------
//  Partitions Manipulations
//-----------------------------------------------------------
/*---------------------------------------------------getPartitions()
 Purpose: get pointer to partition with name in AllPartitions{}
 Parameters: input name - partition name
             parray:   AllPartitions or StartedPartitions
 Returns: pointer to partition with name
*/
Tpartition *getPartitions(char *name, Tpartition *parray[]){
 int i;
 Tpartition *part;
 if(name == NULL){
  printf("getPartitions error: name=NULL \n");
  return NULL;
 }
 for(i=0;i<MNPART;i++){
  if((part=parray[i])){
   if(strcmp(part->name,name) == 0) return part;
  }
 }
 return NULL;
}
/*------------------------------------------------deletePartitions()
  Purpose: remove partition from both lists: AllPartitions[] StartedPartitions[]
  part: input partition to be deleted
  Returns:
  1: deleted from AllPartitions[]
  3: deleted from both
  0: ERROR: partition is not present in any of 2 lists
  2: ERROR: partition deleted from StartedPartitions list only
  4: ERROR: part==NULL
*/
int deletePartitions(Tpartition *part) {
int i, rc=0; char pname[40];
if(part==NULL){
 intError("deletePartitions error: partition=NULL"); return 4;
};
strcpy(pname, part->name);
i=0; while((part != AllPartitions[i]) && (i<MNPART))i++;
if(i>=MNPART) {rc= 0;  // not in All
} else { // IN all
  if((part->positionInAllPartitions!=-1) &&   // never started
    (part->positionInAllPartitions!=i)) {
    char msg[300];
    sprintf(msg, 
      "deletePartitions:%s positionInAllPartitions:%d but it is at:%d .",
      pname, part->positionInAllPartitions, i); 
    intError(msg);
  };
  AllPartitions[i]=deleteTpartition(part);
  rc=1;
};
i=0; while((part != StartedPartitions[i]) && (i<MNPART))i++;
if(i>=MNPART) { // not in Started
  rc= rc;  //deleted only from All (1) or not found in any (0)
} else { 
  if(rc==1) {   // IN started
    StartedPartitions[i]=NULL;   // freed already in All
    rc=3;
  } else {  // found only in Started
    char msg[200];
    sprintf(msg, 
      "deletePartitions error. Partition %s only in StartedPartitions.",pname); 
    intError(msg);
    StartedPartitions[i]=deleteTpartition(part);
    rc=2;
  };
};
if((rc==0) || (rc==2)) {
  char msg[200];
  sprintf(msg, "deletePartitions error %d for partition %s", rc,pname); 
  intError(msg);
};
return rc;
}
/*------------------------------------------------ctp_StopAllPartitions()
used in case: CTRL C
*/
void ctp_StopAllPartitions() {
int i; Tpartition *part; char pname[40];
for(i=0;i<MNPART;i++){
  if((part=AllPartitions[i])){
   int rc1;
   char msg[200];
   strcpy(pname, part->name);
   infolog_SetStream(pname, part->run_number);
   sprintf(msg, "Stop forced for partition %s", pname); 
   infolog_trgboth(LOG_FATAL, msg);
   rc1= ctp_StopPartition(pname);
   //rc1= deletePartitions(Tpartition *part);
  };
};
infolog_SetStream("",0);
return;
}
/*----------------------------------------------------------addPartitions()
 Purpose: add partition to AllPartitions[]
 Parameters: input part
 Globals: AllPartitions[]
 Returns: error code: 0=ok
*/
int addPartitions(Tpartition *part){
 int i;
 for(i=0;i<MNPART;i++){
   if(AllPartitions[i] == NULL){
    AllPartitions[i] = part;
    part->positionInAllPartitions=i;
    return 0;
   }
  }
  printf("addPArtitions sw error: all AllPartitions[] != NULL ?\n");
  return 1; 
}
int addStartedPartitions(Tpartition *part) {
 int i;
 for(i=0;i<MNPART;i++){
   if(AllPartitions[i] == part){
      goto OK;
   };
 };
 intError("addStartPartitions: partition not found in AllPartitions.");
 return(1);
 OK:
 // check if already started: done before calling addStartedPartitions()
 for(i=0;i<MNPART;i++){
   if(StartedPartitions[i] == NULL){
    StartedPartitions[i] = part;
    return 0;
   }
  }
  intError("CheckResources sw error: all StartedPartitions[] != NULL ?");
  return 1; 
}

//--------------------------------------------------------------------------
//  Hardware operations
//--------------------------------------------------------------------------- 
// following structure should be probably part of global HW structure
// called like: hwcontrol (i.e. used for CTP control (not partition config))
struct {
  w32 activebusys; // valid (i.e. in BUSY_DAQBUSY) outside of 'GLOBAL BUSY'
  int global;      // 1: global busy ON. activebusys keeps info about
                   // active busys), BUSY_DAQBUSY is set to 0x3f
                   // 0: global busy OFF. activebusys is copy of BUSY_DAQBUSY
} DAQBUSY={0,0};   // Initialised in ctp_Initproxy

//--------------------------------------------------------setALLDAQBusy()
void setALLDAQBusy(){
 if(DAQBUSY.global==1) {
   intError("setALLDAQBusy: setALLDAQBusy called 2 times. No acion taken");
 } else {
   DAQBUSY.activebusys=vmer32(BUSY_DAQBUSY)&0x3f;
   vmew32(BUSY_DAQBUSY,0x3f); usleep(100);  //the must (L2 pipeline flush)
   DAQBUSY.global=1;
   if(DBGbusy) printf("setALLDAQBusy: old BUSY_DAQBUSY:0x%x \n",DAQBUSY.activebusys);
 };
}
//--------------------------------------------------------unsetALLDAQBusy()
void unsetALLDAQBusy(){
 if(DAQBUSY.global!=1) {
   intError("unsetALLDAQBusy: setALLDAQBusy was not called before. No action taken");
 } else {
   vmew32(BUSY_DAQBUSY,DAQBUSY.activebusys);
   DAQBUSY.global=0;
   if(DBGbusy) printf("unsetALLDAQBusy: old BUSY_DAQBUSY:0x%x \n",DAQBUSY.activebusys);
 };
}
//--------------------------------------------------------setPartDAQBusy()
// Set partition daq busy after alldaq busy
int setPartDAQBusy(Tpartition *part) {
w32 newbusy, clustbusy;
clustbusy=getBusyMaskPartition(part);
 if(DAQBUSY.global==1) {
   intError("setPartDAQBusy: called when GLOBAL busy ON. No acion taken");
 } else {
   newbusy=clustbusy+DAQBUSY.activebusys;
   vmew32(BUSY_DAQBUSY,newbusy);
   DAQBUSY.activebusys=newbusy;
   if(DBGbusy) printf("setPartDAQBusy: BUSY_DAQBUSY=0x%x \n",newbusy); 
 };
 return 0;
}
//-------------------------------------------------------------unsetPartDAQBusy()
int unsetPartDAQBusy(Tpartition *part){
w32 clust;
clust=getBusyMaskPartition(part);
 if(DAQBUSY.global==1) {
   if(part-> remseconds != -1) {
     intError("unsetPartDAQBusy: called when GLOBAL busy ON. No acion taken");
   };
   if(DBGmask)printf("unsetPartDAQBusy: called when GLOBAL busy ON.\n\
 Daqbusy.activebusys changed only\n");
   DAQBUSY.activebusys= DAQBUSY.activebusys & (~clust); 
 } else {
   clust = DAQBUSY.activebusys & (~clust); 
   vmew32(BUSY_DAQBUSY,clust);
   DAQBUSY.activebusys= clust;
   if(DBGbusy) printf("unsetPartDAQBusy BUSY_DAQBUSY=0x%x \n",clust); 
 };
 return 0;
}
/*---------------------------------------------------- ctp_Disablernd1
Disable RND1 geerator for short time - >to enable BC triggers
*/
void ctp_Disablernd1(int usecs) {
//w32 l2anow,l2abefore,dif;
setALLDAQBusy();
//l2abefore= readCTPcnts();
vmew32(RANDOM_1, 0xffffffff);
unsetALLDAQBusy();
usleep(usecs);
setALLDAQBusy(); 
vmew32(RANDOM_1, 0);
//l2anow= readCTPcnts();
unsetALLDAQBusy();
}
/*------------------------------------------------ readLTUcntsInCraDIM()
read LTU counters if they ar in the same crate (to be thrown away
as soon as we have DIM server for that).
*/
void readLTUcntsInCraDIM(int idet, w32 *mem) {
int cix, vsp;
    //ltuc= vmxr32(validLTUs[idet].ltuvsp, L0_COUNTER+4*ix);
if((validLTUs[idet].ltubasea[0]!='\0') && 
   (strncmp(validLTUs[idet].ltubasea,"0x",2)==0)) {   // LTU in CTP crate
  vsp= validLTUs[idet].ltuvsp;
  vmxw32(vsp, COPYCOUNT,DUMMYVAL);
  usleep(8); // allow 8 micsecs for copying counters to VME accessible memory
  vmxw32(vsp, COPYCLEARADD,DUMMYVAL);
  for(cix=0; cix<LTUNCOUNTERS; cix++) {
    mem[cix]= vmxr32(vsp, COPYREAD);
  };
} else {   //LTUDIM
  char emsg[ERRMSGL];
  sprintf(emsg,"LTUDIM counters not supported yet\n");
  intError(emsg);
};
return;
}

/*------------------------------------------------ readLTUcnts()
xse: 'S' -just store in validLTUs
     'E' -read/subtract the value in validLTUs[], store in validLTUs[]
*/
void readLTUcnts(Tpartition *partit, char xse) {
int idet;
// Find out active partition detectors
for(idet=0;idet<NDETEC;idet++){
  int rc=1, ix; w32 ltucnts[LTUNCOUNTERS]; 
  if(partit->Detector2Clust[idet] ==0) continue;
  //printf("readLTUcnts: %d ltubase:%s:\n", idet, validLTUs[idet].ltubasea);
  if(validLTUs[idet].ltuvsp==-1) continue;  // don't try any more
  if(validLTUs[idet].ltuvsp==-2) {   // open it
    validLTUs[idet].ltuvsp=-1;
    if(validLTUs[idet].ltubasea[0]=='\0') {
      return; // LTU not present
    } else if(strncmp(validLTUs[idet].ltubasea,"0x",2)!=0) {
      return; // not support yet to get LTU cnts over DIM
      //rc= dic_open(validLTUs[idet].ltubasea);
      //rc=0;
    } else {
      rc= vmxopen(&validLTUs[idet].ltuvsp, validLTUs[idet].ltubasea, "0x800");
    };
    if(rc!=0) {
      validLTUs[idet].ltuvsp= -1; //don't try to open more
      return;
    } else {
      printf("readLTUcnts: LTU %s vsp %d opened\n",
        validLTUs[idet].name, validLTUs[idet].ltuvsp);
    };
  };
  //readLTUcntsInCrate(validLTUs[idet].ltuvsp, ltucnts);
  readLTUcntsInCraDIM(idet, ltucnts);
  for(ix=16; ix<16+5; ix++) {  // cnts: L0 L1 L1s L2a
    w32 ltuc;
    //ltuc= vmxr32(validLTUs[idet].ltuvsp, L0_COUNTER+4*ix);
    ltuc= ltucnts[ix];
    //printf(" %d", ltuc);
    if(ix==3) {   // L2a
      if(xse=='S') validLTUs[idet].ltul2asod= ltuc;
      else {
        validLTUs[idet].ltul2a= dodif32(validLTUs[idet].ltul2asod, ltuc);
      };
    };
  };
};
}
/*--------------------------------------------------- readCTPcnts()
xse: 'S' -just store in validLTUs
     'E' -read/subtract the value in validLTUs[], store in validLTUs[]
*/
#define newreadCTPcnts
void readCTPcnts(Tpartition *part, char xse) {
int idet,reladr;
#ifdef newreadCTPcnts
w32 mem[CSTART_SPEC];
readCounters(mem, CSTART_SPEC, 0);
for(idet=0;idet<NDETEC;idet++){
  if(part->Detector2Clust[idet] ==0) continue;
  reladr= CSTART_FO + NCOUNTERS_FO*(validLTUs[idet].fo-1) +
    validLTUs[idet].foc -1; 
  if(xse=='S') {
    validLTUs[idet].ctpl0outsod= mem[SODEODfol0out1+reladr];
    validLTUs[idet].ctpl1outsod= mem[SODEODfol1out1+reladr];
    validLTUs[idet].ctpl2strosod= mem[SODEODfol2stro1+reladr];
  };
  if(xse=='E') {
    validLTUs[idet].ctpl0out= dodif32(validLTUs[idet].ctpl0outsod, 
      mem[SODEODfol0out1+reladr]);
    validLTUs[idet].ctpl1out= dodif32(validLTUs[idet].ctpl1outsod, 
      mem[SODEODfol1out1+reladr]);
    validLTUs[idet].ctpl2stro= dodif32(validLTUs[idet].ctpl2strosod, 
      mem[SODEODfol2stro1+reladr]);
  };
};
#else
int bb,cix; w32 copyread;
int board;
w32 mem[NCOUNTERS_MAX];
//board=5; reladr=31;   // FO1, L2strobe on 2nd connector
reladr=30;
for(idet=0;idet<NDETEC;idet++){
  if(part->Detector2Clust[idet] ==0) continue;
  board= validLTUs[idet].fo -1 + 5;   // busy,L0 1 2 INT FO1...
  reladr= 30+ validLTUs[idet].foc -1; //L2strobe (last in the sequence)
  bb= BSP*ctpboards[board].dial;
  if(notInCrate(board) == 0){
    vmew32(bb+COPYCOUNT,DUMMYVAL); 
    usleep(8); // allow 8 micsecs for copying counters to VME accessible memory
    vmew32(bb+COPYCLEARADD,DUMMYVAL);  
    copyread= bb+COPYREAD; 
    for(cix=0; cix<=reladr; cix++)mem[cix]= vmer32(copyread);
  }else{
    for(cix=0; cix<=reladr; cix++)mem[cix]= 0;
  }
  if(xse=='S') {
    validLTUs[idet].ctpl2strosod= mem[reladr];
  };
  if(xse=='E') {
    validLTUs[idet].ctpl2stro= dodif32(validLTUs[idet].ctpl2strosod,
      mem[reladr]);
  };
};
#endif
return;
}
/*------------------------------------------------------ readALLcnts()
xse: 'S' -just store in validLTUs
     'E' -read/subtract the value in validLTUs[], store in validLTUs[]
     'P' -like 'E' but, print the counters in addition
*/
void readALLcnts(Tpartition *part, char xse) {
char xse2='0';
int idet;
if(xse=='P') {
  xse='E'; xse2='P';
};
readCTPcnts(part, xse);
readLTUcnts(part, xse);
if(xse2=='P') {
  char msg[3000], msgmism[200]="" ;
  //sprintf(msg, "detector         CTPL2a     LTUL2a\n");
  sprintf(msg, "detector           CTPL0      CTPL1     CTPL2a  run:%d\n",
    part->run_number);
  for(idet=0;idet<NDETEC;idet++){
    w32 cl0, cl1, cl2;
    if(part->Detector2Clust[idet] ==0) continue;
    cl0= validLTUs[idet].ctpl0out;
    cl1= validLTUs[idet].ctpl1out;
    cl2= validLTUs[idet].ctpl2stro;
    //sprintf(msg,"%s %12s %10d %10d\n", msg, validLTUs[idet].name, validLTUs[idet].ctpl2stro, validLTUs[idet].ltul2a);
    sprintf(msg,"%s %12s %10u %10u %10u \n", msg, validLTUs[idet].name, 
      cl0, cl1, cl2);
    if( (cl0 < cl1) || (cl1 > cl2) ) {
      sprintf(msgmism, "%s %s", msgmism, validLTUs[idet].name);
    };
  };
  infolog_trg(LOG_INFO, msg);
  if( msgmism[0]!='\0') {
    sprintf(msg, "L0/L1/L2 mismatch for %s", msgmism);
    infolog_trg(LOG_ERROR, msg);
  };
};
}
/*------------------------------------------------ generateXOD()
  Purpose: to generate SOD/EOD
  Parameters: input: part
                     x = 'S' for SOD
                       = 'E' for EOD
  Globals: VME
  Return: 0 if succes
          1 if fails
  Comment: 
    -set the ROC on all the FOs feeding detectors in partition
    -set the list of detectors for software trigger: L2_TCSET
    -send the software trigger
  Calls: GenSwtrg()
  Called by: ctp_StartPartition();
*/
int generateXOD(Tpartition *part,char x){
 int i,ifo, idet, iattempt, iconnector, ret=0;
 w32 xod,detectors=0;
w32 busyclusterT;
 w32 testclust[NFO],roc[NFO];   // 20112006 von
 if(part == NULL){
  intError("generateXOD error: part=NULL \n");
  return 1;
 }
 if(x == 'S') {xod=0xe;
  readALLcnts(part, 'S');
 } else if(x == 'E') xod =0xf;
 else{
  char emsg[ERRMSGL];
  sprintf(emsg,"genXOD error: wrong x: %c \n",x);
  intError(emsg);
  return 1;
 }
 /* Find out partition detectors, and program BUSY inputs:
    20112006: it is enough to set detectors variable which is
    than used to program BUSY board in GenSwtrg.
 */
 busyclusterT= 0;   // see too: findBUSYinputs(detectors);
 for(idet=0;idet<NDETEC;idet++){
   int busyinp;
   if((part->Detector2Clust[idet])==0) continue;  //no cluster associated
   detectors=detectors+(1<<idet);
   if((busyinp=validLTUs[idet].busyinp)) {  //BUSY line connected
     busyclusterT= busyclusterT | (1<<(busyinp-1));
   };
 };
 //20112006 von vmew32(BUSY_CLUSTER, busyclusterT);
 if(DBGbusy) {
   printf("genXOD: BUSY/SET_CLUSTER: 0x%x L2_TCSET:0x%x\n", 
     busyclusterT, detectors);
 };
 /* ROC on FO should be set (FO_TESTCLUSTER)
    20112006 von
 */
 for(i=0;i<NFO;i++){testclust[i]=0;roc[i]=0;}
 for(i=0;i<NDETEC;i++){
   if(part->Detector2Clust[i]){
     if(Detector2Connector(i,&ifo,&iconnector))return 1;
     testclust[ifo]=testclust[ifo] +(1<<(16+iconnector));
     roc[ifo]=roc[ifo]+(xod<<(4*iconnector));  
     if(DBGswtrg) printf(
       "genXOD:%c: ifo=%i icon=%i testcl=0x%x roc=0x%x dets:0x%x\n",
         x,ifo,iconnector,testclust[ifo],roc[ifo], detectors);
    }
 }
 for(ifo=0;ifo<NFO;ifo++){   // set all FOs always
   //if((notInCrate(ifo+FO1BOARD)==0)) {
     if(DBGswtrg) printf("genXOD:%c: FO:%d Waddr: 0x%x data: 0x%x\n",
       x,ifo,FO_TESTCLUSTER+BSP*(ifo+1),roc[ifo] | testclust[ifo]);
     //20112006 von vmew32(FO_TESTCLUSTER+BSP*ifo,roc[ifo] | testclust[ifo]);
   //}
 }
 //software trigger with default setings
#define MAX_XOD_ATTEMPTS 3
 iattempt=0;/*
 if(x=='E') {
   setomSSM(5,0x202);   //26 ms, FO L2 monitor mode
   startSSM1(5);
 };*/
 /* SYN: becasue we want to have it in the middle of the orbit to set
 correctly orbit counter on INT board (synchronisation with L2) 
 The waiting time for 'SOD/EOD success' should match the waiting
 time in STD_ALONE mode -see ltu_proxy/ltu_utils.c sodeod().   
 */
if(strcmp(&part->name[strlen(part->name)-2],"_U")!=0) {

#ifndef TEST   
 while((GenSwtrg(1,'s', xod, 1750, detectors) == 0) && (iattempt<MAX_XOD_ATTEMPTS)){
   iattempt++;
   usleep(100000);
 };
#else
  prtLog("generateXOD; TEST mode: no attempt to generate.");
#endif
 if(iattempt>=MAX_XOD_ATTEMPTS){
   w32 deadbusys;
   char emsg[ERRMSGL];
   char ltunames[200];
   sprintf(emsg,"      generate%cOD error: cannot generate sw trigger\n",x);
   prtError(emsg);
   deadbusys= findDeadBusys() & busyclusterT;
   findLTUNAMESby(deadbusys, ltunames);
   deadbusys= vmer32(INT_DISB_CTP_BUSY)&3;
   if(deadbusys !=0) { strcat(ltunames," CTP"); };
   sprintf(emsg, "%cOD cannot be sent becasue of dead detectors (run:%d):%s", 
     x, part->run_number, ltunames);
   infolog_trgboth(LOG_FATAL, emsg);
   ret=1;
 }else {
  printf("%cOD event ok at %d attempt.\n", x, iattempt);
  /*
  if(DBGswtrg) {
    for(ifo=0;ifo<NFO;ifo++){
      if((notInCrate(ifo+FO1BOARD)==0)) {
        w32 tcread;
        tcread= vmer32(FO_TESTCLUSTER+BSP*(ifo+1));
        printf("generateXOD:%c: FO:%d Raddr: 0x%x data: 0x%x\n",
          x,ifo,FO_TESTCLUSTER+BSP*(ifo+1),tcread);
      }
    }; 
  }; */
 };
} else {
  char emsg[ERRMSGL];
  sprintf(emsg, "%cOD generation suppressed (part. name: ..._U).\n", x);
  infolog_trgboth(LOG_INFO, emsg);
};
if(x == 'E') {
  readALLcnts(part, 'P');
};
 /* clean tc cluster word -no need (it is enough to set befor use)
 for(ifo=0;ifo<NFO;ifo++){
   if((notInCrate(ifo+FO1BOARD)==0)) 
     vmew32(FO_TESTCLUSTER+BSP*(ifo+1),0x0);
 }*/
 return ret;
}
/*-----------------------------------------------------------generateXODSSM()
 Purpose: Generates XOD from FO ssm in outgen mode.
          Trick to use exactly same sequence as in standalone mode
 Parameters: input: x='S' for SOD and x='E' for EOD
 Globals: reads ssm memory dumps from disk which contains SOD/EOD from ltu
 Returne: error code: 0=ok

int generateXODSSM(char x){
 int ret;
 stopSSM(5);
 if(x == 'S') ret=readSSMDump(5,"/home/alice/rl/v/vme/WORK/SSMsodDAQ.dump");
 else ret=readSSMDump(5,"/home/alice/rl/v/vme/WORK/SSMeodDAQ.dump");
 printf("Generating %cOD in FO mode\n",x);
 writeSSM(5);
 setomSSM(5,0x104);   //outgen 1 pass
 startSSM1(5);
 sleep(1);
 stopSSM(5);
 return ret;
}*/
/*----------------------------------------------------- xcounters */
#define TAGstartcount 333
#define TAGstopcount 334
#define TAGprintruns 335
#define TAGrcfgdo 336
#define TAGrcfgdelete 337
#define TAGctprestart 338
#define TAGpcfg 339

void callback(void *tag, int *retcode){
 char command[100]; char emsg[300];
 //printf("callback: %li %i \n",*tag,*retcode);
 switch(*(int *)tag){
   case(TAGstartcount):
        strcpy(command,"STARTRUNCOUNT");
        break;
   case(TAGstopcount):
        strcpy(command,"STOPRUNCOUNT");
        break;
   case(TAGrcfgdo):
        strcpy(command,"CTPRCFG/RCFG");
        break;
   case(TAGrcfgdelete):
        strcpy(command,"CTPRCFG/RCFG delete");
        break;
   case(TAGctprestart):
        strcpy(command,"CTPRCFG/RCFG delete(testifpydimON)");
        break;
   case(TAGpcfg):
        strcpy(command,"CTPRCFG/RCFG pcfg");
        break;
   default:
        printf("callback: Unknown tag %i \n",*(int *)tag);
        return;
 }
 if(*retcode){
   sprintf(emsg, "timestamp:callback:%s successful.",command); prtLog(emsg);
 } else {
   sprintf(emsg, "timestamp:callback:DIM command %s failed.",command); prtError(emsg);
 };
}
void xcountersStart(w32 run) {
 char com[100],msg[254];
 int size;
 //                       printf("xcountersStart removed\n"); return;
 sprintf(msg,"Run %i: starting xcounters.",run);
 prtLog(msg);
 strcpy(com,"CTPDIM/STARTRUNCOUNTER");
 size=sizeof(run);
 /* following action:
 - starts xcounters
 - moves .rcfg file to WORK/RCFG/delme/ directory
 That's why group owner of RCFG is fes on alidcscom026:
 drwxrwxr-x  4 trigger fes      4096 Mar  9 16:00 RCFG
 drwxrwxr-x  3 trigger fes   20480 Apr  2 08:20 delme
 */
 dic_cmnd_callback(com,&run, size,&callback,TAGstartcount);
}
void xcountersStop(w32 run) {
 char com[100],msg[100];
 int size;
 //                       printf("xcountersStop removed\n"); return;
 sprintf(msg,"Run %i: stopping xcounters.",run);
 strcpy(com,"CTPDIM/STOPRUNCOUNTER");
 prtLog(msg);
 size=sizeof(run);
 dic_cmnd_callback(com,&run, size,&callback,TAGstopcount);
 /* ??? Registration of the closed file should be 
 on DCS FES with offline tag CTP_xcounters. 
 See v/vme/dimcoff/dimccounters.c -the executable of this
 DIM client is placed in tri@alidcscom026 from where it is started.
 This client should invoke (after closing the xcounters file)
 dcsFES_putData.sh to register it on DCS FES */
}
/*
Input:
part
dodel: 1: prepare file 
0:delete file   called from:
  - _LoadPartition() -in case of error and if it was created
  - _StartPartition() -in case of error 
rc: 0: ok .rcfg prepared (confirmed from parted)
*/
int prepareRunConfig(Tpartition *part, int dodel) {
/* 17.12.2007: just copy
$VMECFDIR/CFG/ctp/pardefs/partname.pcfg ->
$VMEWORKDIR/RCFG/rRUNNUMBER.rcfg
*/
int rc=0, icla, tag; w32 ilog;
char namemode[80];
//char *environ; char runcfg[100];
char cmd[400];
char dimcom[40];
char msg[500];
if(part == NULL){
 intError("prepareRunConfig: part=NULL");
 rc=1;return(rc);
}
  if(part->hwallocated != 0x3) {
    char emsg[300];
    sprintf(emsg, "hwallocated:%x (0x2 expected) for part:%s", 
      part->hwallocated, part->name);
    intError(emsg);
    rc=1; return(rc);
  };
/*----------- test .rcfg file preparation
strcpy(cmd,"cp ");
environ= getenv("VMECFDIR"); strcat(cmd, environ);
strcat(cmd,"/CFG/ctp/pardefs/"); strcat(cmd,part->name); 
strcat(cmd,".pcfg ");
getruncfgname(part->run_number, runcfg);
strcat(cmd, runcfg);
rc=system(cmd);
printf("prepareRunConfig:%s rc:%d\n",cmd, rc);
*/
/* prepare line:
hw 1 2 3 4 5 6 c1 c2 ... c50
1..6 -hw clusters assigned to logical clusters 1..6
c1..c50  -hw classes assigned to log. classes 1..50
0: not assigned (may lead to error in parted when creating .rcfg file)
*/
if(part->partmode[0]!='\0') {
  strcpy(namemode, part->partmode);
} else {
  strcpy(namemode, part->name);
};
if(dodel==1) {
  w32 int1lookup,int1def,int2lookup,int2def;
  tag=TAGrcfgdo;
  //printTpartition("prepareRunConfig1", part);
  sprintf(cmd,"rcfg %s %d 0x%x", namemode, part->run_number,
    part->MaskedDetectors);
  for(ilog=0;ilog<NCLUST;ilog++){
    int hwclu, ihw;
    hwclu=0;
    for(ihw=0;ihw<NCLUST;ihw++){
      if(part->ClusterTable[ihw]==0) continue;
      if(part->ClusterTable[ihw]==(ilog+1)) {hwclu=ihw+1; break;};
    };
    printf("%i -> %i hwclu:%d",ilog,part->ClusterTable[ilog], hwclu);
    sprintf(cmd, "%s %d", cmd, hwclu);
  };
  for(icla=0;icla<NCLASS;icla++){
    TKlas *klas;
    klas=part->klas[icla];
    if(klas!=NULL) {
      printTKlas(klas,icla);
      sprintf(cmd,"%s %d", cmd, klas->hwclass+1);
    } else {
      sprintf(cmd,"%s 0", cmd);
    };
  };
  // int1lookup int1def int2lookup int2def
  //int2lookupdef bug
  int1lookup= vmer32(L0_INTERACT1);
  int2lookup= vmer32(L0_INTERACT2);
  int2def= vmer32(L0_INTERACTSEL);
  int1def= int2def & 0x1f; int2def= int2def >> 5;
  sprintf(cmd, "%s 0x%x 0x%x 0x%x 0x%x", cmd, int1lookup, int1def, int2lookup, int2def);
  strcat(cmd,"\n");
  //printf("prepareRunConfig:%s \n",cmd);
} else {
  tag=TAGrcfgdelete;
  sprintf(cmd,"rcfgdel %s %d\n", namemode, part->run_number);
};
sprintf(msg,"timestamp:prepareRunConfig1: %s", cmd); prtLog(msg);
strcpy(dimcom,"CTPRCFG/RCFG");
dic_cmnd_callback(dimcom, cmd, strlen(cmd)+1, &callback, tag);
return(rc);
}

/*------------------------------------------------ preparepcfg()
*/
void preparepcfg(char *partname, int runnumber) {
char cmd[400];
char dimcom[40];
char msg[500];

sprintf(cmd,"pcfg %s %d\n", partname, runnumber);
sprintf(msg,"timestamp:pcfg1: %s", cmd); prtLog(msg);
strcpy(dimcom,"CTPRCFG/RCFG");
dic_cmnd_callback(dimcom, cmd, strlen(cmd)+1, &callback, TAGpcfg);
return;
}

/*int registerRunConfig(w32 run) {
// Offline tag: CTP_runconfig

int rc=0;
//char cmd[400];
char runcfg[100];
getruncfgname(run, runcfg);
** see tri@alidcscom026:dcsFES_putData.sh 
Offline tag for .rcfg file: CTP_runconfig
dcsFES_putData.sh RUN# DET FILEID INPUTFILE_full_path
Example:
~tri/dcsFES_putData.sh 2 TRI CTP_runconfig $VMEWORKDIR/WORK/RCFG/r2.rcfg
Last idea:
dcsFES_putData.sh will not be called from here. dcsFES_putData.sh
should be modified (run number is known in this script, and
this is only parameter we need) to copy and delete .rcfg file
just before xcounters file at the time of xcountersStart() 
**
printf("registerRunConfig NOACTION: run:%d %s\n", run, runcfg);
return(rc);
}*/
//--------------------------------------------------------------------
// Routines for smi:
//--------------------------------------------------------------------
// Initialise
int ctp_Initproxy(){
int rc;
char msg[300], cmd[100], dimcom[40];
rc= vmeopen("0x820000", "0xd000");
if(rc!=0) {
  printf("vmeopen CTP vme:%d\n", rc); exit(8);
};
printf("ctp_proxy ver: 2.9.2009\n");
checkCTP();   /* check which boards are in the crate - ctpboards */
initCTP();    /* init system pars */
// readTables(); is in checkCTP()
if(initHW(&HWold)) return 1; // initialise and clean HWold structure
if(initHW(&HW)) return 1;   // initialise and clean HW structure
 // to do: read run database WORK/RCFG
 //DAQBUSY.activebusys=vmer32(BUSY_DAQBUSY)&0x3f;
 // but now:
 load2HW(&HW);
 /* initialise hardware ('not configurable' part i.e.: busy, TC_CLEAR):
 */
 DAQBUSY.global=0;  
 DAQBUSY.activebusys=0; vmew32(BUSY_DAQBUSY, DAQBUSY.activebusys);
 clearflags();
 printf("ctp_Initproxy: cleaning CTP hw (all classes \
disabled, all BUSYs cleaned, swtrg flags cleaned.\n");

/* check DIM server is running: */
sprintf(cmd,"rcfgdel testifpydimON\n");
sprintf(msg,"timestamp:TAGctprestart: %s", cmd); prtLog(msg);
strcpy(dimcom,"CTPRCFG/RCFG");
rc= dic_cmnd_callback(dimcom, cmd, strlen(cmd)+1, callback, TAGctprestart);
printf("rc from \"CTPRCFG/RCFG rcfgdel testifpydimON\":%d (1 is OK)\n", rc);
if(rc==1) rc=0;

#ifdef TEST
rc=0; printf("TEST mode, rc forced to 0\n");
#endif
return(rc);
}
int ctp_Endproxy() {
int rc=0, rc1=0,idet, vsp;
printf("ctp_Endproxy: Forcing all partitions to stop...\n");
ctp_StopAllPartitions();
printf("ctp_Endproxy: closing VME...\n");
for(idet=0;idet<NDETEC;idet++){
  if((vsp= validLTUs[idet].ltuvsp)>0) {
    rc1= vmxclose(vsp);
    printf("vmxclose LTU %s vme:%d\n", validLTUs[idet].name, rc);
  };
}
rc=vmeclose();
if(rc!=0) {
  printf("vmeclose CTP vme:%d\n", rc);
};
return(rc+rc1);
}
/*---------------------------------------------ctp_PausePartition()
 * Standard Pause
*/
int ctp_PausePartition(char *name){
 Tpartition *part;
 infolog_SetStream(name,-1);
 part=getPartitions(name, StartedPartitions);   //only Started can be paused
 if(part == NULL) return 1;
 infolog_SetStream(name, part->run_number);
 setPartDAQBusy(part);
 if(part->nclassgroups  > 0 ) {
   part->remseconds= stopTimer(part);
 };
 usleep(200); readALLcnts(part, 'P');
 //printf("\n ctp_PausePartition: SUCCES \n");
 infolog_SetStream("", 0);
 return 0;
}
/*----------------------------------------------------------------
 Pause when in FO outgen mode
int ctp_PausePartition(char *name,char *mask){
 setALLDAQBusy();
 stopSSM(5);
 return 0;
}
*/
/*---------------------------------------------ctp_ResumePartition()
 * Standard resume
*/
int ctp_ResumePartition(char *name){
 Tpartition *part;
 infolog_SetStream(name, -1);
 part=getPartitions(name, StartedPartitions);
 if(part == NULL) return 1;
 infolog_SetStream(name, part->run_number);
 if(part->nclassgroups  > 0 ) {
   startTimer(part, part->remseconds); part->remseconds=-1;
 };
 unsetPartDAQBusy(part); 
 //printf("\n ctp_ResumePartition: SUCCES \n");
 infolog_SetStream("", 0);
 return 0;
}
/*------------------------------------------------ctp_StopPartition()
Stop the trigger.
Operation:
Loaded partition: only remove from AllPArtitions
Started: remove from All/Started Partitions and reload HW

rc: 0: OK, EOD generated, partition unloded
    2: problem when  unloading from HW
*/
int ctp_StopPartition(char *name){
 int ret, rc=0;
 w32 run_number;
 Tpartition *part;
 char emsg[ERRMSGL]="";
 infolog_SetStream(name,0);
 part=getPartitions(name, StartedPartitions); 
 if(part == NULL) { // only loaded (not in HW)
   part=getPartitions(name, AllPartitions); 
   if(part == NULL) { rc= 1; 
     sprintf(emsg,"Attempt to stop partition %s -not loaded before",name);
     goto RETSTOP_badsyntax; //nothing to do,partition never existed
   } else {
     infolog_SetStream(name, part->run_number);
     prepareRunConfig(part,0);
   };
   ret= deletePartitions(part);
   if(ret != 1){
     sprintf(emsg,"deletePartition %s inconsitent: %d",name,ret);
     goto RETSTOP_badsyntax; //nothing to do,partition never existed
   }
   // normally, .rcfg file is deleted by starting xcountersStart in
   // ctp_StartPartition. We should delete it here, because we did not
   // come to the point where partition is started
   goto RET;
 } else {
   infolog_SetStream(name, part->run_number);
 };
 // started partition: delete in All/Started + reload HW
 run_number= part->run_number;
 setALLDAQBusy();
 if(part->nclassgroups  > 0 ) {
   ret= stopTimer(part);
 };
 usleep(2000);  /* to keep trigger rate <1kHz for DDG*/
 usleep(100);   /* to be sure CTP is quiet when reading counters at the EOR */
 xcountersStop(run_number);
 unsetPartDAQBusy(part);    // in case it was 'paused'
 if(generateXOD(part,'E' )) {
   sprintf(emsg,"EOD failure for partition %s.",name); 
   printf("%s\n",emsg); emsg[0]='\0';
   //goto RETSTOPunset;  anyhow, we have to relese hw
 };
 prepareRunConfig(part,0);
 ret=deletePartitions(part);
 if(ret!=3) {   // was not in both list
   rc=1;
   sprintf(emsg,"ERROR. rc:%d from deletePartitions(%s)",ret, name);
 };
 if((ret=addPartitions2HW(StartedPartitions))){ rc=ret;  // to check !!
   sprintf(emsg, 
   "addPartition error when stopping partition %s.", 
   name);
 } else {
   if(load2HW(&HW)) {rc=2;
     sprintf(emsg,"load2HW failure for partition %s.",name);
   };
 };
 //registerRunConfig(run_number);
//RETSTOPunset:
 unsetALLDAQBusy();
 //printf("\n ctp_StopPartition: SUCCES \n");
RETSTOP_badsyntax:
if(emsg[0]!='\0') printf("%s\n",emsg);
RET:
if(quit==1) {
  if(getNAllPartitions()==0) {
    sprintf(emsg,"ctp_proxy stopping (no active partitions)");
    quit=10;
  } else {
    sprintf(emsg,"ctp_proxy still waiting before exit (there are still active partitions)");
  };
  infolog_trgboth(LOG_INFO, emsg);
}
infolog_SetStream("",0);
return rc;
}
/*---------------------------------------------ctp_LoadPartition()
 Operation: 
 0. copy existing HW to hwold
 1. read database, check resources
 2. if OK then: add it to Partitions and create new hw file
    else go to 7.
 3. pause ALL clusters
 4. generate SOD
 5. load HW
 6. resume all clusters
    end
 7. copy hwold to HW
    end
 Return : error flag= 0 ok
                      1 not enough resources
                      2 any other error
 Input: partition name, mask
 mask: decimal or hex (0x..) number, 24 bits
       1: for valid detectors, 0: not valid
       "" (empty string): do not apply mask
 Notes about mask:
 - the mask bits corresponds to detector table given in VALID.LTUS
 - masking is done by programming FO and BUSY board:
   - 0 -> corresponding FO 8-bit word
   - BUSY input is ignored from this detector
   STATIC option(current): masking allowed only at the time of partition start.
   DYNAMIC option (not foreseen from DAQ point of view): 
   Only if DAQ is capable to mask detectors during run. 
   It sems, CTP is capable to do it (i.e. another
   commands for paused (perhaps even running) partitions: 
   APPLY_MASK (and possibly UNMASK) should be prepared
   In this case, masked detectors should keep resources all the time,
   regardless wheter they are masked or not.

rc: 
1 : cannot create .pcfg file
2: pcfg cannot be processed
3: applyMask problem 
4: addPartitions() problem
*/
int ctp_LoadPartition(char *name,char *mask, int run_number) {
int ret=0, rc=0;
char name2[80];
char msg[300];
Tpartition *part;
/* 
way of masking: mask is applied in memory directly
    after part. definition is read in
 */
infolog_SetStream(name,0);
part=getPartitions(name, AllPartitions); 
if(part!=NULL) { 
  sprintf(msg, "Attempt to load %s, which is already loaded or started",name);
  infolog_trgboth(LOG_ERROR, msg); rc=5; goto RET2;
};
infolog_SetStream(name, run_number);
//------------------------------------------- prepare fresh .pcfg file:
if( partmode[0] == '\0'){strcpy(name2, name);}else{ strcpy(name2, partmode); };
sprintf(msg,"rm -f /tmp/%s.pcfg", name2); ret=system(msg);
preparepcfg(name2, run_number);
sprintf(msg, "/tmp/%s.pcfg", name2);
ret= detectfile(msg, 9);  // wait max. 9 secs for file
sprintf(msg,"timestamp:pcfg2: moving /tmp/%s -> %s...", name2, name); prtLog(msg);
if(ret<=0) {
  sprintf(msg, "Wrong partition definition (cannot create .pcfg file)");
  infolog_trgboth(LOG_ERROR, msg); rc=1; goto RET2;
};
if(partmode[0] != '\0') {
  sprintf(msg,"mv /tmp/%s.pcfg /tmp/%s.pcfg", name2, name);
  ret= system(msg); 
  if(ret!=0) {
    sprintf(msg, "cannot create .pcfg file (mv).Mode:%s ", partmode);
    infolog_trg(LOG_ERROR, msg); rc=1; goto RET2;
  };
};

copyHardware(&HWold,&HW);
sprintf(msg,"timestamp:reading partition %s %d", name, run_number); prtLog(msg);
part=readDatabase2Tpartition(name); 
if(part == NULL) {  rc=2;goto RET2; };
part->run_number= run_number;
 // convention mask="" - mask is not used: applymask creates mask
 //                      acoording to partition
 printTpartition("Before mask applied", part);
 if(applyMask(part, mask)) { rc=3; goto RET2; };
 if(DBGparts) {
     printTpartition("After mask applied", part);
 };
 sprintf(msg,"timestamp:mask applied %s %d", name, run_number); prtLog(msg);
 if((ret=checkResources(part))) {rc=ret; goto RET2; };
 // If resources available, continue and add part to Partitions[]
 // From now on, no checks necessary (all checks already done)
 if(addPartitions(part)) { rc=4;
   prtError("addPartitions eror."); 
   goto RET2; };
 if(DBGparts) {
   printf("Partitions after adding partition:%s\n",part->name);
   printTRBIF(HW.rbif);
   printAllTp();
 };
 sprintf(msg,"timestamp:partition merged: %s %d", name, run_number); prtLog(msg);
 if((ret=addPartitions2HW(AllPartitions))){ //just check if enough resources
   printf("addPartitions2HW error: %i \n", ret);   
   rc=ret; goto RETdelrcfg;
 };
 if(DBGparts) {
   printTpartition("After addPartitions2HW:", part);
 };
 sprintf(msg,"timestamp:partition inHW: %s %d", name, run_number); prtLog(msg);
 //we already know HW configuration (allocation of physics resources):
 prepareRunConfig(part,1); //has to be here (2 secs for pydimserver to prepare
                         // .rcfg file
 usleep(2000000);        // 1sec is not enough, 2 seems enough before SOD
 // libDAQlogbook (assignment of detectors to clusters):
 rc= updateDAQClusters(part);
 sprintf(msg, "timestamp:rc:%d from updateDAQClusters()\n", rc); prtLog(msg);
/*partition is 'loaded'
*/
RETdelrcfg:
if(rc!=0) {
 prepareRunConfig(part,0);
 ret=deletePartitions(part); 
} else {
  printHardware(&HW);
  // discard 'addPartitions2HW(AllPartitions)' actions:
  copyHardware(&HW,&HWold);  
};
RET2:
infolog_SetStream("",0);
sprintf(msg, "timestamp:ctp_LoadPartition finished %s %d", name, run_number);
prtLog(msg);
return rc;
}
/*---------------------------------------------ctp_StartPartition()
Return : 0 ok
         1 partition was not loaded before calling StartPartition()
         2 partition already started
         3 SOD not sent (busy detector(s)
         4 load HW problem
         5 CTP readout enabled, but DDL link not ready
*/
int ctp_StartPartition(char *name) {
int ret,rc=0, clgroup; w32 intddlemu;
Tpartition *part;
char emsg[ERRMSGL];
infolog_SetStream(name,0);
part=getPartitions(name, StartedPartitions); 
if(part!=NULL) { 
  rc=2; 
  sprintf(emsg, "Partition %s already started.", name);
  infolog_trgboth(LOG_FATAL, emsg);
  goto RET;
};
part=getPartitions(name, AllPartitions); 
if(part==NULL) { 
  rc=1; 
  sprintf(emsg, "Partition %s not loaded.", name);
  infolog_trgboth(LOG_FATAL, emsg);
  goto RET; };
infolog_SetStream(name, part->run_number);

copyHardware(&HWold,&HW);
addStartedPartitions(part);
addPartitions2HW(StartedPartitions);
 
/* todo: it is sufficient to call setALLDAQBusy just before load2HW()
   i.e. generateXOD() can be called 'on the fly'
*/
setALLDAQBusy(); 
clearflags();
intddlemu= vmer32(INT_DDL_EMU);
if((intddlemu&0xf)==0) {   //check DDL if DAQ is active
  if((intddlemu&0x70)!=0x30) {
    char msg[200];
    sprintf(msg,"Run %d: CTP DDL link full or in bad state before sending SOD.\n\
 INT_DDL_EMU:0x%x expected: 0x30",
      part->run_number, intddlemu);
    infolog_trgboth(LOG_FATAL, msg);
    //von prtLog(msg);
    rc= 5; goto UNSETRET;
  };  
};
usleep(200);   // be sure, CTP is quiet when reading counters at SOR
if(generateXOD(part,'S')) {
  // SOD was not delivered (busy)
  //infolog_trgboth(LOG_ERROR, "SOD not delivered (busy)");
  rc= 3; goto UNSETRET;
  /*if((ret=addPartitions2HW())){ 
    printf("addPartitions error: %i \n", ret);
    goto UNSETRET;}; */
};
//usleep(1100000);   // maybe more for rorc initialisation
if(load2HW(&HW)){
  rc= 4; goto UNSETRET;
}
xcountersStart(part->run_number);
usleep(2000000);   // at least 2secs for: DIM transmission + read counters
disableNEVERACTIVE(part);
clgroup= nextclassgroup(part);
if(clgroup > 0) {
  enableclassgroup(part, clgroup); startTimer(part, 0);
};
UNSETRETadb: 
unsetALLDAQBusy();
//printf("\n ctp_StartPartitions: SUCCESS \n");
RET:
infolog_SetStream("",0);
return rc;
UNSETRET:
  prepareRunConfig(part,0);
  ret= deletePartitions(part);
  copyHardware(&HW,&HWold);
  goto UNSETRETadb;
}


