self.baseAddr="0x820000"
self.spaceLength="0xd000"
self.vmeregs=[('CODE_ADD', '0x4', ''), ('SERIAL_NUMBER', '0x8', ''), ('VERSION_ADD', '0xc', ''), ('SOFT_RESET', '0x28', ''), ('TEMP_START', '0x58', ''), ('TEMP_STATUS', '0x5c', ''), ('TEMP_READ', '0x60', ''), ('FPGAVERSION_ADD', '0x80', ''), ('TEST_ADD', '0x7e0', ''), ('BC_STATUS', '0xc4', ''), ('SSMcommand', '0x19c', ''), ('SSMstart', '0x1a0', ''), ('SSMstop', '0x1a4', ''), ('SSMaddress', '0x1a8', ''), ('SSMdata', '0x1ac', ''), ('SSMstatus', '0x1b0', ''), ('SSMenable', '0x1b4', ''), ('PLLreset', '0x1bc', ''), ('ADC_START', '0xcc', ''), ('ADC_DATA', '0xd0', ''), ('SOFT_LED', '0x15c', ''), ('COPYCOUNT', '0x1d4', ''), ('COPYBUSY', '0x1d8', ''), ('COPYCLEARADD', '0x1dc', ''), ('COPYREAD', '0x1e0', ''), ('CLEARCOUNTER', '0x5ac', ''), ('SPY_MEMORY', '0x400', ''), ('SCOPE_SELECT', '0x4f8', ''), ('ADC_SELECT', '0x500', ''), ('SYNCH_ADD', '0x504', ''), ('PF_COMMON', '0x564', ''), ('PFBLOCK_A', '0x568', ''), ('PFBLOCK_B', '0x56c', ''), ('PFLUT', '0x570', ''), ('FO_CLUSTER', '0x240', ''), ('FO_TESTCLUSTER', '0x244', ''), ('FO_DELAY_L1CLST', '0x248', ''), ('FO_FILTER_L1', '0x84', ''), ('BUSY_DELAY_ADD', '0x84c8', ''), ('BUSY_ORBIT_SELECT', '0x80d4', ''), ('BUSY_DISB_CTP_BUSY', '0x80d8', ''), ('BUSYMAX_DATA', '0x8168', ''), ('BUSYMINI_DATA', '0x816c', ''), ('MINIMAX_SELECT', '0x8570', ''), ('MINIMAX_CLEAR', '0x8174', ''), ('MINIMAX_LIMIT', '0x8578', ''), ('BUSYLAST_SELECT', '0x857c', ''), ('BUSY_CLUSTER', '0x8600', ''), ('BUSY_DAQBUSY', '0x861c', ''), ('BUSY_L0L1DEADTIME', '0x8620', ''), ('BUSY_CTPDEADTIME', '0x8624', ''), ('BUSY_OVERLAP', '0x8640', ''), ('L0_CLEAR_RND', '0x90c8', ''), ('L0_TCSTATUS', '0x91c0', ''), ('L0_TCSTART', '0x91c4', ''), ('L0_TCCLEAR', '0x91c8', ''), ('RATE_DATA', '0x91cc', ''), ('RATE_CLEARADD', '0x91d0', ''), ('MASK_DATA', '0x91e4', ''), ('MASK_CLEARADD', '0x91e8', ''), ('L0_TCSET', '0x9400', ''), ('L0_CONDITION', '0x9400', ''), ('L0_VETO', '0x9600', ''), ('DAQ_LED', '0x9600', ''), ('L0_MASK', '0x9700', ''), ('L0_INVERT', '0x9500', ''), ('L0_INVERTac', '0x9800', ''), ('L0_INTERACT1', '0x94cc', ''), ('L0_INTERACT2', '0x94d0', ''), ('L0_INTERACTT', '0x94d4', ''), ('L0_INTERACTSEL', '0x94d8', ''), ('L0_FUNCTION1', '0x94dc', ''), ('L0_FUNCTION2', '0x94e0', ''), ('RANDOM_1', '0x94e4', ''), ('RANDOM_2', '0x94e8', ''), ('SCALED_1', '0x94ec', ''), ('SCALED_2', '0x94f0', ''), ('ALL_RARE_FLAG', '0x94f4', ''), ('L0_ENA_CRND', '0x94fc', ''), ('MASK_MODE', '0x95a4', ''), ('L0_BCOFFSET', '0x95a8', ''), ('RATE_MODE', '0x9700', ''), ('L0_FUNCTION34', '0x97ec', ''), ('L1_TCSTATUS', '0xa1c0', ''), ('L1_TCCLEAR', '0xa1c8', ''), ('L1_TCSET', '0xa400', ''), ('L1_DEFINITION', '0xa400', ''), ('L1_DELAY_L0', '0xa4cc', ''), ('L1_INVERT', '0xa500', ''), ('ROIP_BUSY', '0xa600', ''), ('L2_DEFINITION', '0xb400', ''), ('L2_ORBIT_READ', '0xb140', ''), ('L2_ORBIT_CLEAR', '0xb144', ''), ('L2_TCSTATUS', '0xb1c0', ''), ('L2_TCCLEAR', '0xb1c8', ''), ('L2_TCSET', '0xb400', ''), ('L2_DELAY_L1', '0xb4cc', ''), ('L2_BCOFFSET', '0xb5a8', ''), ('INT_ORBIT_READ', '0xc140', ''), ('INT_MAX_CLEAR', '0xc144', ''), ('INT_FIFO_MAX', '0xc148', ''), ('INT_DDL_EMU', '0xc14c', ''), ('INT_DISB_CTP_BUSY', '0xc150', ''), ('I2C_MUXWR', '0xc154', ''), ('I2C_MUXRD', '0xc158', ''), ('I2C_ADCWR', '0xc174', ''), ('I2C_ADCRD', '0xc160', ''), ('I2C_SET', '0xc164', ''), ('I2C_DATA', '0xc168', ''), ('INT_RC_BLCKMAX', '0xc16c', ''), ('INT_BLCKMAX_CLEAR', '0xc170', ''), ('INT_TCSET', '0xc400', ''), ('INT_TEST_COUNT', '0xc404', ''), ('INT_BCOFFSET', '0xc5a8', '')]
self.hiddenfuncs=" Common L012 DebCon DbgScopeCalls DbgSSMBROWSERcalls"
self.funcs=[[None, 'Browse CTP snapshot memories \n', 'GUI', 'SSMbrowser', [], 'SSMbrowser'], [None, 'The main window allowing \n- to edit inputs:\n    Delete,Modify,Add,Print\n- Check activity: count all 1 in snapshot memory\n- Synchronise chosen inputs\n- Autocorrelate chosem inputs\n- Align chosen input\n---------------------------------------------\nThe full procedure is:\n1.) Choose the inputs\n2.) Measure the phases\n3.) Synchronise inputs\n4.) Align inputs:\n    - first each level sepratelly\n    - the between levels\n\n', 'GUI', 'INPUTS', [], 'INPUTS'], ['ADCtools', 'Reads adc 300 times as quickly as possible and print it.\n', 'void', 'adcitest', [['board', 'int', '']]], ['ADCtools', 'Scan of BC delay with going from 0 to 31 \n(waiting 10000milsecs between measurements).\n', 'void', 'scanDel', [['micseconds', 'int', ''], ['board', 'int', '']]], ['ADCtools', 'Demonstrates time constant parameters of RL element in delay line.\n', 'void', 'adctimeconst', [['delay0', 'w32', ''], ['delay1', 'w32', ''], ['board', 'int', '']]], ['ADCtools', 'Generates random delays and measure adc for each of them.\n', 'void', 'rndtest', [['board', 'int', '']]], ['ADCtools', '', 'void', 'setbcdelay', [['delay', 'w32', '']]], ['ADCtools', 'rc: 2 BC_STATUS low bits: [BC_STATUSpll, BC_STATUSerr] ', 'w32', 'getbcstatus', [['board', 'int', '']]], ['ADCtools', '  Inputs are counted from 1 to 24(12) as in hardware.\n', 'int', 'setinput', [['board', 'int', ''], ['input', 'w32', '']]], ['EDGEtools', 'Measure phase of ORBIT wrt to BC, by the edge mechanism on BUSY board.\n', 'void', 'measureedge', []], ['ALItools', '', 'void', 'setDelay', [['board', 'int', ''], ['input', 'w32', ''], ['delay', 'w32', '']]], ['EDGEtools', '', 'void', 'getEdge', [['board', 'int', ''], ['input', 'w32', '']]], ['ADCtools', "Steering for phase measurement\nAlways set edge to 'P' before measurement and then set it back.\n", 'int', 'measurephase', [['board', 'int', ''], ['input', 'int', '']]], ['SIGNATUREtools', 'Routine:\n- read the detector name from the input window\n- gets dns node\n- get the status of detector inputs:\n  0:N = normal\n  1:T = toggling\n  2:S = signature\n  3:R = Random generator\n    E = error\n', 'void', 'getDetInputStatus', [['Detector', 'char', '*'], ['numofinputs', 'int', '']]], ['SIGNATUREtools', 'N,T,S,R\nInputs are counted from 1. (Check in server.c)\n', 'void', 'setStatus', [['Detector', 'char', '*'], ['input', 'int', ''], ['stat', 'char', '']]], ['SIGNATUREtools', '1=L0, 2=L1, 3=L2. \nFast check of all input signals for choosen board.\nThe routine takes the snapshot of inputs and counts number of nonzero bits.\nThe approximate values are following:\n- 524288 ~ TOGGLING (Mega/2),\n- 11760  ~ ORBIT\n- 11517(28)  ~ SIGNATURE \nYou can check it with ssmbrowser.\n', 'void', 'checkInputsActivity', [['board', 'int', '']]], ['SIGNATUREtools', '  Check rnds and bcs for activity\n', 'void', 'checkInputsActivityRB', []], ['SIGNATUREtools', 'Translates Signature number to LVDST SEQ_DATA word, i.e the least\n2 significant bits are zero.\nlvdst2 is hexa signature\n', 'int', 'SigNum2LVDSTNum', [['SigNum', 'int', '']]], ['SIGNATUREtools', '  Signature= Header(8 bits)+Number(7 bits)+(~Number)\n  Check signature at board in input. Input counted from 1\n  Otput:\n  Headers:    number of headers found\n  FHeaders:   number of headers attemted but failed\n  Signatures: number of ssm signatures equaled to input signature\n  CmplCntsS:  number of cases when ssm signature == ~(compl ssm signature) \n  CmplCntsI:  number of cases when (compl ssm signature) = ~(input signature)\n  CheckDist:  number of changes of distance between two subsequent headers\n\n  Typical situations.\n--------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    16        0        0         0         0         0         0 \nNo headers found, nothing in ssm channel.\n---------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    16        0    11760         0         0         0         0 \nNo headers found, ssm channel has some nonzero bits.\n-------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    19     1048        0         0         0         0         0 \nHeaders ok.\n-------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    19     1048     1048      1048         0         0         0 \nComplements are not ok, also some spurious signalbetween headers. \n--------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    19     1047        0      1047         0         0         0 \nHeaders and signatures ok, complements wrong\n---------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    19     1047     1047      1047      1047      1047         0 \nLooks like you have some spurious signal between signatures.\n---------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    19     1048        0         0      1048         0         0 \nYou are almost there,\nlooks like signature in ssm is different from one you input\nbut otherwise everything ok.\n---------------------------------------------------------------------\nChannel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n    19     1048        0      1048      1048      1048         0 \nEverything OK!\n\n  Check only one input\n', 'void', 'CheckSignature', [['board', 'int', ''], ['signature', 'int', ''], ['input', 'int', '']]], ['SIGNATUREtools', '  Check all inputs\n', 'void', 'FindSignatures', [['board', 'int', ''], ['inputs', 'char', '*']]], ['ADCtools', '', 'void', 'getorbitstatus', []], ['SimpleTests', 'Dump CTP configuration.\nL0 BOARD CLASSES section:\nclass: L0_CONDITION L0_VETO L0_RATE L0_MASK [L0_INVERT for classes45-50 or all]\n', 'void', 'dumpCTP', []], ['L0', 'get PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n', 'void', 'getPF', [['ix', 'int', '']]], ['L0', 'get PF parameters for 1 circuit \nI:\nL0, L1, or L2 -> ix= 1, 2 or 3\ncirc -> 1..5\nO: on stdout: 3 hexadecimal numbers: PFBLOCK_A, PFBLOCK_B, PFLUT\n', 'void', 'getPFc', [['ix', 'int', ''], ['circ', 'int', '']]], ['L0', 'like getPF\n', 'void', 'getprtPF', [['ix', 'int', '']]], ['L0', 'like getPFc\n', 'void', 'getprtPFc', [['ix', 'int', ''], ['circ', 'int', '']]], ['L0', 'set PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\npfc: PF_COMMON word\n', 'void', 'setPF', [['ix', 'int', ''], ['pfc', 'w32', '']]], ['L0', 'set PF parameters for 1 circuit \nI:\nL0, L1, or L2 -> ix= 1, 2 or 3\ncirc -> 1..5\nA, B, LUT -3 words to be written\n', 'void', 'setPFc', [['ix', 'int', ''], ['circ', 'int', ''], ['A', 'w32', ''], ['B', 'w32', ''], ['LUT', 'w32', '']]], ['L0', 'Print setings (12 hexa numbers) of PFcircuit for deltat in BCs\nFirst hexa number is 0xffffffff if error\n', 'void', 'printPFwc', [['deltat', 'int', '']]], ['L0', 'get rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2 INTSEL1 INTSEL2 allrare\n', 'void', 'getShared', []], ['L0', 'get 4096 hexa chars each containing i-bit of LUT4-1. i:0..4095\n', 'void', 'getSharedL0f34', [['lutout', 'int', '']]], ['L0', '4096 hexa chars from stdin will be loaded to LUT31 32 41 42', 'void', 'setSharedL0f34', []], ['L0', 'set rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2\n', 'void', 'setShared', [['r1', 'w32', ''], ['r2', 'w32', ''], ['bs1', 'w32', ''], ['bs2', 'w32', ''], ['int1', 'w32', ''], ['int2', 'w32', ''], ['intt', 'w32', ''], ['l0fun1', 'w32', ''], ['l0fun2', 'w32', '']]], ['L0', 'set INTERACTSEL ALL_RARE_FLAG\n', 'void', 'setShared2', [['intsel', 'w32', ''], ['allrare', 'w32', '']]], ['DbgNewFW', 'Load run reading RCFG file in WORK directory \n', 'void', 'loadRun', [['runnumber', 'w32', '']]], ['DbgNewFW', 'Prints static class CTPHardware.\n', 'void', 'printHW', []], ['DbgNewFW', '', 'void', 'unloadRun', [['runnumber', 'w32', '']]], ['DbgNewFW', '', 'void', 'printL0FUN34', []], ['Common', '', 'int', 'notInCrate', [['ix', 'int', '']]], ['Common', '', 'int', 'findBUSYINP', [['fo', 'int', ''], ['foc', 'int', '']]], ['busy', ' Input: time in milisecs\n For detectors in clusters as defined on busy board \n it calculates and prints average: \n  -fraction of the time detectors is busy \n  -average deadtime\n', 'w32', 'findDeadBusysRuns', [['time', 'int', '']]], ['busy', ' For detectors in clusters as defined on busy board\n it reads LasBusy counter.\n Last busy counts number of cases when detector is releasing busy LAST\n in given cluster.\n', 'void', 'printLastDetectors', [['cluster', 'w32', '']]], ['busy', 'Busy probe option - minimax select word\nSelect the object you want to study:\n0- CTP BUSY\n1-24 : detectors\n25-30 : clusters\n31 test cluster\n', 'void', 'busyprobe', [['det', 'char', '*']]], ['busy', 'Input: dets is pattern of detectors to be checked.  0xffffff: all dets\nOperation:\n- read busy timers\n- sleep 100ms\n- read busy timers \n- calculate difference between 2 measurements and compare \n  with busy_timer\nrc: busy pattern: [0..23] bits set to 1 correspond to Dead busy inputs\n', 'w32', 'findDeadBusys', [['dets', 'w32', '']]], ['DebCon', '', 'int', 'GenSwtrg', [['n', 'int', ''], ['trigtype', 'char', ''], ['roc', 'int', ''], ['BC', 'w32', ''], ['detectors', 'w32', ''], ['customer', 'int', '']]], ['DebCon', '', 'int', 'getCALIBBC2', [['ctprodets', 'w32', '']]], ['DbgScopeCalls', '', 'int', 'checkScopeBoard', [['ab', 'char', '']]], ['DbgScopeCalls', '', 'int', 'setScopeBoard', [['ab', 'char', ''], ['board', 'int', '']]], ['DbgScopeCalls', '', 'int', 'getScopeSignal', [['board', 'int', ''], ['ab', 'char', '']]], ['DbgScopeCalls', '', 'int', 'setScopeSignal', [['board', 'int', ''], ['ab', 'char', ''], ['signal', 'int', '']]], ['DbgScopeCalls', '', 'int', 'getVMERWScope', []], ['DbgScopeCalls', '', 'void', 'setVMERWScope', [['newv', 'w32', ''], ['oldv', 'w32', '']]], ['ConfiguratioH', 'Print 1 line string xxxx\nwhere x is the status (0/1) of software LED word\n', 'void', 'getSWLEDS', [['ixboard', 'int', '']]], ['inputsTools', 'board:0:busy (the CLK edge for input ORBIT signal) \n      1..3:L0/1/2  \ninput: no sense for busy board.For L0/1/2 boards: L0,L1:1..24   L2:1..12\nedge: 0:Positive 1:Negative\n\nEdge: choose negative (for delay:0) if unstability is found around delay 0.\n', 'void', 'setEdge', [['board', 'int', ''], ['input', 'w32', ''], ['edge', 'w32', '']]], ['inputsTools', 'set Edge/Delay \nInputs:\nboard: 1:L0 2:L1 3:L2\ninput: 1..24 (1..12 for L2)\nedge:  0:positive 1:negative\ndelay: 0..15', 'void', 'setEdgeDelay', [['board', 'int', ''], ['input', 'int', ''], ['edge', 'int', ''], ['delay', 'int', '']]], ['inputsTools', 'Read edge/delay info from hw for all the inputs (clk edge for ORbit\nin case of busy board).\nInputs:\n  board: 0:busy (the CLK edge for INPUT ORBIT signal)\n         1..3: L0/1/2\n  input: 1..24 (for L0/1 boards) 1..12 for L2 board\n\nEdge: choose negative (for delay:0) if unstability is found around delay 0.\n\n', 'void', 'printEdgeDelay', [['board', 'int', '']]], ['L0', 'read BC masks from HW and print out 3564 4bits words\n', 'void', 'getBCmasks', []], ['L0', 'set BC masks in HW from input line containing 3564 hexa-chars.\n', 'void', 'setBCmasks', []], ['L0', 'set/read/check ntimes\nwords: if 0 than check whole BCmask memory (3564)\n', 'void', 'checkBCmasks', [['ntimes', 'int', ''], ['words', 'int', '']]], ['SimpleTests', 'return 5 integers in 1 line corresponding to clcock phase on L0/1/2 BUSY INT\n', 'void', 'checkPhasesPrint', []], ['SimpleTests', '', 'void', 'printToggle', []], ['SimpleTests', '', 'int', 'Toggle', [['det', 'char', '*'], ['onoff', 'int', '']]], ['SimpleTests', 'Resets PLL clock on all boards\n', 'void', 'resetPLLS', []], ['SimpleTests', '', 'void', 'ReadPF', []], ['SimpleTests', '', 'void', 'WritePFcommon', [['INTa', 'w32', ''], ['INTb', 'w32', ''], ['Delayed_INT', 'w32', '']]], ['SimpleTests', '', 'void', 'WritePF', [['icircuit', 'w32', ''], ['THa1', 'w32', ''], ['THa2', 'w32', ''], ['THb1', 'w32', ''], ['THb2', 'w32', ''], ['dTa', 'int', ''], ['dTb', 'int', ''], ['P_signal', 'w32', '']]], ['SimpleTests', 'Set PF circuit for INT1 only (for INT1/2 combinations, another\nfunction should be prepared). Note that INT1 should be defined in Shared Resources!\nExamples of INT1 definition: it can be BC1,BC2,RND1,RND2 or any logical combination of \nfirst 4 L0 inputs (INTfun1). For example if we want to define INT1 as L01 input then INTfun1 \nwill be 0xaaaa, L02 only -> INTfun1=0xcccc, L03 only -> INTfun1=0xf0f0, L04 only -> INTfun1=0xff00,\nL01.or.L02.or.L03.or.L04 -> INTfun1=0xfffe, L01.and.L02.and.L03.and.L04 -> INTfun1=0x8000\n\nicircuit: 1..4 - circuit number - there can be 4 PF protections in parallel\n\nbcs: 1..4096 - protected interval in BCs. \nFor example: 10mus = 400 BC.\n\nthreshold: 0..63 - number of allowed interactions in protected interval \nFor example: 0: kill this event  1: only this event   2: max. 1 additional event\n', 'void', 'WritePFuser', [['icircuit', 'w32', ''], ['threshold', 'w32', ''], ['bcs', 'w32', '']]], ['SimpleTests', '', 'int', 'WritePFuserII', [['Ncoll', 'w32', ''], ['dT1', 'w32', ''], ['dT2', 'w32', ''], ['icircuit', 'w32', ''], ['plut', 'w32', '']]], [None, 'read QPLL* and TTCrx status bits.\nRC: 0xTAB\nT: bit 8. 1: TTCrx ok\nA: [7..6] BC1 error,locked (i.e. 01 correct)\n   [5..4] BC2\nB: [3..2] BCref\n   [1..0] BCmain\nI.e. 0x155 is correct status of all 9 bits\n     0x1aa error in both BC, was not locked. NEXT READING is 0x155 !\n', 'w32', 'readstatus', []], ['L012', '', 'w32', 'getCounter', [['board', 'int', ''], ['reladr', 'int', ''], ['customer', 'int', '']]], ['L012', '', 'void', 'getCounters', [['N', 'int', ''], ['accrual', 'int', ''], ['customer', 'int', '']]], ['L012', '', 'void', 'clearCounters', [['customer', 'int', '']]], ['SimpleTests', 'rc: 0: if L0 borad firmware >0xAB\n    boardversion if firmware <=0xAB \n', 'int', 'l0AB', []], ['INT', "daqon:0       ->daq active\ndaqon:0xb     ->daq off (i.e. produce triggers in spite of DDL red diode \n                on INT board is on \ndaqon: other  -> show current status.\nNOTE about LEDs on INT board:\nDDL interface: \n  green:DDL line ready, data not read out \n  flashing green: DDL line ready, data are read out\n  flashing orange: data are read out, backpressure is sometimes active\n                   (DAQ is not able to read everything)\nupper DDL LED on INT board fron panel:\n  red: INT is raising CTPBUSY on backlplane, because of full DDL buffers\nINT_DDL_EMU word in normal mode (i.e. DAQ active):\n     DDLfiLF  DDLfiBEN  DDLfiDIR\n0x20:      0         1         0  data can't be sent (DDL not enabled from DIU)\n0x30:      0         1         1  data sent\n0x70:      1         1         1  data not sent (backpressure)\n", 'void', 'DAQonoff', [['daqon', 'int', '']]], ['ALItools', '', 'void', 'setRareFlag', [['board', 'int', ''], ['input', 'int', ''], ['mode', 'int', '']]], ['ALItools', '', 'void', 'initAignment', []], ['ALItools', '', 'void', 'printINPUTS', []], ['ALItools', '', 'void', 'resetINPUTS', []], ['ALItools', '------------------------------------------------------------------------------\nRecord and read 1SSM\n', 'void', 'take1SSM', [['board', 'int', ''], ['ntimes', 'int', '']]], ['ALItools', '', 'void', 'filter', [['sm', 'w32', '*'], ['chan', 'int', '']]], ['ALItools', '----------------------------------------------------------------------------\nRecord and read 1SSM\n', 'void', 'takerbSSM', [['ntimes', 'int', '']]], ['ALItools', '---------------------------------------------------------------------------------------\nRecord and read and synchronise 2 SSMs\n', 'int', 'take2SSM', [['board1', 'int', ''], ['board2', 'int', ''], ['ntimes', 'int', '']]], ['ALItools', 'To be written. We do not need it untill any L2 inputs exits\n', 'int', 'take3SSM', [['ntimes', 'int', '']]], ['ALItools', '  delta=0 -> autocor fun\n  delta=1 -> -1,0,1\n', 'void', 'croscor1', [['input1', 'int', ''], ['input2', 'int', ''], ['cordist', 'int', ''], ['delta', 'int', ''], ['dir', 'int', '']]], ['ALItools', 'Autocorel one input\ncordist>0\n', 'void', 'autocor', [['input', 'int', ''], ['cordist', 'int', ''], ['delta', 'w32', '']]], ['ALItools', 'Steering routone for correlation:\n type =0 : autocorrelation = noise, bckg\n type =1 : crosscorrelation = alignment\n h0chans = channels in ssm in l0 output mode\n', 'void', 'Correl', [['type', 'int', ''], ['l0inputs', 'int', ''], ['l1inputs', 'int', ''], ['l2inputs', 'int', ''], ['h0chans', 'int', ''], ['cordist', 'int', ''], ['delta', 'int', ''], ['dir', 'int', '']]], ['DebugSSMcalls', '-------------------------------------------------------------- getswSSM() \nreturn status word of SSM\nLTU: [4] FrontPanel->SSM mode active\n     [3] not used\n     [2] BUSY bit\n     [1..0] operation\nCTP: [8] -BUSY\n     [7..6] Enable SSM Input..Output flag\n     [5..4] ConfSel bits\n     [3..3] InOut flag   0:out   1:in\n     [2..1] Operation bits \n     [0..0] mode bit \nerror: 0xdeadbeaf\n', 'w32', 'getswSSM', [['board', 'int', '']]], ['DebugSSMcalls', '-------------------------------------------------------------- setsmssw() \nset sms[].mode\n', 'void', 'setsmssw', [['ix', 'int', ''], ['newmode', 'char', '*']]], ['DebugSSMcalls', "Set operation & mode. If SSM is BUSY, an attempt is made to stop\nthe recording.\nInput parameteres:\nboard -number of the board (index into global sms array) \n       0..NSSMBOARDS    (busy,L0,1,2,int,fo1,2,3,4,5,6,ltu1,2,3,4)\nopmo  -mode/operation bit for SSMcommand word. symbolic names \n       are defined in ctp.h (as SSMom*)\n\nopmo for LTU boards:\n--------------\n0x0 -VME access, read\n0x1 -VME access, write\n0x2 -RECORDING, After  (cca 26 milsec)\n0x3 -RECORDING, Before (should be stopped by SSMstoprec)\n\nBit opmo[4] (0x10) should be set to 1 for LTU/RECORDING mode\n    (new feature 'FrontPanel->SSM' introduced for LTU 7.10.2005)\n    If not set, signals from LTU-FPGA will be recorded.\n\nopmo for CTP boards:\n--------------\nThe codes above (0-3) are valid, in addition 7 bits (opmo[9..3] are\nmeaningfull, and 2 more codes are added:\n0x4 - GENERATING, single pass\n0x5 - GENERATING, continuous\nopmo[9..8] - bits to be used for selecting SSMenable word\n             10 ->enable Input    01 ->enable Output\nopmo[7..6] - not used\nopmo[5..4] - ConfSel bits  (defined in \n               $VMECFDIR/CFG/ctp/ssmsigs/.sig files)\nopmo[3]      - InOut flag   1:in   0:out (side of FPGA logic)\nExamples: \n0x20d - generate continuously  inputs for board logic\n0x20c - generate 1 pass (27ms) inputs for board logic\n0x102 - record   1 pass (27ms) of board logic outputs\nRC:  0->ok, mode set\n     1->mode not set, possible errors (printed to stdout):\n        -BC signal not connected\n        -Cannot stop recording operation\n     2->bad mode for LTU board\n", 'int', 'setomSSM', [['board', 'int', ''], ['opmo', 'w32', '']]], ['DebugSSMcalls', '', 'int', 'startSSM1', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------- stopSSM()\nOpearation:\n- check if board is in BUSY status\n- stop (recording or generation)\nrc: == 0 OK\n       1 board not busy, no action\n       2 problem with openvme for LTU\n', 'int', 'stopSSM', [['board', 'int', '']]], ['DebugSSMcalls', "Opearation:\n- read counter cntpos\n- check 'the change of this counter' + check maxloops\n- sleep 'sleepafter' micsecs (should be 0 or at least 100)\n- stop (recording or generation) -> call stopSSM()\nInputs:\nboard: 0:busy, 1:L0,..., 10:INT\n      21: L0+L1 -> i.e. stop 2 SSM for L0/1 board\ncntpos: position of the counter (starting from 0) for this board\n        see 2. column in dimcdistrib/cnames.sorted2 file\nmaxloops: max. number of loops (1 loop == cca 2 ms)\n          0: loop forever\ncustomer: bakery customer (see ctplib/readCounters.c)\nrc: == 0 OK\n   1 board not busy, no action (i.e. SSM was not started before in\n     'BEFORE/continuous' mode)\n   2 problem with openvme for LTU\n  10 timeout (counter did not change even after 'maxloops' reads)\n--------------------- ", 'int', 'condstopSSM', [['board', 'int', ''], ['cntpos', 'int', ''], ['maxloops', 'int', ''], ['sleepafter', 'int', ''], ['customer', 'int', '']]], ['DebugSSMcalls', '--------------------------------------------------------- readSSM()\nread whole SSM into array of unsigned ints\nNote: InOut, ConfSel bits and SSMenable word left unchanged\nInput:\nboard: board according to sms global array\nOutput:\nrc:  0 SSM read into sms[board].sm->\n       i.e. Mega words were read\n    >0 only part of SSM was read into sms[board].sm-> \n       reason in After or Before mode:\n       - SSM stopped early (<26ms)\n', 'int', 'readSSM', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------ writeSSM()\nwrite whole sms[].sm into hardware\nNote: InOut, ConfSel bits and SSMenable word left unchanged\nInput:\nboard: board according to sms global array\nrc:    0: no errors found during writing\n', 'int', 'writeSSM', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------ dumpSSM()\nwrite whole sms[].sm into hardware\nInput:\nboard: board according to sms global array\nrc:    0: no errors found during writing\n', 'int', 'dumpSSM', [['board', 'int', ''], ['fname', 'char', '*']]], ['DebugSSMcalls', 'Dump computer ssm (not hw ssm)\ncompress: 0: old way 1; new way i.e. compressed\n', 'int', 'dumpssm_compress', [['board', 'int', ''], ['fname', 'char', '*'], ['compress', 'int', '']]], ['DebugSSMcalls', "print to stdout SSM board from word 'fromadr'\n", 'void', 'printSSM', [['board', 'int', ''], ['fromadr', 'int', '']]], ['SimpleTests', " Read binary dump written before by dumpSSM() to the sms[board].sm\nboard: 0,1,2,... ->   BUSY, L0, L1,...\nfilename: 'WORK/name.dmp'\ncompress: 0: old way 1; new way i.e. compressed\n", 'int', 'readSSMDump_compress', [['board', 'int', ''], ['filename', 'char', '*'], ['compress', 'int', '']]], ['DbgSSMBROWSERcalls', 'return the names+modes of SSMs for present boards:\nstdout:\nname1 mode1 \nname2 mode2 \n...\nmode -mode of the ssm or:\n      _nomode if sms[ix].mode is epmty string\n      notin  board is not in the crate\n      nossm  if board or sms[ix].sm==NULL\n', 'void', 'gettableSSM', []], ['DbgSSMBROWSERcalls', 'return line:\nhighest_syncflag n1 n2...\nn1,n2 -numbers of items (indexes into sms[])\n', 'void', 'getsfSSM', [['board', 'int', '']]], ['DbgSSMBROWSERcalls', 'return line:\nhighest_syncflag n1 n2...\nn1,n2 -numbers of items (indexes into sms[])\n', 'void', 'getsyncedSSM', []], ['DbgSSMBROWSERcalls', "Extract 1 signal to stdout:\nInput:\nboard:   (0...) according to sms global array\nbit:     SSM bit (0-31)\nfrombc: bc number. \n         0 corresponds to word with address sms[board].offset\nbits:    number of bits to be examined (but don't print more then\n         102 lines)\nOutput:\nvalue_of_the_1st_bit      or <0 if error\nbit_number_for_which_value_changed\nbit_number_for_which_value_changed\n...\nErrors:\n-1 -> required SSM not read\n", 'void', 'getsigSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', ''], ['bits', 'int', '']]], ['DbgSSMBROWSERcalls', 'Find signal change.\nInput:\nboard,bit,frombc: as in getsigSSM()\nOutput (on stdout):\n-1 -signal does not change (or memory not accessible)\nn  - pointing to the last bit with the same value, next bit\n     is different\n', 'void', 'finddifSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', '']]], ['DbgSSMBROWSERcalls', 'print sms[board].offset\n', 'void', 'getoffsetSSM', [['board', 'int', '']]], ['DbgSSMBROWSERcalls', 'set sms[board].offset\n', 'void', 'setoffsetSSM', [['board', 'int', ''], ['newoffset', 'int', '']]], ['DbgSSMBROWSERcalls', 'set sms[board].mode, ltubase\nboard: 0..  index into sms[]\nnewmode: file name in CFG/ctp/ssmsigs without .sig suffix\nltubase: valid only for ltu (board>10)\n', 'void', 'setmodeSSM', [['board', 'int', ''], ['newmode', 'char', '*'], ['ltubase', 'char', '*']]], ['DbgSSMBROWSERcalls', 'set sms[board].offset\n', 'void', 'printsms', []]]
