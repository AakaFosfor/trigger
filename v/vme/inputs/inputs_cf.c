/* generated by comp.py */
#include <stdio.h>
#include "vmewrap.h"
#include "lexan.h"
#include "vmeaistd.h"

char BoardName[]="inputs";
char BoardBaseAddress[11]="0x820000";
char BoardSpaceLength[11]="0xd000";
char BoardSpaceAddmod[11]="A24";
char gettableSSM_usagehelp[]="return the names+modes of SSMs for present boards:\n\
stdout:\n\
name1 mode1 \n\
name2 mode2 \n\
...\n\
mode -mode of the ssm or:\n\
      _nomode if sms[ix].mode is epmty string\n\
      notin  board is not in the crate\n\
      nossm  if board or sms[ix].sm==NULL\n\
";

Tpardesc getsfSSM_parameters[1]={
{"board", 1}};
char getsfSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

char getsyncedSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

Tpardesc getsigSSM_parameters[4]={
{"board", 1},
{"bit", 1},
{"frombc", 1},
{"bits", 1}};
char getsigSSM_usagehelp[]="Extract 1 signal to stdout:\n\
Input:\n\
board:   (0...) according to sms global array\n\
bit:     SSM bit (0-31)\n\
frombc: bc number. \n\
         0 corresponds to word with address sms[board].offset\n\
bits:    number of bits to be examined (but don't print more then\n\
         102 lines)\n\
Output:\n\
value_of_the_1st_bit      or <0 if error\n\
bit_number_for_which_value_changed\n\
bit_number_for_which_value_changed\n\
...\n\
Errors:\n\
-1 -> required SSM not read\n\
";

Tpardesc finddifSSM_parameters[3]={
{"board", 1},
{"bit", 1},
{"frombc", 1}};
char finddifSSM_usagehelp[]="Find signal change.\n\
Input:\n\
board,bit,frombc: as in getsigSSM()\n\
Output (on stdout):\n\
-1 -signal does not change (or memory not accessible)\n\
n  - pointing to the last bit with the same value, next bit\n\
     is different\n\
";

Tpardesc getoffsetSSM_parameters[1]={
{"board", 1}};
char getoffsetSSM_usagehelp[]="print sms[board].offset\n\
";

Tpardesc setoffsetSSM_parameters[2]={
{"board", 1},
{"newoffset", 1}};
char setoffsetSSM_usagehelp[]="set sms[board].offset\n\
";

Tpardesc setmodeSSM_parameters[3]={
{"board", 1},
{"newmode", 3| 0x80000000},
{"ltubase", 3| 0x80000000}};
char setmodeSSM_usagehelp[]="set sms[board].mode, ltubase\n\
board: 0..  index into sms[]\n\
newmode: file name in CFG/ctp/ssmsigs without .sig suffix\n\
ltubase: valid only for ltu (board>10)\n\
";

char printsms_usagehelp[]="set sms[board].offset\n\
";

char dumpCTP_usagehelp[]="Dump CTP configuration.\n\
L0 BOARD CLASSES section:\n\
class: L0_CONDITION L0_VETO L0_RATE L0_MASK [L0_INVERT for classes45-50 or all]\n\
";

Tpardesc getPF_parameters[1]={
{"ix", 1}};
char getPF_usagehelp[]="get PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
";

Tpardesc getPFc_parameters[2]={
{"ix", 1},
{"circ", 1}};
char getPFc_usagehelp[]="get PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
O: on stdout: 3 hexadecimal numbers: PFBLOCK_A, PFBLOCK_B, PFLUT\n\
";

Tpardesc getprtPF_parameters[1]={
{"ix", 1}};
char getprtPF_usagehelp[]="like getPF\n\
";

Tpardesc getprtPFc_parameters[2]={
{"ix", 1},
{"circ", 1}};
char getprtPFc_usagehelp[]="like getPFc\n\
";

Tpardesc setPF_parameters[2]={
{"ix", 1},
{"pfc", 2}};
char setPF_usagehelp[]="set PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
pfc: PF_COMMON word\n\
";

Tpardesc setPFc_parameters[5]={
{"ix", 1},
{"circ", 1},
{"A", 2},
{"B", 2},
{"LUT", 2}};
char setPFc_usagehelp[]="set PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
A, B, LUT -3 words to be written\n\
";

Tpardesc printPFwc_parameters[1]={
{"deltat", 1}};
char printPFwc_usagehelp[]="Print setings (12 hexa numbers) of PFcircuit for deltat in BCs\n\
First hexa number is 0xffffffff if error\n\
";

char getShared_usagehelp[]="get rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2 INTSEL1 INTSEL2 allrare\n\
";

Tpardesc getSharedL0f34_parameters[1]={
{"lutout", 1}};
char getSharedL0f34_usagehelp[]="get 4096 hexa chars each containing i-bit of LUT4-1. i:0..4095\n\
";

Tpardesc setL0f34c_parameters[1]={
{"m4", 3| 0x80000000}};
char setSharedL0f34_usagehelp[]="4096 hexa chars from stdin will be loaded to LUT31 32 41 42";

Tpardesc setShared_parameters[9]={
{"r1", 2},
{"r2", 2},
{"bs1", 2},
{"bs2", 2},
{"int1", 2},
{"int2", 2},
{"intt", 2},
{"l0fun1", 2},
{"l0fun2", 2}};
char setShared_usagehelp[]="set rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2\n\
";

Tpardesc setShared2_parameters[2]={
{"intsel", 2},
{"allrare", 2}};
char setShared2_usagehelp[]="set INTERACTSEL ALL_RARE_FLAG\n\
";

Tpardesc loadRun_parameters[1]={
{"runnumber", 2}};
char loadRun_usagehelp[]="Load run reading RCFG file in WORK directory \n\
";

char printHW_usagehelp[]="Prints static class CTPHardware.\n\
";

Tpardesc unloadRun_parameters[1]={
{"runnumber", 2}};
Tpardesc setL0FUN34_parameters[1]={
{"lut", 2| 0x80000000}};
Tpardesc notInCrate_parameters[1]={
{"ix", 1}};
Tpardesc findBUSYINP_parameters[2]={
{"fo", 1},
{"foc", 1}};
Tpardesc getCounter_parameters[2]={
{"board", 1},
{"reladr", 1}};
Tpardesc getCounters_parameters[2]={
{"N", 1},
{"accrual", 1}};
Tpardesc findDeadBusysRuns_parameters[1]={
{"time", 1}};
char findDeadBusysRuns_usagehelp[]=" Input: time in milisecs\n\
 For detectors in clusters as defined on busy board \n\
 it calculates and prints average: \n\
  -fraction of the time detectors is busy \n\
  -average deadtime\n\
";

Tpardesc printLastDetectors_parameters[1]={
{"cluster", 2}};
char printLastDetectors_usagehelp[]=" For detectors in clusters as defined on busy board\n\
 it reads LasBusy counter.\n\
 Last busy counts number of cases when detector is releasing busy LAST\n\
 in given cluster.\n\
";

Tpardesc busyprobe_parameters[1]={
{"det", 3| 0x80000000}};
char busyprobe_usagehelp[]="Busy probe option - minimax select word\n\
Select the object you want to study:\n\
0- CTP BUSY\n\
1-24 : detectors\n\
25-30 : clusters\n\
31 test cluster\n\
";

Tpardesc findDeadBusys_parameters[1]={
{"dets", 2}};
char findDeadBusys_usagehelp[]="Input: dets is pattern of detectors to be checked.  0xffffff: all dets\n\
Operation:\n\
- read busy timers\n\
- sleep 100ms\n\
- read busy timers \n\
- calculate difference between 2 measurements and compare \n\
  with busy_timer\n\
rc: busy pattern: [0..23] bits set to 1 correspond to Dead busy inputs\n\
";

Tpardesc GenSwtrg_parameters[6]={
{"n", 1},
{"trigtype", 3},
{"roc", 1},
{"BC", 2},
{"detectors", 2},
{"customer", 1}};
Tpardesc getCALIBBC2_parameters[1]={
{"ctprodets", 2}};
Tpardesc checkScopeBoard_parameters[1]={
{"ab", 3}};
Tpardesc setScopeBoard_parameters[2]={
{"ab", 3},
{"board", 1}};
Tpardesc getScopeSignal_parameters[2]={
{"board", 1},
{"ab", 3}};
Tpardesc setScopeSignal_parameters[3]={
{"board", 1},
{"ab", 3},
{"signal", 1}};
Tpardesc setVMERWScope_parameters[2]={
{"newv", 2},
{"oldv", 2}};
Tpardesc getSWLEDS_parameters[1]={
{"ixboard", 1}};
char getSWLEDS_usagehelp[]="Print 1 line string xxxx\n\
where x is the status (0/1) of software LED word\n\
";

Tpardesc setEdge_parameters[3]={
{"board", 1},
{"input", 2},
{"edge", 2}};
char setEdge_usagehelp[]="board:0:busy (the CLK edge for input ORBIT signal) \n\
      1..3:L0/1/2  \n\
input: no sense for busy board.For L0/1/2 boards: L0,L1:1..24   L2:1..12\n\
edge: 0:Positive 1:Negative\n\
\n\
Edge: choose negative (for delay:0) if unstability is found around delay 0.\n\
";

Tpardesc setEdgeDelay_parameters[4]={
{"board", 1},
{"input", 1},
{"edge", 1},
{"delay", 1}};
char setEdgeDelay_usagehelp[]="set Edge/Delay \n\
Inputs:\n\
board: 1:L0 2:L1 3:L2\n\
input: 1..24 (1..12 for L2)\n\
edge:  0:positive 1:negative\n\
delay: 0..15";

Tpardesc printEdgeDelay_parameters[1]={
{"board", 1}};
char printEdgeDelay_usagehelp[]="Read edge/delay info from hw for all the inputs (clk edge for ORbit\n\
in case of busy board).\n\
Inputs:\n\
  board: 0:busy (the CLK edge for INPUT ORBIT signal)\n\
         1..3: L0/1/2\n\
  input: 1..24 (for L0/1 boards) 1..12 for L2 board\n\
\n\
Edge: choose negative (for delay:0) if unstability is found around delay 0.\n\
\n\
";

char getBCmasks_usagehelp[]="read BC masks from HW and print out 3564 4bits words\n\
";

char setBCmasks_usagehelp[]="set BC masks in HW from input line containing 3564 hexa-chars.\n\
";

Tpardesc checkBCmasks_parameters[2]={
{"ntimes", 1},
{"words", 1}};
char checkBCmasks_usagehelp[]="set/read/check ntimes\n\
words: if 0 than check whole BCmask memory (3564)\n\
";

char checkPhasesPrint_usagehelp[]="return 5 integers in 1 line corresponding to clcock phase on L0/1/2 BUSY INT\n\
";

Tpardesc Toggle_parameters[2]={
{"det", 3| 0x80000000},
{"onoff", 1}};
char resetPLLS_usagehelp[]="Resets PLL clock on all boards\n\
";

Tpardesc WritePFcommon_parameters[3]={
{"INTa", 2},
{"INTb", 2},
{"Delayed_INT", 2}};
Tpardesc WritePF_parameters[8]={
{"icircuit", 2},
{"THa1", 2},
{"THa2", 2},
{"THb1", 2},
{"THb2", 2},
{"dTa", 1},
{"dTb", 1},
{"P_signal", 2}};
Tpardesc WritePFuser_parameters[3]={
{"icircuit", 2},
{"threshold", 2},
{"bcs", 2}};
char WritePFuser_usagehelp[]="Set PF circuit for INT1 only (for INT1/2 combinations, another\n\
function should be prepared). Note that INT1 should be defined in Shared Resources!\n\
Examples of INT1 definition: it can be BC1,BC2,RND1,RND2 or any logical combination of \n\
first 4 L0 inputs (INTfun1). For example if we want to define INT1 as L01 input then INTfun1 \n\
will be 0xaaaa, L02 only -> INTfun1=0xcccc, L03 only -> INTfun1=0xf0f0, L04 only -> INTfun1=0xff00,\n\
L01.or.L02.or.L03.or.L04 -> INTfun1=0xfffe, L01.and.L02.and.L03.and.L04 -> INTfun1=0x8000\n\
\n\
icircuit: 1..4 - circuit number - there can be 4 PF protections in parallel\n\
\n\
bcs: 1..4096 - protected interval in BCs. \n\
For example: 10mus = 400 BC.\n\
\n\
threshold: 0..63 - number of allowed interactions in protected interval \n\
For example: 0: kill this event  1: only this event   2: max. 1 additional event\n\
";

Tpardesc WritePFuserII_parameters[5]={
{"Ncoll", 2},
{"dT1", 2},
{"dT2", 2},
{"icircuit", 2},
{"plut", 2}};
char SSMbrowser_usagehelp[]="Browse CTP snapshot memories \n\
";

char INPUTS_usagehelp[]="The main window allowing \n\
- to edit inputs:\n\
    Delete,Modify,Add,Print\n\
- Check activity: count all 1 in snapshot memory\n\
- Synchronise chosen inputs\n\
- Autocorrelate chosem inputs\n\
- Align chosen input\n\
---------------------------------------------\n\
The full procedure is:\n\
1.) Choose the inputs\n\
2.) Measure the phases\n\
3.) Synchronise inputs\n\
4.) Align inputs:\n\
    - first each level sepratelly\n\
    - the between levels\n\
\n\
";

Tpardesc adcitest_parameters[1]={
{"board", 1}};
char adcitest_usagehelp[]="Reads adc 300 times as quickly as possible and print it.\n\
";

Tpardesc scanDel_parameters[2]={
{"micseconds", 1},
{"board", 1}};
char scanDel_usagehelp[]="Scan of BC delay with going from 0 to 31 \n\
(waiting 10000milsecs between measurements).\n\
";

Tpardesc adctimeconst_parameters[3]={
{"delay0", 2},
{"delay1", 2},
{"board", 1}};
char adctimeconst_usagehelp[]="Demonstrates time constant parameters of RL element in delay line.\n\
";

Tpardesc rndtest_parameters[1]={
{"board", 1}};
char rndtest_usagehelp[]="Generates random delays and measure adc for each of them.\n\
";

Tpardesc setbcdelay_parameters[1]={
{"delay", 2}};
Tpardesc getbcstatus_parameters[1]={
{"board", 1}};
char getbcstatus_usagehelp[]="rc: 2 BC_STATUS low bits: [BC_STATUSpll, BC_STATUSerr] ";

Tpardesc setinput_parameters[2]={
{"board", 1},
{"input", 2}};
char setinput_usagehelp[]="  Inputs are counted from 1 to 24(12) as in hardware.\n\
";

char measureedge_usagehelp[]="Measure phase of ORBIT wrt to BC, by the edge mechanism on BUSY board.\n\
";

Tpardesc setDelay_parameters[3]={
{"board", 1},
{"input", 2},
{"delay", 2}};
Tpardesc getEdge_parameters[2]={
{"board", 1},
{"input", 2}};
Tpardesc measurephase_parameters[2]={
{"board", 1},
{"input", 1}};
char measurephase_usagehelp[]="Steering for phase measurement\n\
Always set edge to 'P' before measurement and then set it back.\n\
";

Tpardesc getDetInputStatus_parameters[2]={
{"Detector", 3| 0x80000000},
{"numofinputs", 1}};
char getDetInputStatus_usagehelp[]="Routine:\n\
- read the detector name from the input window\n\
- gets dns node\n\
- get the status of detector inputs:\n\
  0:N = normal\n\
  1:T = toggling\n\
  2:S = signature\n\
  3:R = Random generator\n\
    E = error\n\
";

Tpardesc setStatus_parameters[3]={
{"Detector", 3| 0x80000000},
{"input", 1},
{"stat", 3}};
char setStatus_usagehelp[]="N,T,S,R\n\
Inputs are counted from 1. (Check in server.c)\n\
";

Tpardesc checkInputsActivity_parameters[1]={
{"board", 1}};
char checkInputsActivity_usagehelp[]="1=L0, 2=L1, 3=L2. \n\
Fast check of all input signals for choosen board.\n\
The routine takes the snapshot of inputs and counts number of nonzero bits.\n\
The approximate values are following:\n\
- 524288 ~ TOGGLING (Mega/2),\n\
- 11760  ~ ORBIT\n\
- 11517(28)  ~ SIGNATURE \n\
You can check it with ssmbrowser.\n\
";

char checkInputsActivityRB_usagehelp[]="  Check rnds and bcs for activity\n\
";

Tpardesc SigNum2LVDSTNum_parameters[1]={
{"SigNum", 1}};
char SigNum2LVDSTNum_usagehelp[]="Translates Signature number to LVDST SEQ_DATA word, i.e the least\n\
2 significant bits are zero.\n\
lvdst2 is hexa signature\n\
";

Tpardesc CheckSignature_parameters[3]={
{"board", 1},
{"signature", 1},
{"input", 1}};
char CheckSignature_usagehelp[]="  Signature= Header(8 bits)+Number(7 bits)+(~Number)\n\
  Check signature at board in input. Input counted from 1\n\
  Otput:\n\
  Headers:    number of headers found\n\
  FHeaders:   number of headers attemted but failed\n\
  Signatures: number of ssm signatures equaled to input signature\n\
  CmplCntsS:  number of cases when ssm signature == ~(compl ssm signature) \n\
  CmplCntsI:  number of cases when (compl ssm signature) = ~(input signature)\n\
  CheckDist:  number of changes of distance between two subsequent headers\n\
\n\
  Typical situations.\n\
--------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    16        0        0         0         0         0         0 \n\
No headers found, nothing in ssm channel.\n\
---------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    16        0    11760         0         0         0         0 \n\
No headers found, ssm channel has some nonzero bits.\n\
-------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    19     1048        0         0         0         0         0 \n\
Headers ok.\n\
-------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    19     1048     1048      1048         0         0         0 \n\
Complements are not ok, also some spurious signalbetween headers. \n\
--------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    19     1047        0      1047         0         0         0 \n\
Headers and signatures ok, complements wrong\n\
---------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    19     1047     1047      1047      1047      1047         0 \n\
Looks like you have some spurious signal between signatures.\n\
---------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    19     1048        0         0      1048         0         0 \n\
You are almost there,\n\
looks like signature in ssm is different from one you input\n\
but otherwise everything ok.\n\
---------------------------------------------------------------------\n\
Channel  Headers FHeaders Signatures CmplCntsS CmplCntsI CheckDist\n\
    19     1048        0      1048      1048      1048         0 \n\
Everything OK!\n\
\n\
  Check only one input\n\
";

Tpardesc FindSignatures_parameters[2]={
{"board", 1},
{"inputs", 3| 0x80000000}};
char FindSignatures_usagehelp[]="  Check all inputs\n\
";

Tpardesc getswSSM_parameters[1]={
{"board", 1}};
char getswSSM_usagehelp[]="-------------------------------------------------------------- getswSSM() \n\
return status word of SSM\n\
LTU: [4] FrontPanel->SSM mode active\n\
     [3] not used\n\
     [2] BUSY bit\n\
     [1..0] operation\n\
CTP: [8] -BUSY\n\
     [7..6] Enable SSM Input..Output flag\n\
     [5..4] ConfSel bits\n\
     [3..3] InOut flag   0:out   1:in\n\
     [2..1] Operation bits \n\
     [0..0] mode bit \n\
error: 0xdeadbeaf\n\
";

Tpardesc setsmssw_parameters[2]={
{"ix", 1},
{"newmode", 3| 0x80000000}};
char setsmssw_usagehelp[]="-------------------------------------------------------------- setsmssw() \n\
set sms[].mode\n\
";

Tpardesc setomSSM_parameters[2]={
{"board", 1},
{"opmo", 2}};
char setomSSM_usagehelp[]="Set operation & mode. If SSM is BUSY, an attempt is made to stop\n\
the recording.\n\
Input parameteres:\n\
board -number of the board (index into global sms array) \n\
       0..NSSMBOARDS    (busy,L0,1,2,int,fo1,2,3,4,5,6,ltu1,2,3,4)\n\
opmo  -mode/operation bit for SSMcommand word. symbolic names \n\
       are defined in ctp.h (as SSMom*)\n\
\n\
opmo for LTU boards:\n\
--------------\n\
0x0 -VME access, read\n\
0x1 -VME access, write\n\
0x2 -RECORDING, After  (cca 26 milsec)\n\
0x3 -RECORDING, Before (should be stopped by SSMstoprec)\n\
\n\
Bit opmo[4] (0x10) should be set to 1 for LTU/RECORDING mode\n\
    (new feature 'FrontPanel->SSM' introduced for LTU 7.10.2005)\n\
    If not set, signals from LTU-FPGA will be recorded.\n\
\n\
opmo for CTP boards:\n\
--------------\n\
The codes above (0-3) are valid, in addition 7 bits (opmo[9..3] are\n\
meaningfull, and 2 more codes are added:\n\
0x4 - GENERATING, single pass\n\
0x5 - GENERATING, continuous\n\
opmo[9..8] - bits to be used for selecting SSMenable word\n\
             10 ->enable Input    01 ->enable Output\n\
opmo[7..6] - not used\n\
opmo[5..4] - ConfSel bits  (defined in \n\
               $VMECFDIR/CFG/ctp/ssmsigs/.sig files)\n\
opmo[3]      - InOut flag   1:in   0:out (side of FPGA logic)\n\
Examples: \n\
0x20d - generate continuously  inputs for board logic\n\
0x20c - generate 1 pass (27ms) inputs for board logic\n\
0x102 - record   1 pass (27ms) of board logic outputs\n\
RC:  0->ok, mode set\n\
     1->mode not set, possible errors (printed to stdout):\n\
        -BC signal not connected\n\
        -Cannot stop recording operation\n\
     2->bad mode for LTU board\n\
";

Tpardesc startSSM1_parameters[1]={
{"board", 1}};
Tpardesc stopSSM_parameters[1]={
{"board", 1}};
char stopSSM_usagehelp[]="------------------------------------------------------- stopSSM()\n\
Opearation:\n\
- check if board is in BUSY status\n\
- stop (recording or generation)\n\
rc: == 0 OK\n\
       1 board not busy, no action\n\
       2 problem with openvme for LTU\n\
";

Tpardesc condstopSSM_parameters[4]={
{"board", 1},
{"cntpos", 1},
{"maxloops", 1},
{"sleepafter", 1}};
char condstopSSM_usagehelp[]="Opearation:\n\
- read counter cntpos\n\
- check 'the change of this counter' + check maxloops\n\
- sleep 'sleepafter' micsecs (should be 0 or at least 100)\n\
- stop (recording or generation) -> call stopSSM()\n\
Inputs:\n\
cntpos: position of the counter (starting from 0) for this board\n\
        see 2. column in dimcdistrib/cnames.sorted2 file\n\
maxloops: max. number of loops (1 loop == cca 2 ms)\n\
rc: == 0 OK\n\
   1 board not busy, no action (i.e. SSM was not started before in\n\
     'BEFORE/continuous' mode)\n\
   2 problem with openvme for LTU\n\
  10 timeout (counter did not change even after 'maxloops' reads)\n\
--------------------- ";

Tpardesc readSSM_parameters[1]={
{"board", 1}};
char readSSM_usagehelp[]="--------------------------------------------------------- readSSM()\n\
read whole SSM into array of unsigned ints\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
Output:\n\
rc:  0 SSM read into sms[board].sm->\n\
       i.e. Mega words were read\n\
    >0 only part of SSM was read into sms[board].sm-> \n\
       reason in After or Before mode:\n\
       - SSM stopped early (<26ms)\n\
";

Tpardesc writeSSM_parameters[1]={
{"board", 1}};
char writeSSM_usagehelp[]="------------------------------------------------------ writeSSM()\n\
write whole sms[].sm into hardware\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
";

Tpardesc dumpSSM_parameters[2]={
{"board", 1},
{"fname", 3| 0x80000000}};
char dumpSSM_usagehelp[]="------------------------------------------------------ dumpSSM()\n\
write whole sms[].sm into hardware\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
continues mode should be treated same as in readSSM\n\
";

Tpardesc dumpssm_parameters[2]={
{"board", 1},
{"fname", 3| 0x80000000}};
char dumpssm_usagehelp[]="Dump computer ssm (not hw ssm)\n\
";

Tpardesc printSSM_parameters[2]={
{"board", 1},
{"fromadr", 1}};
char printSSM_usagehelp[]="print to stdout SSM board from word 'fromadr'\n\
";

Tpardesc readSSMDump_parameters[2]={
{"board", 1},
{"filename", 3| 0x80000000}};
char readSSMDump_usagehelp[]=" Read binary dump written by dumpSSM() to the sms[board].sm\n\
";

Tpardesc setRareFlag_parameters[3]={
{"board", 1},
{"input", 1},
{"mode", 1}};
Tpardesc take1SSM_parameters[2]={
{"board", 1},
{"ntimes", 1}};
char take1SSM_usagehelp[]="------------------------------------------------------------------------------\n\
Record and read 1SSM\n\
";

Tpardesc filter_parameters[2]={
{"sm", 2| 0x80000000},
{"chan", 1}};
Tpardesc takerbSSM_parameters[1]={
{"ntimes", 1}};
char takerbSSM_usagehelp[]="----------------------------------------------------------------------------\n\
Record and read 1SSM\n\
";

Tpardesc take2SSM_parameters[3]={
{"board1", 1},
{"board2", 1},
{"ntimes", 1}};
char take2SSM_usagehelp[]="---------------------------------------------------------------------------------------\n\
Record and read and synchronise 2 SSMs\n\
";

Tpardesc take3SSM_parameters[1]={
{"ntimes", 1}};
char take3SSM_usagehelp[]="To be written. We do not need it untill any L2 inputs exits\n\
";

Tpardesc croscor1_parameters[5]={
{"input1", 1},
{"input2", 1},
{"cordist", 1},
{"delta", 1},
{"dir", 1}};
char croscor1_usagehelp[]="  delta=0 -> autocor fun\n\
  delta=1 -> -1,0,1\n\
";

Tpardesc autocor_parameters[3]={
{"input", 1},
{"cordist", 1},
{"delta", 1}};
char autocor_usagehelp[]="Autocorel one input\n\
cordist>0\n\
";

Tpardesc Correl_parameters[8]={
{"type", 1},
{"l0inputs", 1},
{"l1inputs", 1},
{"l2inputs", 1},
{"h0chans", 1},
{"cordist", 1},
{"delta", 1},
{"dir", 1}};
char Correl_usagehelp[]="Steering routone for correlation:\n\
 type =0 : autocorrelation = noise, bckg\n\
 type =1 : crosscorrelation = alignment\n\
 h0chans = channels in ssm in l0 output mode\n\
";

void gettableSSM();
void getsfSSM(int board);
void getsyncedSSM();
void getsigSSM(int board, int bit, int frombc, int bits);
void finddifSSM(int board, int bit, int frombc);
void getoffsetSSM(int board);
void setoffsetSSM(int board, int newoffset);
void setmodeSSM(int board, char *newmode, char *ltubase);
void printsms();
void dumpCTP();
void getPF(int ix);
void getPFc(int ix, int circ);
void getprtPF(int ix);
void getprtPFc(int ix, int circ);
void setPF(int ix, w32 pfc);
void setPFc(int ix, int circ, w32 A, w32 B, w32 LUT);
void printPFwc(int deltat);
void getShared();
void getSharedL0f34(int lutout);
int setL0f34c(char *m4);
void setSharedL0f34();
void setShared(w32 r1, w32 r2, w32 bs1, w32 bs2, w32 int1, w32 int2, w32 intt, w32 l0fun1, w32 l0fun2);
void setShared2(w32 intsel, w32 allrare);
void loadRun(w32 runnumber);
void printHW();
void unloadRun(w32 runnumber);
void printL0FUN34();
void setL0FUN34(w32 *lut);
int notInCrate(int ix);
int findBUSYINP(int fo, int foc);
w32 getCounter(int board, int reladr);
void getCounters(int N, int accrual);
void clearCounters();
w32 findDeadBusysRuns(int time);
void printLastDetectors(w32 cluster);
void busyprobe(char *det);
w32 findDeadBusys(w32 dets);
int GenSwtrg(int n, char trigtype, int roc, w32 BC, w32 detectors, int customer);
int getCALIBBC2(w32 ctprodets);
int checkScopeBoard(char ab);
int setScopeBoard(char ab, int board);
int getScopeSignal(int board, char ab);
int setScopeSignal(int board, char ab, int signal);
int getVMERWScope();
void setVMERWScope(w32 newv, w32 oldv);
void getSWLEDS(int ixboard);
void setEdge(int board, w32 input, w32 edge);
void setEdgeDelay(int board, int input, int edge, int delay);
void printEdgeDelay(int board);
void getBCmasks();
void setBCmasks();
void checkBCmasks(int ntimes, int words);
void checkPhasesPrint();
void printToggle();
int Toggle(char *det, int onoff);
void resetPLLS();
void ReadPF();
void WritePFcommon(w32 INTa, w32 INTb, w32 Delayed_INT);
void WritePF(w32 icircuit, w32 THa1, w32 THa2, w32 THb1, w32 THb2, int dTa, int dTb, w32 P_signal);
void WritePFuser(w32 icircuit, w32 threshold, w32 bcs);
int WritePFuserII(w32 Ncoll, w32 dT1, w32 dT2, w32 icircuit, w32 plut);
void adcitest(int board);
void scanDel(int micseconds, int board);
void adctimeconst(w32 delay0, w32 delay1, int board);
void rndtest(int board);
void setbcdelay(w32 delay);
w32 getbcstatus(int board);
int setinput(int board, w32 input);
void measureedge();
void setDelay(int board, w32 input, w32 delay);
void getEdge(int board, w32 input);
int measurephase(int board, int input);
void getDetInputStatus(char *Detector, int numofinputs);
void setStatus(char *Detector, int input, char stat);
void checkInputsActivity(int board);
void checkInputsActivityRB();
int SigNum2LVDSTNum(int SigNum);
void CheckSignature(int board, int signature, int input);
void FindSignatures(int board, char *inputs);
void getorbitstatus();
w32 getswSSM(int board);
void setsmssw(int ix, char *newmode);
int setomSSM(int board, w32 opmo);
int startSSM1(int board);
int stopSSM(int board);
int condstopSSM(int board, int cntpos, int maxloops, int sleepafter);
int readSSM(int board);
int writeSSM(int board);
int dumpSSM(int board, char *fname);
int dumpssm(int board, char *fname);
void printSSM(int board, int fromadr);
int readSSMDump(int board, char *filename);
void setRareFlag(int board, int input, int mode);
void initAignment();
void printINPUTS();
void resetINPUTS();
void take1SSM(int board, int ntimes);
void filter(w32 *sm, int chan);
void takerbSSM(int ntimes);
int take2SSM(int board1, int board2, int ntimes);
int take3SSM(int ntimes);
void croscor1(int input1, int input2, int cordist, int delta, int dir);
void autocor(int input, int cordist, int delta);
void Correl(int type, int l0inputs, int l1inputs, int l2inputs, int h0chans, int cordist, int delta, int dir);

int nnames=221;
Tname allnames[MAXNAMES]={
{"SYNCctp", tSYMNAME, NULL, (w32)BoardSpaceLength, 0.0, NULL, (w32)BoardBaseAddress, NULL},
{"CODE_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x4, NULL},
{"SERIAL_NUMBER", tVMEADR, NULL, 0, 0.0, NULL, 0x8, NULL},
{"VERSION_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0xc, NULL},
{"SOFT_RESET", tVMEADR, NULL, 0, 0.0, NULL, 0x28, NULL},
{"TEMP_START", tVMEADR, NULL, 0, 0.0, NULL, 0x58, NULL},
{"TEMP_STATUS", tVMEADR, NULL, 0, 0.0, NULL, 0x5c, NULL},
{"TEMP_READ", tVMEADR, NULL, 0, 0.0, NULL, 0x60, NULL},
{"FPGAVERSION_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x80, NULL},
{"TEST_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x7e0, NULL},
{"BC_STATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xc4, NULL},
{"SSMcommand", tVMEADR, NULL, 0, 0.0, NULL, 0x19c, NULL},
{"SSMstart", tVMEADR, NULL, 0, 0.0, NULL, 0x1a0, NULL},
{"SSMstop", tVMEADR, NULL, 0, 0.0, NULL, 0x1a4, NULL},
{"SSMaddress", tVMEADR, NULL, 0, 0.0, NULL, 0x1a8, NULL},
{"SSMdata", tVMEADR, NULL, 0, 0.0, NULL, 0x1ac, NULL},
{"SSMstatus", tVMEADR, NULL, 0, 0.0, NULL, 0x1b0, NULL},
{"SSMenable", tVMEADR, NULL, 0, 0.0, NULL, 0x1b4, NULL},
{"PLLreset", tVMEADR, NULL, 0, 0.0, NULL, 0x1bc, NULL},
{"ADC_START", tVMEADR, NULL, 0, 0.0, NULL, 0xcc, NULL},
{"ADC_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0xd0, NULL},
{"SOFT_LED", tVMEADR, NULL, 0, 0.0, NULL, 0x15c, NULL},
{"COPYCOUNT", tVMEADR, NULL, 0, 0.0, NULL, 0x1d4, NULL},
{"COPYBUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x1d8, NULL},
{"COPYCLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x1dc, NULL},
{"COPYREAD", tVMEADR, NULL, 0, 0.0, NULL, 0x1e0, NULL},
{"CLEARCOUNTER", tVMEADR, NULL, 0, 0.0, NULL, 0x5ac, NULL},
{"SPY_MEMORY", tVMEADR, NULL, 0, 0.0, NULL, 0x400, NULL},
{"SCOPE_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x4f8, NULL},
{"ADC_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x500, NULL},
{"SYNCH_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x504, NULL},
{"PF_COMMON", tVMEADR, NULL, 0, 0.0, NULL, 0x564, NULL},
{"PFBLOCK_A", tVMEADR, NULL, 0, 0.0, NULL, 0x568, NULL},
{"PFBLOCK_B", tVMEADR, NULL, 0, 0.0, NULL, 0x56c, NULL},
{"PFLUT", tVMEADR, NULL, 0, 0.0, NULL, 0x570, NULL},
{"FO_CLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x240, NULL},
{"FO_TESTCLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x244, NULL},
{"FO_DELAY_L1CLST", tVMEADR, NULL, 0, 0.0, NULL, 0x248, NULL},
{"FO_FILTER_L1", tVMEADR, NULL, 0, 0.0, NULL, 0x84, NULL},
{"BUSY_DELAY_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x84c8, NULL},
{"BUSY_ORBIT_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x80d4, NULL},
{"BUSY_DISB_CTP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x80d8, NULL},
{"BUSYMAX_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x8168, NULL},
{"BUSYMINI_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x816c, NULL},
{"MINIMAX_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x8570, NULL},
{"MINIMAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0x8174, NULL},
{"MINIMAX_LIMIT", tVMEADR, NULL, 0, 0.0, NULL, 0x8578, NULL},
{"BUSYLAST_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x857c, NULL},
{"BUSY_CLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x8600, NULL},
{"BUSY_DAQBUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x861c, NULL},
{"BUSY_L0L1DEADTIME", tVMEADR, NULL, 0, 0.0, NULL, 0x8620, NULL},
{"BUSY_CTPDEADTIME", tVMEADR, NULL, 0, 0.0, NULL, 0x8624, NULL},
{"BUSY_OVERLAP", tVMEADR, NULL, 0, 0.0, NULL, 0x8640, NULL},
{"L0_CLEAR_RND", tVMEADR, NULL, 0, 0.0, NULL, 0x90c8, NULL},
{"L0_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0x91c0, NULL},
{"L0_TCSTART", tVMEADR, NULL, 0, 0.0, NULL, 0x91c4, NULL},
{"L0_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0x91c8, NULL},
{"RATE_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x91cc, NULL},
{"RATE_CLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x91d0, NULL},
{"MASK_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x91e4, NULL},
{"MASK_CLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x91e8, NULL},
{"L0_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0x9400, NULL},
{"L0_CONDITION", tVMEADR, NULL, 0, 0.0, NULL, 0x9400, NULL},
{"L0_VETO", tVMEADR, NULL, 0, 0.0, NULL, 0x9600, NULL},
{"DAQ_LED", tVMEADR, NULL, 0, 0.0, NULL, 0x9600, NULL},
{"L0_MASK", tVMEADR, NULL, 0, 0.0, NULL, 0x9700, NULL},
{"L0_INVERT", tVMEADR, NULL, 0, 0.0, NULL, 0x9500, NULL},
{"L0_INVERTac", tVMEADR, NULL, 0, 0.0, NULL, 0x9800, NULL},
{"L0_INTERACT1", tVMEADR, NULL, 0, 0.0, NULL, 0x94cc, NULL},
{"L0_INTERACT2", tVMEADR, NULL, 0, 0.0, NULL, 0x94d0, NULL},
{"L0_INTERACTT", tVMEADR, NULL, 0, 0.0, NULL, 0x94d4, NULL},
{"L0_INTERACTSEL", tVMEADR, NULL, 0, 0.0, NULL, 0x94d8, NULL},
{"L0_FUNCTION1", tVMEADR, NULL, 0, 0.0, NULL, 0x94dc, NULL},
{"L0_FUNCTION2", tVMEADR, NULL, 0, 0.0, NULL, 0x94e0, NULL},
{"RANDOM_1", tVMEADR, NULL, 0, 0.0, NULL, 0x94e4, NULL},
{"RANDOM_2", tVMEADR, NULL, 0, 0.0, NULL, 0x94e8, NULL},
{"SCALED_1", tVMEADR, NULL, 0, 0.0, NULL, 0x94ec, NULL},
{"SCALED_2", tVMEADR, NULL, 0, 0.0, NULL, 0x94f0, NULL},
{"ALL_RARE_FLAG", tVMEADR, NULL, 0, 0.0, NULL, 0x94f4, NULL},
{"L0_ENA_CRND", tVMEADR, NULL, 0, 0.0, NULL, 0x94fc, NULL},
{"MASK_MODE", tVMEADR, NULL, 0, 0.0, NULL, 0x95a4, NULL},
{"L0_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0x95a8, NULL},
{"RATE_MODE", tVMEADR, NULL, 0, 0.0, NULL, 0x9700, NULL},
{"L0_FUNCTION34", tVMEADR, NULL, 0, 0.0, NULL, 0x97ec, NULL},
{"L1_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xa1c0, NULL},
{"L1_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xa1c8, NULL},
{"L1_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xa400, NULL},
{"L1_DEFINITION", tVMEADR, NULL, 0, 0.0, NULL, 0xa400, NULL},
{"L1_DELAY_L0", tVMEADR, NULL, 0, 0.0, NULL, 0xa4cc, NULL},
{"L1_INVERT", tVMEADR, NULL, 0, 0.0, NULL, 0xa500, NULL},
{"ROIP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0xa600, NULL},
{"L2_DEFINITION", tVMEADR, NULL, 0, 0.0, NULL, 0xb400, NULL},
{"L2_ORBIT_READ", tVMEADR, NULL, 0, 0.0, NULL, 0xb140, NULL},
{"L2_ORBIT_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xb144, NULL},
{"L2_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xb1c0, NULL},
{"L2_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xb1c8, NULL},
{"L2_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xb400, NULL},
{"L2_DELAY_L1", tVMEADR, NULL, 0, 0.0, NULL, 0xb4cc, NULL},
{"L2_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0xb5a8, NULL},
{"INT_ORBIT_READ", tVMEADR, NULL, 0, 0.0, NULL, 0xc140, NULL},
{"INT_MAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xc144, NULL},
{"INT_FIFO_MAX", tVMEADR, NULL, 0, 0.0, NULL, 0xc148, NULL},
{"INT_DDL_EMU", tVMEADR, NULL, 0, 0.0, NULL, 0xc14c, NULL},
{"INT_DISB_CTP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0xc150, NULL},
{"I2C_MUXWR", tVMEADR, NULL, 0, 0.0, NULL, 0xc154, NULL},
{"I2C_MUXRD", tVMEADR, NULL, 0, 0.0, NULL, 0xc158, NULL},
{"I2C_ADCWR", tVMEADR, NULL, 0, 0.0, NULL, 0xc174, NULL},
{"I2C_ADCRD", tVMEADR, NULL, 0, 0.0, NULL, 0xc160, NULL},
{"I2C_SET", tVMEADR, NULL, 0, 0.0, NULL, 0xc164, NULL},
{"I2C_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0xc168, NULL},
{"INT_RC_BLCKMAX", tVMEADR, NULL, 0, 0.0, NULL, 0xc16c, NULL},
{"INT_BLCKMAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xc170, NULL},
{"INT_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xc400, NULL},
{"INT_TEST_COUNT", tVMEADR, NULL, 0, 0.0, NULL, 0xc404, NULL},
{"INT_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0xc5a8, NULL},
{"gettableSSM", tFUN+0x400, (funcall)gettableSSM, 0xdead, 0.0, NULL, 0, gettableSSM_usagehelp},
{"getsfSSM", tFUN+0x400, (funcall)getsfSSM, 0xdead, 0.0, getsfSSM_parameters, 1, getsfSSM_usagehelp},
{"getsyncedSSM", tFUN+0x400, (funcall)getsyncedSSM, 0xdead, 0.0, NULL, 0, getsyncedSSM_usagehelp},
{"getsigSSM", tFUN+0x400, (funcall)getsigSSM, 0xdead, 0.0, getsigSSM_parameters, 4, getsigSSM_usagehelp},
{"finddifSSM", tFUN+0x400, (funcall)finddifSSM, 0xdead, 0.0, finddifSSM_parameters, 3, finddifSSM_usagehelp},
{"getoffsetSSM", tFUN+0x400, (funcall)getoffsetSSM, 0xdead, 0.0, getoffsetSSM_parameters, 1, getoffsetSSM_usagehelp},
{"setoffsetSSM", tFUN+0x400, (funcall)setoffsetSSM, 0xdead, 0.0, setoffsetSSM_parameters, 2, setoffsetSSM_usagehelp},
{"setmodeSSM", tFUN+0x400, (funcall)setmodeSSM, 0xdead, 0.0, setmodeSSM_parameters, 3, setmodeSSM_usagehelp},
{"printsms", tFUN+0x400, (funcall)printsms, 0xdead, 0.0, NULL, 0, printsms_usagehelp},
{"dumpCTP", tFUN+0x400, (funcall)dumpCTP, 0xdead, 0.0, NULL, 0, dumpCTP_usagehelp},
{"getPF", tFUN+0x400, (funcall)getPF, 0xdead, 0.0, getPF_parameters, 1, getPF_usagehelp},
{"getPFc", tFUN+0x400, (funcall)getPFc, 0xdead, 0.0, getPFc_parameters, 2, getPFc_usagehelp},
{"getprtPF", tFUN+0x400, (funcall)getprtPF, 0xdead, 0.0, getprtPF_parameters, 1, getprtPF_usagehelp},
{"getprtPFc", tFUN+0x400, (funcall)getprtPFc, 0xdead, 0.0, getprtPFc_parameters, 2, getprtPFc_usagehelp},
{"setPF", tFUN+0x400, (funcall)setPF, 0xdead, 0.0, setPF_parameters, 2, setPF_usagehelp},
{"setPFc", tFUN+0x400, (funcall)setPFc, 0xdead, 0.0, setPFc_parameters, 5, setPFc_usagehelp},
{"printPFwc", tFUN+0x400, (funcall)printPFwc, 0xdead, 0.0, printPFwc_parameters, 1, printPFwc_usagehelp},
{"getShared", tFUN+0x400, (funcall)getShared, 0xdead, 0.0, NULL, 0, getShared_usagehelp},
{"getSharedL0f34", tFUN+0x400, (funcall)getSharedL0f34, 0xdead, 0.0, getSharedL0f34_parameters, 1, getSharedL0f34_usagehelp},
{"setL0f34c", tFUN+0x200, (funcall)setL0f34c, 0xdead, 0.0, setL0f34c_parameters, 1, NULL},
{"setSharedL0f34", tFUN+0x400, (funcall)setSharedL0f34, 0xdead, 0.0, NULL, 0, setSharedL0f34_usagehelp},
{"setShared", tFUN+0x400, (funcall)setShared, 0xdead, 0.0, setShared_parameters, 9, setShared_usagehelp},
{"setShared2", tFUN+0x400, (funcall)setShared2, 0xdead, 0.0, setShared2_parameters, 2, setShared2_usagehelp},
{"loadRun", tFUN+0x400, (funcall)loadRun, 0xdead, 0.0, loadRun_parameters, 1, loadRun_usagehelp},
{"printHW", tFUN+0x400, (funcall)printHW, 0xdead, 0.0, NULL, 0, printHW_usagehelp},
{"unloadRun", tFUN+0x400, (funcall)unloadRun, 0xdead, 0.0, unloadRun_parameters, 1, NULL},
{"printL0FUN34", tFUN+0x400, (funcall)printL0FUN34, 0xdead, 0.0, NULL, 0, NULL},
{"setL0FUN34", tFUN+0x400, (funcall)setL0FUN34, 0xdead, 0.0, setL0FUN34_parameters, 1, NULL},
{"notInCrate", tFUN+0x200, (funcall)notInCrate, 0xdead, 0.0, notInCrate_parameters, 1, NULL},
{"findBUSYINP", tFUN+0x200, (funcall)findBUSYINP, 0xdead, 0.0, findBUSYINP_parameters, 2, NULL},
{"getCounter", tFUN+0x100, (funcall)getCounter, 0xdead, 0.0, getCounter_parameters, 2, NULL},
{"getCounters", tFUN+0x400, (funcall)getCounters, 0xdead, 0.0, getCounters_parameters, 2, NULL},
{"clearCounters", tFUN+0x400, (funcall)clearCounters, 0xdead, 0.0, NULL, 0, NULL},
{"findDeadBusysRuns", tFUN+0x100, (funcall)findDeadBusysRuns, 0xdead, 0.0, findDeadBusysRuns_parameters, 1, findDeadBusysRuns_usagehelp},
{"printLastDetectors", tFUN+0x400, (funcall)printLastDetectors, 0xdead, 0.0, printLastDetectors_parameters, 1, printLastDetectors_usagehelp},
{"busyprobe", tFUN+0x400, (funcall)busyprobe, 0xdead, 0.0, busyprobe_parameters, 1, busyprobe_usagehelp},
{"findDeadBusys", tFUN+0x100, (funcall)findDeadBusys, 0xdead, 0.0, findDeadBusys_parameters, 1, findDeadBusys_usagehelp},
{"GenSwtrg", tFUN+0x200, (funcall)GenSwtrg, 0xdead, 0.0, GenSwtrg_parameters, 6, NULL},
{"getCALIBBC2", tFUN+0x200, (funcall)getCALIBBC2, 0xdead, 0.0, getCALIBBC2_parameters, 1, NULL},
{"checkScopeBoard", tFUN+0x200, (funcall)checkScopeBoard, 0xdead, 0.0, checkScopeBoard_parameters, 1, NULL},
{"setScopeBoard", tFUN+0x200, (funcall)setScopeBoard, 0xdead, 0.0, setScopeBoard_parameters, 2, NULL},
{"getScopeSignal", tFUN+0x200, (funcall)getScopeSignal, 0xdead, 0.0, getScopeSignal_parameters, 2, NULL},
{"setScopeSignal", tFUN+0x200, (funcall)setScopeSignal, 0xdead, 0.0, setScopeSignal_parameters, 3, NULL},
{"getVMERWScope", tFUN+0x200, (funcall)getVMERWScope, 0xdead, 0.0, NULL, 0, NULL},
{"setVMERWScope", tFUN+0x400, (funcall)setVMERWScope, 0xdead, 0.0, setVMERWScope_parameters, 2, NULL},
{"getSWLEDS", tFUN+0x400, (funcall)getSWLEDS, 0xdead, 0.0, getSWLEDS_parameters, 1, getSWLEDS_usagehelp},
{"setEdge", tFUN+0x400, (funcall)setEdge, 0xdead, 0.0, setEdge_parameters, 3, setEdge_usagehelp},
{"setEdgeDelay", tFUN+0x400, (funcall)setEdgeDelay, 0xdead, 0.0, setEdgeDelay_parameters, 4, setEdgeDelay_usagehelp},
{"printEdgeDelay", tFUN+0x400, (funcall)printEdgeDelay, 0xdead, 0.0, printEdgeDelay_parameters, 1, printEdgeDelay_usagehelp},
{"getBCmasks", tFUN+0x400, (funcall)getBCmasks, 0xdead, 0.0, NULL, 0, getBCmasks_usagehelp},
{"setBCmasks", tFUN+0x400, (funcall)setBCmasks, 0xdead, 0.0, NULL, 0, setBCmasks_usagehelp},
{"checkBCmasks", tFUN+0x400, (funcall)checkBCmasks, 0xdead, 0.0, checkBCmasks_parameters, 2, checkBCmasks_usagehelp},
{"checkPhasesPrint", tFUN+0x400, (funcall)checkPhasesPrint, 0xdead, 0.0, NULL, 0, checkPhasesPrint_usagehelp},
{"printToggle", tFUN+0x400, (funcall)printToggle, 0xdead, 0.0, NULL, 0, NULL},
{"Toggle", tFUN+0x200, (funcall)Toggle, 0xdead, 0.0, Toggle_parameters, 2, NULL},
{"resetPLLS", tFUN+0x400, (funcall)resetPLLS, 0xdead, 0.0, NULL, 0, resetPLLS_usagehelp},
{"ReadPF", tFUN+0x400, (funcall)ReadPF, 0xdead, 0.0, NULL, 0, NULL},
{"WritePFcommon", tFUN+0x400, (funcall)WritePFcommon, 0xdead, 0.0, WritePFcommon_parameters, 3, NULL},
{"WritePF", tFUN+0x400, (funcall)WritePF, 0xdead, 0.0, WritePF_parameters, 8, NULL},
{"WritePFuser", tFUN+0x400, (funcall)WritePFuser, 0xdead, 0.0, WritePFuser_parameters, 3, WritePFuser_usagehelp},
{"WritePFuserII", tFUN+0x200, (funcall)WritePFuserII, 0xdead, 0.0, WritePFuserII_parameters, 5, NULL},
{"SSMbrowser", tFUN, NULL, 0xdead, 0.0, NULL, 0, SSMbrowser_usagehelp},
{"INPUTS", tFUN, NULL, 0xdead, 0.0, NULL, 0, INPUTS_usagehelp},
{"adcitest", tFUN+0x400, (funcall)adcitest, 0xdead, 0.0, adcitest_parameters, 1, adcitest_usagehelp},
{"scanDel", tFUN+0x400, (funcall)scanDel, 0xdead, 0.0, scanDel_parameters, 2, scanDel_usagehelp},
{"adctimeconst", tFUN+0x400, (funcall)adctimeconst, 0xdead, 0.0, adctimeconst_parameters, 3, adctimeconst_usagehelp},
{"rndtest", tFUN+0x400, (funcall)rndtest, 0xdead, 0.0, rndtest_parameters, 1, rndtest_usagehelp},
{"setbcdelay", tFUN+0x400, (funcall)setbcdelay, 0xdead, 0.0, setbcdelay_parameters, 1, NULL},
{"getbcstatus", tFUN+0x100, (funcall)getbcstatus, 0xdead, 0.0, getbcstatus_parameters, 1, getbcstatus_usagehelp},
{"setinput", tFUN+0x200, (funcall)setinput, 0xdead, 0.0, setinput_parameters, 2, setinput_usagehelp},
{"measureedge", tFUN+0x400, (funcall)measureedge, 0xdead, 0.0, NULL, 0, measureedge_usagehelp},
{"setDelay", tFUN+0x400, (funcall)setDelay, 0xdead, 0.0, setDelay_parameters, 3, NULL},
{"getEdge", tFUN+0x400, (funcall)getEdge, 0xdead, 0.0, getEdge_parameters, 2, NULL},
{"measurephase", tFUN+0x200, (funcall)measurephase, 0xdead, 0.0, measurephase_parameters, 2, measurephase_usagehelp},
{"getDetInputStatus", tFUN+0x400, (funcall)getDetInputStatus, 0xdead, 0.0, getDetInputStatus_parameters, 2, getDetInputStatus_usagehelp},
{"setStatus", tFUN+0x400, (funcall)setStatus, 0xdead, 0.0, setStatus_parameters, 3, setStatus_usagehelp},
{"checkInputsActivity", tFUN+0x400, (funcall)checkInputsActivity, 0xdead, 0.0, checkInputsActivity_parameters, 1, checkInputsActivity_usagehelp},
{"checkInputsActivityRB", tFUN+0x400, (funcall)checkInputsActivityRB, 0xdead, 0.0, NULL, 0, checkInputsActivityRB_usagehelp},
{"SigNum2LVDSTNum", tFUN+0x200, (funcall)SigNum2LVDSTNum, 0xdead, 0.0, SigNum2LVDSTNum_parameters, 1, SigNum2LVDSTNum_usagehelp},
{"CheckSignature", tFUN+0x400, (funcall)CheckSignature, 0xdead, 0.0, CheckSignature_parameters, 3, CheckSignature_usagehelp},
{"FindSignatures", tFUN+0x400, (funcall)FindSignatures, 0xdead, 0.0, FindSignatures_parameters, 2, FindSignatures_usagehelp},
{"getorbitstatus", tFUN+0x400, (funcall)getorbitstatus, 0xdead, 0.0, NULL, 0, NULL},
{"getswSSM", tFUN+0x100, (funcall)getswSSM, 0xdead, 0.0, getswSSM_parameters, 1, getswSSM_usagehelp},
{"setsmssw", tFUN+0x400, (funcall)setsmssw, 0xdead, 0.0, setsmssw_parameters, 2, setsmssw_usagehelp},
{"setomSSM", tFUN+0x200, (funcall)setomSSM, 0xdead, 0.0, setomSSM_parameters, 2, setomSSM_usagehelp},
{"startSSM1", tFUN+0x200, (funcall)startSSM1, 0xdead, 0.0, startSSM1_parameters, 1, NULL},
{"stopSSM", tFUN+0x200, (funcall)stopSSM, 0xdead, 0.0, stopSSM_parameters, 1, stopSSM_usagehelp},
{"condstopSSM", tFUN+0x200, (funcall)condstopSSM, 0xdead, 0.0, condstopSSM_parameters, 4, condstopSSM_usagehelp},
{"readSSM", tFUN+0x200, (funcall)readSSM, 0xdead, 0.0, readSSM_parameters, 1, readSSM_usagehelp},
{"writeSSM", tFUN+0x200, (funcall)writeSSM, 0xdead, 0.0, writeSSM_parameters, 1, writeSSM_usagehelp},
{"dumpSSM", tFUN+0x200, (funcall)dumpSSM, 0xdead, 0.0, dumpSSM_parameters, 2, dumpSSM_usagehelp},
{"dumpssm", tFUN+0x200, (funcall)dumpssm, 0xdead, 0.0, dumpssm_parameters, 2, dumpssm_usagehelp},
{"printSSM", tFUN+0x400, (funcall)printSSM, 0xdead, 0.0, printSSM_parameters, 2, printSSM_usagehelp},
{"readSSMDump", tFUN+0x200, (funcall)readSSMDump, 0xdead, 0.0, readSSMDump_parameters, 2, readSSMDump_usagehelp},
{"setRareFlag", tFUN+0x400, (funcall)setRareFlag, 0xdead, 0.0, setRareFlag_parameters, 3, NULL},
{"initAignment", tFUN+0x400, (funcall)initAignment, 0xdead, 0.0, NULL, 0, NULL},
{"printINPUTS", tFUN+0x400, (funcall)printINPUTS, 0xdead, 0.0, NULL, 0, NULL},
{"resetINPUTS", tFUN+0x400, (funcall)resetINPUTS, 0xdead, 0.0, NULL, 0, NULL},
{"take1SSM", tFUN+0x400, (funcall)take1SSM, 0xdead, 0.0, take1SSM_parameters, 2, take1SSM_usagehelp},
{"filter", tFUN+0x400, (funcall)filter, 0xdead, 0.0, filter_parameters, 2, NULL},
{"takerbSSM", tFUN+0x400, (funcall)takerbSSM, 0xdead, 0.0, takerbSSM_parameters, 1, takerbSSM_usagehelp},
{"take2SSM", tFUN+0x200, (funcall)take2SSM, 0xdead, 0.0, take2SSM_parameters, 3, take2SSM_usagehelp},
{"take3SSM", tFUN+0x200, (funcall)take3SSM, 0xdead, 0.0, take3SSM_parameters, 1, take3SSM_usagehelp},
{"croscor1", tFUN+0x400, (funcall)croscor1, 0xdead, 0.0, croscor1_parameters, 5, croscor1_usagehelp},
{"autocor", tFUN+0x400, (funcall)autocor, 0xdead, 0.0, autocor_parameters, 3, autocor_usagehelp},
{"Correl", tFUN+0x400, (funcall)Correl, 0xdead, 0.0, Correl_parameters, 8, Correl_usagehelp}};
