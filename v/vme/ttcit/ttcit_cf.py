self.baseAddr="0x8a0000"
self.spaceLength="0x300"
self.vmeregs=[('VERSION_NUMBER', '0x4', ''), ('TTCIT_CONTROL', '0x8', ''), ('TTCIT_STATUS', '0xc', ''), ('RESET_TTCRX', '0x10', ''), ('VME_CONTROL_VERS', '0x3c', ''), ('READ_ADDR_COUNT', '0x14', ''), ('READ_SNAPSHOT', '0x18', ''), ('RESET', '0x28', ''), ('BCNT_TTCRX', '0x1c', ''), ('N_BCNT_TTCRX', '0x20', ''), ('RESET_SNAPSHOT_N', '0x8c', ''), ('CONFIG_START', '0x2c', ''), ('FLASHADD_CLEAR', '0x30', ''), ('FLASHACCESS_INCR', '0x34', ''), ('FLASHACCESS_NOINCR', '0x38', ''), ('HW_TIME_L0_L1', '0x24', ''), ('HW_RESET_COUNTERS', '0x40', ''), ('HW_COUNTER_L0', '0x44', ''), ('HW_COUNTER_L1', '0x48', ''), ('HW_COUNTER_L1M', '0x4c', ''), ('HW_COUNTER_L2A', '0x50', ''), ('HW_COUNTER_L2R', '0x54', ''), ('HW_COUNT_ERR_PP', '0x58', ''), ('HW_COUNT_ERR_L0S', '0x5c', ''), ('HW_COUNT_ERR_L1S', '0x60', ''), ('HW_COUNT_ERR_L1MM', '0x64', ''), ('HW_COUNT_ERR_L1MS', '0x68', ''), ('HW_COUNT_ERR_L1MI', '0x6c', ''), ('HW_COUNT_ERR_L1MD', '0x70', ''), ('HW_COUNT_ERR_L2MM', '0x74', ''), ('HW_COUNT_ERR_L2MS', '0x78', ''), ('HW_COUNT_ERR_L2MI', '0x7c', ''), ('HW_COUNT_ERR_L2MD', '0x80', ''), ('HW_COUNT_ERR_CAL', '0x84', ''), ('HW_COUNT_ERR_BCNT', '0x88', ''), ('SCOPE_SELECTED_A', '0x90', ''), ('SCOPE_SELECTED_B', '0x94', ''), ('SERIAL_NUMBER', '0x98', ''), ('HW_DELAY_SSM_STOP', '0x9c', ''), ('HW_BCNT_DIFFERENCE', '0xa0', ''), ('HW_PP_COUNTER', '0xa4', '')]
self.hiddenfuncs=""
self.funcs=[['Configuration', 'Initialize TTCit board\n', 'void', 'TTCITinit', []], ['VMEcontroller', '  Get the version of the FPGA code\n ', 'int', 'FPGAcodeVersion', []], ['VMEcontroller', 'Get Board Serial Number \n', 'int', 'GetSerialNumber', []], ['Reset', 'Reset TTCRx chip\n', 'int', 'TTCRxReset', []], ['Reset', 'Reset TTCIT logic\n', 'int', 'ResetTTCit', []], ['FrontPanel', '  Clear all counters:   Reset all memory counters to 0\n                        Reset all OM counters\n                        SM counters are not resettable\n ', 'void', 'clearCounters', []], ['FrontPanel', '  Sets the scope signals for A, B oscilloscope channels\n ', 'void', 'ScopeSelect_AB', [['A', 'int', ''], ['B', 'int', '']]], ['FrontPanel', '  Gets the current settings for A and B scope signals\n\n  how =  0  Return 100*A + B\n         1  Return\n\t 2  Print 100*A + B\n ', 'void', 'ScopeGet_AB', [['how', 'int', '']]], ['OnBoard_Monitor', '  Resets the TTCit board, keeps all OM setting intact\n ', 'void', 'OM_Reset', []], ['OnBoard_Monitor', '  Activate OM and start collecting data\n', 'void', 'OM_ON_Start', []], ['OnBoard_Monitor', '  Deactivate OM, stop it if collecting data\n', 'void', 'OM_OFF', []], ['OnBoard_Monitor', '  Show the status of the OM\n', 'void', 'OM_Status', []], ['OnBoard_Monitor', '  Prints the status of the SSM, whether it is reading data or stopped and \n  available for read. To be used only with the other functions of the Online\n  Monitor.\n', 'void', 'OM_PrintStatusSSM', []], ['OnBoard_Monitor', '  Sets the error mask for the OM. Set nonzero value for each error\n  that is to be watched. When this error is detected the data collection\n  stops and the SSM can be fetched and its contents analyzed.\n\n  Error conditions related to messages: L1m, L2m\n', 'void', 'OM_SetErrorMask_msg', [['L1M_missing', 'int', ''], ['L1M_spurious', 'int', ''], ['L1M_incomplete', 'int', ''], ['L1M_data_error', 'int', ''], ['L2M_missing', 'int', ''], ['L2M_spurious', 'int', ''], ['L2M_incomplete', 'int', ''], ['L2M_data_error', 'int', '']]], ['OnBoard_Monitor', '  Sets the error mask for the OM. Set nonzero value for each error\n  that is to be watched. When this error is detected the data collection\n  stops and the SSM can be fetched and its contents analyzed.\n\n  Error conditions related to signals: L0, L1, Calibration, BC\n', 'void', 'OM_SetErrorMask_sig', [['PP', 'int', ''], ['L0S', 'int', ''], ['L1S', 'int', ''], ['CAL_error', 'int', ''], ['BCNT_diff', 'int', '']]], ['OnBoard_Monitor', '  Show the Error mask set\n', 'void', 'OM_ShowErrorMask', []], ['OnBoard_Monitor', '  Clear the Error mask, i.e. unset all error stop conditions.\n', 'void', 'OM_ClearErrorMask', []], ['OnBoard_Monitor', '  Save the currently set error mask for later use. The current error mask \n  is stored only in memory.\n', 'void', 'OM_SaveErrorMask', []], ['OnBoard_Monitor', ' Set the saved error mask (useful after TTCit Reset). The saved Error mask\n is kept in the computer memory.\n', 'void', 'OM_ReloadLastErrorMask', []], ['OnBoard_Monitor', '  Set time between L0 - L1 in BC clocks\n', 'void', 'OM_SetTimeL0_L1', [['t', 'int', '']]], ['OnBoard_Monitor', '  Print the contents of all hardware counters - trigger and errors.\n', 'void', 'OM_ShowCounters', []], ['OnBoard_Monitor', '  Reset all hardware counters.\n', 'void', 'OM_ResetCounters', []], ['OnBoard_Monitor', ' Print the contents of the TRIGGER counters (L0, L1, L1m, L2m)\n', 'void', 'OM_TriggerCounters', []], ['OnBoard_Monitor', '  Print the contents of the ERROR counters\n', 'void', 'OM_ErrorCounters', []], ['OnBoard_Monitor', '  Show the errors detected by the OM after STOP\n', 'void', 'OM_Detected_Errors', []], ['OnBoard_Monitor', '  After stopping of the OM the contents of the SSM is fetched and dumped.\n', 'void', 'OM_FetchSSM_Dump', []], ['OnBoard_Monitor', '  After stopping of the OM the contents of the SSM is fetched and analyzed.\n ', 'void', 'OM_FetchSSM_Analyze', []], ['OnBoard_Monitor', '  Makes error masks and settings of the OM as equivalent to those of the \n  SSM analyzer and SSM Software monitor as possible.\n  Saves the need to set basicaly the same constants  twice.\n\n  how  = 0 copy the settings from OM to SSM analyz/Soft Monitor\n         1 copy the settings from SSM analyz/Soft Monitor to OM\n ', 'void', 'OM_ErrMaskSync', [['how', 'int', '']]], ['OnBoard_Monitor', '  Dump the contents of the SSM after On-Line Monitor stopped after an error\n  condition. Does CombinedFetchAndDump() when the OM is not running.\n\n  Its argument specifies how much minutes we are wanting to wait before \n  forcing the OM to stop accumulating data.\n', 'void', 'OM_SSM_DumpAfterStop', [['minutes', 'int', '']]], ['OnBoard_Monitor', '  Applies software SSM analyzer to the contents of the SSM before the occurence\n  of the error condition leading to a stop.\n\n  Its argument specifies how much minutes we are wanting to wait before\n  forcing OM to stop accumulating data.\n', 'void', 'OM_SSM_AnalyzeAfterStop', [['minutes', 'int', '']]], ['OnBoard_Monitor', '  Sets the number of BCs during which the SSM is written into after\n  an error detection (0 means stop on error)\n ', 'void', 'OM_SetDelayedSSMstop', [['dt', 'int', '']]], ['OnBoard_Monitor', '  Gets the value of the delay for SSM write after error detection\n ', 'int', 'OM_GetDelayedSSMstop', []], ['SnapShot', '  Reads and prints SSM address counter and Nr. of words in BC fifo\n', 'void', 'RA', []], ['SSM_analyz', '  Specify, how the L0 signal is sent to TTCit board:\n\n  t == 0   Not present (L0 is not sent to TTCit at all)\n       \n       1   L0 is sent over A channel\n\n       2   L0 is sent over wire\n\n       3   L0 is sent over wire and A channel (if possible)\n\n       4   Unknown. We shall try to read a couple of snapshots and determine\n           absence/presence of L0. Its absence will NOT be considered an\n\t   error!\n ', 'void', 'L0signal', [['t', 'int', '']]], ['SoftMONITOR', '  Start software monitor:  \n\n  A soft Monitor run in split in Loops in which SSM and BC fifo is read.\n  During one loop the SSM is set to SCOPE mode and read nSCOPE times. \n  Then it is set to SEQ mode and read nSEQ times. \n  The whole process repeats nLoops times (or indefinitely to be stopped\n  from StopMONITOR function. \n\n  use SetStopConditionNSEQ(...) if you want to loop only limited nr. of times\n      SetStopConditions(...)    if you want to stop on selected errors\n      SetNEVERstop()            if you want to loop indefinitely\n\n  use StopMONITOR()             to stop looping at any moment \n\n ', 'int', 'StartMONITOR', []], ['FrontPanel', '  Reads all Counters (Soft Monitor and On-Line monitor) and prints them\n  in a standard way: \n\n  ordering of counters must correspond with that in ttcit_u.py\n  TTCITcnts = {...}\n\n  NCNTS  = Number of counters to be read + 1\n  accrual == 1 return differences (actual - previos value)\n          != 1 return actual values\n\n ', 'void', 'getCounters', [['NCNTS', 'int', ''], ['difval', 'int', '']]], ['Debug', 'Read the last Snap Shot memory word\n', 'int', 'ReadLastSSM', []], ['Debug', "  Print contents of the SSM from address 'begin' till address 'end'\n  with zero suppression (only words that are 0x0 are not printed\n\n  Since there is 1 MB the full SSM dump is to be avoided\n ", 'void', 'RawDumpSSM', [['begin', 'int', ''], ['end', 'int', '']]], ['SnapShot', '  Clears the ON-BOARD Snap Shot Memory (SSM) i.e. write Zeroes to the SSM.\n ', 'void', 'ClearSSM', []], ['SnapShot', 'Clear the SSM buffer in MEMORY\n', 'void', 'ClearSSMemoryBuffer', []], ['SnapShot', 'Get the number of words in the SSM software buffer\n ', 'int', 'GetNrSSMwords', []], ['SelectDump', '  Hexadecimal and binary dump of the SSM contents. Starts from the 1-st\n  recorded event and dumps as many events as set by SelDumpN(n)\n ', 'void', 'HexBinDump', []], ['SelectDump', '  Hexadecimal and binary dumo of the SSM contents. Starts where the last\n  dump via HexBinDump() or HexBinDumpNext() ended. Continuation print.\n ', 'void', 'HexBinDumpNext', []], ['SelectDump', '  Human readable dump (works only with firmware version >= 24). What to\n  print can be selected using SelDumpOptions(...), how many events to print\n  is set by SelDumpN(n).\n ', 'int', 'SelDump', []], ['SelectDump', '  Resets TTCit, waits till SSM is full, fetches data and prints \n  the first N words in hex/binary form\n ', 'int', 'SelFetchHexBinDump', []], ['SelectDump', '  Resets TTCit, waits until the SSM is full, fetches SSM from TTCit board,\n  and prints the first N recorded events (selected print available using\n  SelDumOptions(...)).\n ', 'int', 'SelFetchDump', []], ['SelectDump', '  Continuation dump. Prints next N (set by SelDumpN()) events from SSM,\n  starting where the last print using SelDump(), SelDumpNext(), \n  or SelFetchDump() stopped.\n ', 'int', 'SelDumpNext', []], ['SelectDump', '  Set SSM dumping options. 0 = disable option\n                           1 = enable it\n  Orbit     : print Orbit reset commands\n  TTC_A     : print all traffic from the TTC A channel (L0, L1 accept)\n  TTC_B     : print all traffic from the TTC B channel (L1M, L2a, L2r...)\n  L0_LVDS   : print L0 signals sent over LVDS cable\n  PP        : print PP signals\n  TTCrx     : print information/data from the TTCrx chip\n  EventType : print exact signature of SSM event\n ', 'void', 'SelDumpOptions', [['Orbit', 'int', ''], ['TTC_A', 'int', ''], ['TTC_B', 'int', ''], ['L0_LVDS', 'int', ''], ['PP', 'int', ''], ['TTCrx', 'int', ''], ['EventType', 'int', '']]], ['SelectDump', '  Prints options for the SelDump, SelDumpNext, SelFetchDump, HexBinDump,\n  HexBinDumpNext.\n ', 'void', 'SelPrintDumpOpt', []], ['SelectDump', '  Set how many events stored in the SSM are to be printed at the same time\n  (the number of SSM events is quite large so set this number not too high,\n  otherwise the output became unmanageable)\n\n  0 == print ALL SSM events (not recommended, use at your own risk)\n ', 'int', 'SelDumpN', [['howmany', 'int', '']]], ['SelectDump', '  Set the max allowed timeout in seconds for combined fetch_and_dumps\n\n  Time_s   = max allowed timeout in seconds\n ', 'void', 'SelDumpTimeouts', [['Time_s', 'int', '']]], ['SelectDump', '  Allows to set the first event in the dump, where you want to start your \n  print. The Sel mask is to be given as OR for all events that are to be used\n  as a starting point.\n  This selection affects ALL dumping routines, even  SelDumpNext(), if the \n  dump should continue where the last print stopped, you must deselect\n  1-st event option:\n\n  Sel = 0x1      L0\n\t0x2      L0 over wire\n\t0x4      L1\n\t0x8      Orbit\n\t0x10     L1m\n\t0x20     L2a\n\t0x40     L2r\n\t0x80     PP\n', 'void', 'SelDump1stEvent', [['Sel', 'int', '']]], ['SelectDump', '  Set the first dumped event type mask in a more user friendly way.\n\n  Nonzero value = select\n  Zero          = do not select\n\n  If you want to disable the 1-st dumped event selection\n  use SelDump1stEvent(0xff);\n ', 'void', 'SelDump1stMenu', [['L0', 'int', ''], ['L0_LVDS', 'int', ''], ['L1', 'int', ''], ['Orbit', 'int', ''], ['L1m', 'int', ''], ['L2a', 'int', ''], ['L2r', 'int', ''], ['PP', 'int', '']]], ['SelectDump', '  Sets L0 signal source - cable or fibre. Proper knowledge of this\n  is needed to interpret the signals in TTC A channel (L0/L1)\n\n  OverFibre  = 1 if L0 is sent over fibre or over both wire and fibre\n               0 if L0 is not sent over TTC A channel (fibre)\n ', 'void', 'SelDumpL0', [['OverFibre', 'int', '']]], ['SelectDump', '  Resests the default values (Print all, start at any event\n ', 'void', 'SelDumpDefaults', []], ['SelectDump', ' ', 'void', 'SelDumpCountSSM', []], ['SelectDump', '  Select the position of the 1-st event to be printed\n\n  The N-th event matching the 1-st event mask wil be printed in the \n  following call to HexBinDumpNext(), SelDumpNext().\n\n  This is meant as a help in browsing the large Snap Shot.\n\n  N = 0           the 1-st event \n      1 .. MAX    i-th event (events are numbered from 1 to max)\n                  if i > Max nr. of events stored in SSM then the last\n                  event matching 1-st event criteria is chosen\n      If you waht to see tha last occurence of event accorfing to the\n      1-st event mask, run SelDumpCountSSM(), see how many of them is\n      in the snapshot and select some bigger number.\n\n    return: 0    on success\n           -1    if no event satisfy the 1-st event selection criteria\n ', 'int', 'SelDumpSetEvent', [['N', 'int', '']]], ['Debug', 'Get number of words stored in Bunch Crossing TTCRx FIFO\n ', 'int', 'GetNbcntFIFO', []], ['Debug', 'Read the whole bunch crossing FIFO, stora data in memory\n ', 'int', 'FetchBcntFIFO', []], ['SoftMONITOR', 'Stops the running soft MONITOR loop. Does nothing if nothing is looping.\n ', 'void', 'StopMONITOR', []], ['SoftMONITOR', '  Shows status of the software monitor (running status, nr. of loops \n  completed etc...)\n\n  Returns:    0xA     MONITOR is RUNNING\n              0xB                STOPPING, transition to stopped state\n              0xC                STOPPED\n\n              0xBAD  is a BUG, call experts\n ', 'int', 'StatusMONITOR', []], ['SoftMONITOR', '  Read the stored file (created during a soft MONITOR run) and reanalyze it.\n  To be used when one first looks at the errors that happen (maybe not very\n  often) and then wants to investigate them one by one. \n\n  Opens the file, reads, reached a stop condition-stops, closes file\n\n  To use this function, you must first run: WriteFile_ON()\n                                            StartMONITOR()\n', 'void', 'Rescan', []], ['SoftMONITOR', '  Read the stored file (created during a soft MONITOR run) and reanalyze it.\n  To be used when one first looks at the errors that happen (maybe not very\n  often) and then wants to investigate them one by one. \n\n  Opens the file, reads, reached a stop condition-stops, leaves the file opened\n  for subsequent reads\n\n  To use this function, you must first run: WriteFile_ON()\n                                            StartMONITOR()\n ', 'void', 'RescanLeave', []], ['SoftMONITOR', '  Read the stored file (created during a soft MONITOR run) and reanalyze it.\n  To be used when one first looks at the errors that happen (maybe not very\n  often) and then wants to investigate them one by one. \n\n  Reads already opened file, reached a stop condition-stops, leaves the file\n  opened\n\n  To use this function, you must first run: WriteFile_ON()\n                                            StartMONITOR()\n ', 'void', 'RecsanCont', []], ['SoftMONITOR', '  Ask MONITOR to write a file to be inspected later\n ', 'void', 'WriteFile_ON', []], ['SoftMONITOR', '  Ask MONITOR not to write any file\n ', 'void', 'WriteFile_OFF', []], ['SoftMONITOR', '  Ask MONITOR to perform on-line diagnostics\n ', 'void', 'OnlineDiag_ON', []], ['SoftMONITOR', '  Ask MONITOR not to perform on-line diagnostics (if a file is written the\n  same diagnostics can be performed off-line later)\n ', 'void', 'OnlineDiag_OFF', []], ['SoftMONITOR', '  Show the current MONITOR options \n ', 'void', 'ShowMONITORoptions', []], ['SoftMONITOR', '  Set stopping conditions for the Sotfware MONITOR :  ERRORS \n\n  If the MONITOR is to be stopped ad given error set argument to 1\n  if the error is to be not used as stopping point set 0\n ', 'void', 'SetStopCondition', [['Stop_at_L0S', 'int', ''], ['Stop_at_L1S', 'int', ''], ['Stop_at_L1T', 'int', ''], ['Stop_at_L1M', 'int', ''], ['Stop_at_L1Mo', 'int', ''], ['Stop_at_L1F', 'int', ''], ['Stop_at_L2T', 'int', ''], ['Stop_at_L2Ts', 'int', ''], ['Stop_at_L2F', 'int', ''], ['Stop_at_BCID_diff', 'int', '']]], ['SoftMONITOR', '  Stop Software MONITOR at ANY error\n ', 'void', 'SetStopAnyError', []], ['SoftMONITOR', 'Stop Software monitor after reading NSEQ sequences (Snap shots)\n ', 'void', 'SetStopConditionNSEQ', [['NSEQ', 'int', '']]], ['SoftMONITOR', '  Clear STOP conditions, after this the Software MONITOR never stops and\n  must be stopped manually\n ', 'void', 'SetNEVERstop', []], ['SoftMONITOR', '  Prints the actual Stopping conditions for Software MONITOR\n ', 'void', 'ShowStopConditions', []], ['SSM_analyz', '  Resets the SSM analyzer to default values, clears all counters\n ', 'void', 'ResetSSManalyzer', []], ['SSM_analyz', '  Shows the contents of the trigger counters (as seen by SSM analyzer)\n ', 'void', 'ShowCounters', []], ['SSM_analyz', '  Show the contents of the error counters (as seen by SSM analyzer)\n ', 'void', 'ShowErrors', []], ['SSM_analyz', '  Show the timing infor as calculated by SSM analyzer\n ', 'void', 'ShowTiming', []], ['SSM_analyz', '  Defines the software time windows used in definition of some trigger \n  errors\n\n  All time value are given in 26ns ticks\n\n  Setting half width to 0 turns intervals into single fixed numbers\n\n  L0_L1_window      = centre of the L0-L1 decision interval\n\n  L0_L1_width       = half width of the L0-L1 decision interval \n\n  L1_timeout        = timout for L1m from L1 signal, after this time \n                      the L1m is assumed to be missing\n\n  L1_L2_timeout     = timout for L2a header or L2r, after this time the \n                      L2a/L2r is assumed to be missing\n\n  L1_L2_BCID_window = centre of the window in which the difference in \n                      BCID from TTC Rx at the arrival of L1 signal and the \n\t\t      BCID value found in L2a/L2r must be found. If not, \n\t\t      an error is signalled\n\n  L1_L2_BCID_width  = half width of the BCID window.\n ', 'void', 'SetTimeWindows', [['L0_L1_window', 'int', ''], ['L0_L1_width', 'int', ''], ['L1m_timeout', 'int', ''], ['L1_L2_timeout', 'int', ''], ['L1_L2_BCID_window', 'int', ''], ['L1_L2_BCID_width', 'int', ''], ['L1_RoI_timeout', 'int', '']]], ['SSM_analyz', '  Set the Bunch crossing during which the PrePulse is sent and set limiting\n  BC that can be used to mark old L2 i.e. those L2 which follow L0-L1-L1m\n  that has not been recorded in SSM (because of ResetTTCit came after sending\n  the L0-L1-L1m) when those originated in the orbit preceding the one \n  recorded in SSM\n\n  BC_PP        = bunch crossing during which the PrePulse is sent\n  BC_old_L2    = old L2 bunch crossing boundary (this value must be tuned)\n  BC_new_L2    = new L0-L1 orbit last BC boundary\n ', 'void', 'SetBCconst', [['BC_PP', 'int', ''], ['BC_old_L2', 'int', ''], ['BC_new_L2', 'int', '']]], ['SSM_analyz', '  Set the default values of the time windows used in definitions of some\n  trigger errors\n ', 'void', 'DefaultTimeWindows', []], ['SSM_analyz', '  Shows the actual values of the time windows used in definitions of some \n  trigger errors.\n ', 'void', 'ShowTimeWindows', []], ['SSM_analyz', '  Quick look at the activity on the optical line. Combines the following \n  actions:\n\n  1) ResetTTCit                 : Start reading one SSM\n  2) wail till SSM gets filled \n  3) FetchSSM\n  4) FetchBcntFIFO\n  5) perform analyzis on one Snap Shot\n  6) print error count\n  7) dump the SSM with indication of error occurence\n ', 'void', 'AnalyzeOneSnapShot', []], ['SSM_analyz', '  Analyze N snap shots, stop at 1-st error\n ', 'void', 'AnalyzeN', [['n', 'int', '']]], ['SSM_analyz', '  Tries to analyze SSM snapshots and in those where NO ERRORS are present\n  the BCID differences are evaluated and histogrammed. Snapshots with errors\n  are ignored.\n\n  This is supposed to work independently of bugs in TTCit soft logic\n ', 'void', 'BcidMismatch', [['n', 'int', '']]], ['Debug', '  Print the contents of the BC Fifo (only differing words are printed\n  nw = number of words you want to print (0 == all)\n ', 'void', 'PrintBcntFIFO', [['nw', 'int', '']]], [None, '  Counters for On-Line Monitor (OM) and Software Snap-shot Monitor (SM)\n ', 'GUI', 'TTCitCounters', [], 'TTCitCounters'], [None, '  Scope signal selection A/B\n ', 'GUI', 'Scope_Signals', [], 'Scope_Signals'], ['Debug', '  Test fetching SSM \n ', 'void', 'TestFetchSSM', []], ['Debug', 'Get board type\n', 'int', 'GetBoardType', []], ['Debug', 'Get VME comtroller version\n', 'int', 'GetVMEContVersion', []], ['Debug', '  n        = number of SSM fetches\n  nretries = number of dummy loops before each retry (D=100)\n ', 'void', 'LoopTestSSM', [['n', 'int', ''], ['nretries', 'int', '']]], ['Debug', 'Returns SS.top\n ', 'int', 'SS_top', []], ['Debug', '  Get next word from the BC fifo\n ', 'int', 'GetWordBCfifo', []], ['Debug', '  Print Internal state of the TTCIT software logic\n ', 'void', 'PrintTTCITLogic', []], ['Debug', '  Read a part of the MONITOR file and dump its contents as HEX and DEC\n  It is to be used for debug only\n\n  nwords   = number of words to be read and dumped\n ', 'void', 'DumpWrittenData', [['nwords', 'int', '']]], ['Debug', '  Dump the contents on the ttcit_monitor.dat as TTCit events. It is used\n  for debugging the I/O operations. This call may produce HUGE output.\n ', 'void', 'DumpFileEvents', []], ['Debug', '  Debugging tool for manual command clearCounters()\n ', 'void', 'GUI_ClearCounters', []], ['Debug', '  Debugging tool for manual command getCounters(N,difval)\n ', 'void', 'GUI_GetCounters', [['difval', 'int', '']]], ['Debug', '  Test of the ClearSSM function\n ', 'void', 'DBG_TestClearSSM', []], ['Debug', '  Activate OM but do not start collecting data\n', 'void', 'OM_ON_nostart', []], ['Configuration', '  Reads the file <ttcit_fpga_code> - link to the actual file - , \n  write it into the Flash Memory, Read it back and compare with the \n  read original. If all bytes agree return 0 otherwise <> 0.\n ', 'int', 'WriteCodeFM', []], ['Configuration', '  Load FPGA configuration from the Flash Memory. Returns 0 if nothing wrong\n  happened\n ', 'int', 'LoadFPGA', []], ['Debug', ' ', 'void', 'dummyDebugStop', []]]
