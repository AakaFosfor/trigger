/* generated by comp.py */
#include <stdio.h>
#include "vmewrap.h"
#include "lexan.h"
#include "vmeaistd.h"

char BoardName[]="ttcit";
char BoardBaseAddress[11]="0x8a0000";
char BoardSpaceLength[11]="0x300";
char BoardSpaceAddmod[11]="A24";
char TTCITinit_usagehelp[]="Initialize TTCit board\n\
";

char FPGAcodeVersion_usagehelp[]="  Get the version of the FPGA code\n\
 ";

char GetSerialNumber_usagehelp[]="Get Board Serial Number \n\
";

char TTCRxReset_usagehelp[]="Reset TTCRx chip\n\
";

char ResetTTCit_usagehelp[]="Reset TTCIT logic\n\
";

char clearCounters_usagehelp[]="  Clear all counters:   Reset all memory counters to 0\n\
                        Reset all OM counters\n\
                        SM counters are not resettable\n\
 ";

Tpardesc ScopeSelect_AB_parameters[2]={
{"A", 1},
{"B", 1}};
char ScopeSelect_AB_usagehelp[]="  Sets the scope signals for A, B oscilloscope channels\n\
 ";

Tpardesc ScopeGet_AB_parameters[1]={
{"how", 1}};
char ScopeGet_AB_usagehelp[]="  Gets the current settings for A and B scope signals\n\
\n\
  how =  0  Return 100*A + B\n\
         1  Return\n\
	 2  Print 100*A + B\n\
 ";

char OM_Reset_usagehelp[]="  Resets the TTCit board, keeps all OM setting intact\n\
 ";

char OM_ON_Start_usagehelp[]="  Activate OM and start collecting data\n\
";

char OM_OFF_usagehelp[]="  Deactivate OM, stop it if collecting data\n\
";

char OM_Status_usagehelp[]="  Show the status of the OM\n\
";

char OM_PrintStatusSSM_usagehelp[]="  Prints the status of the SSM, whether it is reading data or stopped and \n\
  available for read. To be used only with the other functions of the Online\n\
  Monitor.\n\
";

Tpardesc OM_SetErrorMask_msg_parameters[8]={
{"L1M_missing", 1},
{"L1M_spurious", 1},
{"L1M_incomplete", 1},
{"L1M_data_error", 1},
{"L2M_missing", 1},
{"L2M_spurious", 1},
{"L2M_incomplete", 1},
{"L2M_data_error", 1}};
char OM_SetErrorMask_msg_usagehelp[]="  Sets the error mask for the OM. Set nonzero value for each error\n\
  that is to be watched. When this error is detected the data collection\n\
  stops and the SSM can be fetched and its contents analyzed.\n\
\n\
  Error conditions related to messages: L1m, L2m\n\
";

Tpardesc OM_SetErrorMask_sig_parameters[5]={
{"PP", 1},
{"L0S", 1},
{"L1S", 1},
{"CAL_error", 1},
{"BCNT_diff", 1}};
char OM_SetErrorMask_sig_usagehelp[]="  Sets the error mask for the OM. Set nonzero value for each error\n\
  that is to be watched. When this error is detected the data collection\n\
  stops and the SSM can be fetched and its contents analyzed.\n\
\n\
  Error conditions related to signals: L0, L1, Calibration, BC\n\
";

char OM_ShowErrorMask_usagehelp[]="  Show the Error mask set\n\
";

char OM_ClearErrorMask_usagehelp[]="  Clear the Error mask, i.e. unset all error stop conditions.\n\
";

char OM_SaveErrorMask_usagehelp[]="  Save the currently set error mask for later use. The current error mask \n\
  is stored only in memory.\n\
";

char OM_ReloadLastErrorMask_usagehelp[]=" Set the saved error mask (useful after TTCit Reset). The saved Error mask\n\
 is kept in the computer memory.\n\
";

Tpardesc OM_SetTimeL0_L1_parameters[1]={
{"t", 1}};
char OM_SetTimeL0_L1_usagehelp[]="  Set time between L0 - L1 in BC clocks\n\
";

char OM_ShowCounters_usagehelp[]="  Print the contents of all hardware counters - trigger and errors.\n\
";

char OM_ResetCounters_usagehelp[]="  Reset all hardware counters.\n\
";

char OM_TriggerCounters_usagehelp[]=" Print the contents of the TRIGGER counters (L0, L1, L1m, L2m)\n\
";

char OM_ErrorCounters_usagehelp[]="  Print the contents of the ERROR counters\n\
";

char OM_Detected_Errors_usagehelp[]="  Show the errors detected by the OM after STOP\n\
";

char OM_FetchSSM_Dump_usagehelp[]="  After stopping of the OM the contents of the SSM is fetched and dumped.\n\
";

char OM_FetchSSM_Analyze_usagehelp[]="  After stopping of the OM the contents of the SSM is fetched and analyzed.\n\
 ";

Tpardesc OM_ErrMaskSync_parameters[1]={
{"how", 1}};
char OM_ErrMaskSync_usagehelp[]="  Makes error masks and settings of the OM as equivalent to those of the \n\
  SSM analyzer and SSM Software monitor as possible.\n\
  Saves the need to set basicaly the same constants  twice.\n\
\n\
  how  = 0 copy the settings from OM to SSM analyz/Soft Monitor\n\
         1 copy the settings from SSM analyz/Soft Monitor to OM\n\
 ";

Tpardesc OM_SSM_DumpAfterStop_parameters[1]={
{"minutes", 1}};
char OM_SSM_DumpAfterStop_usagehelp[]="  Dump the contents of the SSM after On-Line Monitor stopped after an error\n\
  condition. Does CombinedFetchAndDump() when the OM is not running.\n\
\n\
  Its argument specifies how much minutes we are wanting to wait before \n\
  forcing the OM to stop accumulating data.\n\
";

Tpardesc OM_SSM_AnalyzeAfterStop_parameters[1]={
{"minutes", 1}};
char OM_SSM_AnalyzeAfterStop_usagehelp[]="  Applies software SSM analyzer to the contents of the SSM before the occurence\n\
  of the error condition leading to a stop.\n\
\n\
  Its argument specifies how much minutes we are wanting to wait before\n\
  forcing OM to stop accumulating data.\n\
";

Tpardesc OM_SetDelayedSSMstop_parameters[1]={
{"dt", 1}};
char OM_SetDelayedSSMstop_usagehelp[]="  Sets the number of BCs during which the SSM is written into after\n\
  an error detection (0 means stop on error)\n\
 ";

char OM_GetDelayedSSMstop_usagehelp[]="  Gets the value of the delay for SSM write after error detection\n\
 ";

char RA_usagehelp[]="  Reads and prints SSM address counter and Nr. of words in BC fifo\n\
";

Tpardesc L0signal_parameters[1]={
{"t", 1}};
char L0signal_usagehelp[]="  Specify, how the L0 signal is sent to TTCit board:\n\
\n\
  t == 0   Not present (L0 is not sent to TTCit at all)\n\
       \n\
       1   L0 is sent over A channel\n\
\n\
       2   L0 is sent over wire\n\
\n\
       3   L0 is sent over wire and A channel (if possible)\n\
\n\
       4   Unknown. We shall try to read a couple of snapshots and determine\n\
           absence/presence of L0. Its absence will NOT be considered an\n\
	   error!\n\
 ";

char StartMONITOR_usagehelp[]="  Start software monitor:  \n\
\n\
  A soft Monitor run in split in Loops in which SSM and BC fifo is read.\n\
  During one loop the SSM is set to SCOPE mode and read nSCOPE times. \n\
  Then it is set to SEQ mode and read nSEQ times. \n\
  The whole process repeats nLoops times (or indefinitely to be stopped\n\
  from StopMONITOR function. \n\
\n\
  use SetStopConditionNSEQ(...) if you want to loop only limited nr. of times\n\
      SetStopConditions(...)    if you want to stop on selected errors\n\
      SetNEVERstop()            if you want to loop indefinitely\n\
\n\
  use StopMONITOR()             to stop looping at any moment \n\
\n\
 ";

Tpardesc getCounters_parameters[2]={
{"NCNTS", 1},
{"difval", 1}};
char getCounters_usagehelp[]="  Reads all Counters (Soft Monitor and On-Line monitor) and prints them\n\
  in a standard way: \n\
\n\
  ordering of counters must correspond with that in ttcit_u.py\n\
  TTCITcnts = {...}\n\
\n\
  NCNTS  = Number of counters to be read + 1\n\
  accrual == 1 return differences (actual - previos value)\n\
          != 1 return actual values\n\
\n\
 ";

char ReadLastSSM_usagehelp[]="Read the last Snap Shot memory word\n\
";

Tpardesc RawDumpSSM_parameters[2]={
{"begin", 1},
{"end", 1}};
char RawDumpSSM_usagehelp[]="  Print contents of the SSM from address 'begin' till address 'end'\n\
  with zero suppression (only words that are 0x0 are not printed\n\
\n\
  Since there is 1 MB the full SSM dump is to be avoided\n\
 ";

char ClearSSM_usagehelp[]="  Clears the ON-BOARD Snap Shot Memory (SSM) i.e. write Zeroes to the SSM.\n\
 ";

char ClearSSMemoryBuffer_usagehelp[]="Clear the SSM buffer in MEMORY\n\
";

char GetNrSSMwords_usagehelp[]="Get the number of words in the SSM software buffer\n\
 ";

char HexBinDump_usagehelp[]="  Hexadecimal and binary dump of the SSM contents. Starts from the 1-st\n\
  recorded event and dumps as many events as set by SelDumpN(n)\n\
 ";

char HexBinDumpNext_usagehelp[]="  Hexadecimal and binary dumo of the SSM contents. Starts where the last\n\
  dump via HexBinDump() or HexBinDumpNext() ended. Continuation print.\n\
 ";

char SelDump_usagehelp[]="  Human readable dump (works only with firmware version >= 24). What to\n\
  print can be selected using SelDumpOptions(...), how many events to print\n\
  is set by SelDumpN(n).\n\
 ";

char SelFetchHexBinDump_usagehelp[]="  Resets TTCit, waits till SSM is full, fetches data and prints \n\
  the first N words in hex/binary form\n\
 ";

char SelFetchDump_usagehelp[]="  Resets TTCit, waits until the SSM is full, fetches SSM from TTCit board,\n\
  and prints the first N recorded events (selected print available using\n\
  SelDumOptions(...)).\n\
 ";

char SelDumpNext_usagehelp[]="  Continuation dump. Prints next N (set by SelDumpN()) events from SSM,\n\
  starting where the last print using SelDump(), SelDumpNext(), \n\
  or SelFetchDump() stopped.\n\
 ";

Tpardesc SelDumpOptions_parameters[7]={
{"Orbit", 1},
{"TTC_A", 1},
{"TTC_B", 1},
{"L0_LVDS", 1},
{"PP", 1},
{"TTCrx", 1},
{"EventType", 1}};
char SelDumpOptions_usagehelp[]="  Set SSM dumping options. 0 = disable option\n\
                           1 = enable it\n\
  Orbit     : print Orbit reset commands\n\
  TTC_A     : print all traffic from the TTC A channel (L0, L1 accept)\n\
  TTC_B     : print all traffic from the TTC B channel (L1M, L2a, L2r...)\n\
  L0_LVDS   : print L0 signals sent over LVDS cable\n\
  PP        : print PP signals\n\
  TTCrx     : print information/data from the TTCrx chip\n\
  EventType : print exact signature of SSM event\n\
 ";

char SelPrintDumpOpt_usagehelp[]="  Prints options for the SelDump, SelDumpNext, SelFetchDump, HexBinDump,\n\
  HexBinDumpNext.\n\
 ";

Tpardesc SelDumpN_parameters[1]={
{"howmany", 1}};
char SelDumpN_usagehelp[]="  Set how many events stored in the SSM are to be printed at the same time\n\
  (the number of SSM events is quite large so set this number not too high,\n\
  otherwise the output became unmanageable)\n\
\n\
  0 == print ALL SSM events (not recommended, use at your own risk)\n\
 ";

Tpardesc SelDumpTimeouts_parameters[1]={
{"Time_s", 1}};
char SelDumpTimeouts_usagehelp[]="  Set the max allowed timeout in seconds for combined fetch_and_dumps\n\
\n\
  Time_s   = max allowed timeout in seconds\n\
 ";

Tpardesc SelDump1stEvent_parameters[1]={
{"Sel", 1}};
char SelDump1stEvent_usagehelp[]="  Allows to set the first event in the dump, where you want to start your \n\
  print. The Sel mask is to be given as OR for all events that are to be used\n\
  as a starting point.\n\
  This selection affects ALL dumping routines, even  SelDumpNext(), if the \n\
  dump should continue where the last print stopped, you must deselect\n\
  1-st event option:\n\
\n\
  Sel = 0x1      L0\n\
	0x2      L0 over wire\n\
	0x4      L1\n\
	0x8      Orbit\n\
	0x10     L1m\n\
	0x20     L2a\n\
	0x40     L2r\n\
	0x80     PP\n\
";

Tpardesc SelDump1stMenu_parameters[8]={
{"L0", 1},
{"L0_LVDS", 1},
{"L1", 1},
{"Orbit", 1},
{"L1m", 1},
{"L2a", 1},
{"L2r", 1},
{"PP", 1}};
char SelDump1stMenu_usagehelp[]="  Set the first dumped event type mask in a more user friendly way.\n\
\n\
  Nonzero value = select\n\
  Zero          = do not select\n\
\n\
  If you want to disable the 1-st dumped event selection\n\
  use SelDump1stEvent(0xff);\n\
 ";

Tpardesc SelDumpL0_parameters[1]={
{"OverFibre", 1}};
char SelDumpL0_usagehelp[]="  Sets L0 signal source - cable or fibre. Proper knowledge of this\n\
  is needed to interpret the signals in TTC A channel (L0/L1)\n\
\n\
  OverFibre  = 1 if L0 is sent over fibre or over both wire and fibre\n\
               0 if L0 is not sent over TTC A channel (fibre)\n\
 ";

char SelDumpDefaults_usagehelp[]="  Resests the default values (Print all, start at any event\n\
 ";

char SelDumpCountSSM_usagehelp[]=" ";

Tpardesc SelDumpSetEvent_parameters[1]={
{"N", 1}};
char SelDumpSetEvent_usagehelp[]="  Select the position of the 1-st event to be printed\n\
\n\
  The N-th event matching the 1-st event mask wil be printed in the \n\
  following call to HexBinDumpNext(), SelDumpNext().\n\
\n\
  This is meant as a help in browsing the large Snap Shot.\n\
\n\
  N = 0           the 1-st event \n\
      1 .. MAX    i-th event (events are numbered from 1 to max)\n\
                  if i > Max nr. of events stored in SSM then the last\n\
                  event matching 1-st event criteria is chosen\n\
      If you waht to see tha last occurence of event accorfing to the\n\
      1-st event mask, run SelDumpCountSSM(), see how many of them is\n\
      in the snapshot and select some bigger number.\n\
\n\
    return: 0    on success\n\
           -1    if no event satisfy the 1-st event selection criteria\n\
 ";

char GetNbcntFIFO_usagehelp[]="Get number of words stored in Bunch Crossing TTCRx FIFO\n\
 ";

char FetchBcntFIFO_usagehelp[]="Read the whole bunch crossing FIFO, stora data in memory\n\
 ";

char StopMONITOR_usagehelp[]="Stops the running soft MONITOR loop. Does nothing if nothing is looping.\n\
 ";

char StatusMONITOR_usagehelp[]="  Shows status of the software monitor (running status, nr. of loops \n\
  completed etc...)\n\
\n\
  Returns:    0xA     MONITOR is RUNNING\n\
              0xB                STOPPING, transition to stopped state\n\
              0xC                STOPPED\n\
\n\
              0xBAD  is a BUG, call experts\n\
 ";

char Rescan_usagehelp[]="  Read the stored file (created during a soft MONITOR run) and reanalyze it.\n\
  To be used when one first looks at the errors that happen (maybe not very\n\
  often) and then wants to investigate them one by one. \n\
\n\
  Opens the file, reads, reached a stop condition-stops, closes file\n\
\n\
  To use this function, you must first run: WriteFile_ON()\n\
                                            StartMONITOR()\n\
";

char RescanLeave_usagehelp[]="  Read the stored file (created during a soft MONITOR run) and reanalyze it.\n\
  To be used when one first looks at the errors that happen (maybe not very\n\
  often) and then wants to investigate them one by one. \n\
\n\
  Opens the file, reads, reached a stop condition-stops, leaves the file opened\n\
  for subsequent reads\n\
\n\
  To use this function, you must first run: WriteFile_ON()\n\
                                            StartMONITOR()\n\
 ";

char RecsanCont_usagehelp[]="  Read the stored file (created during a soft MONITOR run) and reanalyze it.\n\
  To be used when one first looks at the errors that happen (maybe not very\n\
  often) and then wants to investigate them one by one. \n\
\n\
  Reads already opened file, reached a stop condition-stops, leaves the file\n\
  opened\n\
\n\
  To use this function, you must first run: WriteFile_ON()\n\
                                            StartMONITOR()\n\
 ";

char WriteFile_ON_usagehelp[]="  Ask MONITOR to write a file to be inspected later\n\
 ";

char WriteFile_OFF_usagehelp[]="  Ask MONITOR not to write any file\n\
 ";

char OnlineDiag_ON_usagehelp[]="  Ask MONITOR to perform on-line diagnostics\n\
 ";

char OnlineDiag_OFF_usagehelp[]="  Ask MONITOR not to perform on-line diagnostics (if a file is written the\n\
  same diagnostics can be performed off-line later)\n\
 ";

char ShowMONITORoptions_usagehelp[]="  Show the current MONITOR options \n\
 ";

Tpardesc SetStopCondition_parameters[10]={
{"Stop_at_L0S", 1},
{"Stop_at_L1S", 1},
{"Stop_at_L1T", 1},
{"Stop_at_L1M", 1},
{"Stop_at_L1Mo", 1},
{"Stop_at_L1F", 1},
{"Stop_at_L2T", 1},
{"Stop_at_L2Ts", 1},
{"Stop_at_L2F", 1},
{"Stop_at_BCID_diff", 1}};
char SetStopCondition_usagehelp[]="  Set stopping conditions for the Sotfware MONITOR :  ERRORS \n\
\n\
  If the MONITOR is to be stopped ad given error set argument to 1\n\
  if the error is to be not used as stopping point set 0\n\
 ";

char SetStopAnyError_usagehelp[]="  Stop Software MONITOR at ANY error\n\
 ";

Tpardesc SetStopConditionNSEQ_parameters[1]={
{"NSEQ", 1}};
char SetStopConditionNSEQ_usagehelp[]="Stop Software monitor after reading NSEQ sequences (Snap shots)\n\
 ";

char SetNEVERstop_usagehelp[]="  Clear STOP conditions, after this the Software MONITOR never stops and\n\
  must be stopped manually\n\
 ";

char ShowStopConditions_usagehelp[]="  Prints the actual Stopping conditions for Software MONITOR\n\
 ";

char ResetSSManalyzer_usagehelp[]="  Resets the SSM analyzer to default values, clears all counters\n\
 ";

char ShowCounters_usagehelp[]="  Shows the contents of the trigger counters (as seen by SSM analyzer)\n\
 ";

char ShowErrors_usagehelp[]="  Show the contents of the error counters (as seen by SSM analyzer)\n\
 ";

char ShowTiming_usagehelp[]="  Show the timing infor as calculated by SSM analyzer\n\
 ";

Tpardesc SetTimeWindows_parameters[7]={
{"L0_L1_window", 1},
{"L0_L1_width", 1},
{"L1m_timeout", 1},
{"L1_L2_timeout", 1},
{"L1_L2_BCID_window", 1},
{"L1_L2_BCID_width", 1},
{"L1_RoI_timeout", 1}};
char SetTimeWindows_usagehelp[]="  Defines the software time windows used in definition of some trigger \n\
  errors\n\
\n\
  All time value are given in 26ns ticks\n\
\n\
  Setting half width to 0 turns intervals into single fixed numbers\n\
\n\
  L0_L1_window      = centre of the L0-L1 decision interval\n\
\n\
  L0_L1_width       = half width of the L0-L1 decision interval \n\
\n\
  L1_timeout        = timout for L1m from L1 signal, after this time \n\
                      the L1m is assumed to be missing\n\
\n\
  L1_L2_timeout     = timout for L2a header or L2r, after this time the \n\
                      L2a/L2r is assumed to be missing\n\
\n\
  L1_L2_BCID_window = centre of the window in which the difference in \n\
                      BCID from TTC Rx at the arrival of L1 signal and the \n\
		      BCID value found in L2a/L2r must be found. If not, \n\
		      an error is signalled\n\
\n\
  L1_L2_BCID_width  = half width of the BCID window.\n\
 ";

Tpardesc SetBCconst_parameters[3]={
{"BC_PP", 1},
{"BC_old_L2", 1},
{"BC_new_L2", 1}};
char SetBCconst_usagehelp[]="  Set the Bunch crossing during which the PrePulse is sent and set limiting\n\
  BC that can be used to mark old L2 i.e. those L2 which follow L0-L1-L1m\n\
  that has not been recorded in SSM (because of ResetTTCit came after sending\n\
  the L0-L1-L1m) when those originated in the orbit preceding the one \n\
  recorded in SSM\n\
\n\
  BC_PP        = bunch crossing during which the PrePulse is sent\n\
  BC_old_L2    = old L2 bunch crossing boundary (this value must be tuned)\n\
  BC_new_L2    = new L0-L1 orbit last BC boundary\n\
 ";

char DefaultTimeWindows_usagehelp[]="  Set the default values of the time windows used in definitions of some\n\
  trigger errors\n\
 ";

char ShowTimeWindows_usagehelp[]="  Shows the actual values of the time windows used in definitions of some \n\
  trigger errors.\n\
 ";

char AnalyzeOneSnapShot_usagehelp[]="  Quick look at the activity on the optical line. Combines the following \n\
  actions:\n\
\n\
  1) ResetTTCit                 : Start reading one SSM\n\
  2) wail till SSM gets filled \n\
  3) FetchSSM\n\
  4) FetchBcntFIFO\n\
  5) perform analyzis on one Snap Shot\n\
  6) print error count\n\
  7) dump the SSM with indication of error occurence\n\
 ";

Tpardesc AnalyzeN_parameters[1]={
{"n", 1}};
char AnalyzeN_usagehelp[]="  Analyze N snap shots, stop at 1-st error\n\
 ";

Tpardesc BcidMismatch_parameters[1]={
{"n", 1}};
char BcidMismatch_usagehelp[]="  Tries to analyze SSM snapshots and in those where NO ERRORS are present\n\
  the BCID differences are evaluated and histogrammed. Snapshots with errors\n\
  are ignored.\n\
\n\
  This is supposed to work independently of bugs in TTCit soft logic\n\
 ";

Tpardesc PrintBcntFIFO_parameters[1]={
{"nw", 1}};
char PrintBcntFIFO_usagehelp[]="  Print the contents of the BC Fifo (only differing words are printed\n\
  nw = number of words you want to print (0 == all)\n\
 ";

char TTCitCounters_usagehelp[]="  Counters for On-Line Monitor (OM) and Software Snap-shot Monitor (SM)\n\
 ";

char Scope_Signals_usagehelp[]="  Scope signal selection A/B\n\
 ";

char TestFetchSSM_usagehelp[]="  Test fetching SSM \n\
 ";

char GetBoardType_usagehelp[]="Get board type\n\
";

char GetVMEContVersion_usagehelp[]="Get VME comtroller version\n\
";

Tpardesc LoopTestSSM_parameters[2]={
{"n", 1},
{"nretries", 1}};
char LoopTestSSM_usagehelp[]="  n        = number of SSM fetches\n\
  nretries = number of dummy loops before each retry (D=100)\n\
 ";

char SS_top_usagehelp[]="Returns SS.top\n\
 ";

char GetWordBCfifo_usagehelp[]="  Get next word from the BC fifo\n\
 ";

char PrintTTCITLogic_usagehelp[]="  Print Internal state of the TTCIT software logic\n\
 ";

Tpardesc DumpWrittenData_parameters[1]={
{"nwords", 1}};
char DumpWrittenData_usagehelp[]="  Read a part of the MONITOR file and dump its contents as HEX and DEC\n\
  It is to be used for debug only\n\
\n\
  nwords   = number of words to be read and dumped\n\
 ";

char DumpFileEvents_usagehelp[]="  Dump the contents on the ttcit_monitor.dat as TTCit events. It is used\n\
  for debugging the I/O operations. This call may produce HUGE output.\n\
 ";

char GUI_ClearCounters_usagehelp[]="  Debugging tool for manual command clearCounters()\n\
 ";

Tpardesc GUI_GetCounters_parameters[1]={
{"difval", 1}};
char GUI_GetCounters_usagehelp[]="  Debugging tool for manual command getCounters(N,difval)\n\
 ";

char DBG_TestClearSSM_usagehelp[]="  Test of the ClearSSM function\n\
 ";

char OM_ON_nostart_usagehelp[]="  Activate OM but do not start collecting data\n\
";

char WriteCodeFM_usagehelp[]="  Reads the file <ttcit_fpga_code> - link to the actual file - , \n\
  write it into the Flash Memory, Read it back and compare with the \n\
  read original. If all bytes agree return 0 otherwise <> 0.\n\
 ";

char LoadFPGA_usagehelp[]="  Load FPGA configuration from the Flash Memory. Returns 0 if nothing wrong\n\
  happened\n\
 ";

char dummyDebugStop_usagehelp[]=" ";

void TTCITinit();
int FPGAcodeVersion();
int GetSerialNumber();
int TTCRxReset();
int ResetTTCit();
void clearCounters();
void ScopeSelect_AB(int A, int B);
void ScopeGet_AB(int how);
void OM_Reset();
void OM_ON_Start();
void OM_OFF();
void OM_Status();
void OM_PrintStatusSSM();
void OM_SetErrorMask_msg(int L1M_missing, int L1M_spurious, int L1M_incomplete, int L1M_data_error, int L2M_missing, int L2M_spurious, int L2M_incomplete, int L2M_data_error);
void OM_SetErrorMask_sig(int PP, int L0S, int L1S, int CAL_error, int BCNT_diff);
void OM_ShowErrorMask();
void OM_ClearErrorMask();
void OM_SaveErrorMask();
void OM_ReloadLastErrorMask();
void OM_SetTimeL0_L1(int t);
void OM_ShowCounters();
void OM_ResetCounters();
void OM_TriggerCounters();
void OM_ErrorCounters();
void OM_Detected_Errors();
void OM_FetchSSM_Dump();
void OM_FetchSSM_Analyze();
void OM_ErrMaskSync(int how);
void OM_SSM_DumpAfterStop(int minutes);
void OM_SSM_AnalyzeAfterStop(int minutes);
void OM_SetDelayedSSMstop(int dt);
int OM_GetDelayedSSMstop();
void RA();
void L0signal(int t);
int StartMONITOR();
void getCounters(int NCNTS, int difval);
int ReadLastSSM();
void RawDumpSSM(int begin, int end);
void ClearSSM();
void ClearSSMemoryBuffer();
int GetNrSSMwords();
void HexBinDump();
void HexBinDumpNext();
int SelDump();
int SelFetchHexBinDump();
int SelFetchDump();
int SelDumpNext();
void SelDumpOptions(int Orbit, int TTC_A, int TTC_B, int L0_LVDS, int PP, int TTCrx, int EventType);
void SelPrintDumpOpt();
int SelDumpN(int howmany);
void SelDumpTimeouts(int Time_s);
void SelDump1stEvent(int Sel);
void SelDump1stMenu(int L0, int L0_LVDS, int L1, int Orbit, int L1m, int L2a, int L2r, int PP);
void SelDumpL0(int OverFibre);
void SelDumpDefaults();
void SelDumpCountSSM();
int SelDumpSetEvent(int N);
int GetNbcntFIFO();
int FetchBcntFIFO();
void StopMONITOR();
int StatusMONITOR();
void Rescan();
void RescanLeave();
void RecsanCont();
void WriteFile_ON();
void WriteFile_OFF();
void OnlineDiag_ON();
void OnlineDiag_OFF();
void ShowMONITORoptions();
void SetStopCondition(int Stop_at_L0S, int Stop_at_L1S, int Stop_at_L1T, int Stop_at_L1M, int Stop_at_L1Mo, int Stop_at_L1F, int Stop_at_L2T, int Stop_at_L2Ts, int Stop_at_L2F, int Stop_at_BCID_diff);
void SetStopAnyError();
void SetStopConditionNSEQ(int NSEQ);
void SetNEVERstop();
void ShowStopConditions();
void ResetSSManalyzer();
void ShowCounters();
void ShowErrors();
void ShowTiming();
void SetTimeWindows(int L0_L1_window, int L0_L1_width, int L1m_timeout, int L1_L2_timeout, int L1_L2_BCID_window, int L1_L2_BCID_width, int L1_RoI_timeout);
void SetBCconst(int BC_PP, int BC_old_L2, int BC_new_L2);
void DefaultTimeWindows();
void ShowTimeWindows();
void AnalyzeOneSnapShot();
void AnalyzeN(int n);
void BcidMismatch(int n);
void PrintBcntFIFO(int nw);
void TestFetchSSM();
int GetBoardType();
int GetVMEContVersion();
void LoopTestSSM(int n, int nretries);
int SS_top();
int GetWordBCfifo();
void PrintTTCITLogic();
void DumpWrittenData(int nwords);
void DumpFileEvents();
void GUI_ClearCounters();
void GUI_GetCounters(int difval);
void DBG_TestClearSSM();
void OM_ON_nostart();
int WriteCodeFM();
int LoadFPGA();
void dummyDebugStop();

int nnames=146;
Tname allnames[MAXNAMES]={
{"ttcit", tSYMNAME, NULL, (w32)BoardSpaceLength, 0.0, NULL, (w32)BoardBaseAddress, NULL},
{"VERSION_NUMBER", tVMEADR, NULL, 0, 0.0, NULL, 0x4, NULL},
{"TTCIT_CONTROL", tVMEADR, NULL, 0, 0.0, NULL, 0x8, NULL},
{"TTCIT_STATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xc, NULL},
{"RESET_TTCRX", tVMEADR, NULL, 0, 0.0, NULL, 0x10, NULL},
{"VME_CONTROL_VERS", tVMEADR, NULL, 0, 0.0, NULL, 0x3c, NULL},
{"READ_ADDR_COUNT", tVMEADR, NULL, 0, 0.0, NULL, 0x14, NULL},
{"READ_SNAPSHOT", tVMEADR, NULL, 0, 0.0, NULL, 0x18, NULL},
{"RESET", tVMEADR, NULL, 0, 0.0, NULL, 0x28, NULL},
{"BCNT_TTCRX", tVMEADR, NULL, 0, 0.0, NULL, 0x1c, NULL},
{"N_BCNT_TTCRX", tVMEADR, NULL, 0, 0.0, NULL, 0x20, NULL},
{"RESET_SNAPSHOT_N", tVMEADR, NULL, 0, 0.0, NULL, 0x8c, NULL},
{"CONFIG_START", tVMEADR, NULL, 0, 0.0, NULL, 0x2c, NULL},
{"FLASHADD_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0x30, NULL},
{"FLASHACCESS_INCR", tVMEADR, NULL, 0, 0.0, NULL, 0x34, NULL},
{"FLASHACCESS_NOINCR", tVMEADR, NULL, 0, 0.0, NULL, 0x38, NULL},
{"HW_TIME_L0_L1", tVMEADR, NULL, 0, 0.0, NULL, 0x24, NULL},
{"HW_RESET_COUNTERS", tVMEADR, NULL, 0, 0.0, NULL, 0x40, NULL},
{"HW_COUNTER_L0", tVMEADR, NULL, 0, 0.0, NULL, 0x44, NULL},
{"HW_COUNTER_L1", tVMEADR, NULL, 0, 0.0, NULL, 0x48, NULL},
{"HW_COUNTER_L1M", tVMEADR, NULL, 0, 0.0, NULL, 0x4c, NULL},
{"HW_COUNTER_L2A", tVMEADR, NULL, 0, 0.0, NULL, 0x50, NULL},
{"HW_COUNTER_L2R", tVMEADR, NULL, 0, 0.0, NULL, 0x54, NULL},
{"HW_COUNT_ERR_PP", tVMEADR, NULL, 0, 0.0, NULL, 0x58, NULL},
{"HW_COUNT_ERR_L0S", tVMEADR, NULL, 0, 0.0, NULL, 0x5c, NULL},
{"HW_COUNT_ERR_L1S", tVMEADR, NULL, 0, 0.0, NULL, 0x60, NULL},
{"HW_COUNT_ERR_L1MM", tVMEADR, NULL, 0, 0.0, NULL, 0x64, NULL},
{"HW_COUNT_ERR_L1MS", tVMEADR, NULL, 0, 0.0, NULL, 0x68, NULL},
{"HW_COUNT_ERR_L1MI", tVMEADR, NULL, 0, 0.0, NULL, 0x6c, NULL},
{"HW_COUNT_ERR_L1MD", tVMEADR, NULL, 0, 0.0, NULL, 0x70, NULL},
{"HW_COUNT_ERR_L2MM", tVMEADR, NULL, 0, 0.0, NULL, 0x74, NULL},
{"HW_COUNT_ERR_L2MS", tVMEADR, NULL, 0, 0.0, NULL, 0x78, NULL},
{"HW_COUNT_ERR_L2MI", tVMEADR, NULL, 0, 0.0, NULL, 0x7c, NULL},
{"HW_COUNT_ERR_L2MD", tVMEADR, NULL, 0, 0.0, NULL, 0x80, NULL},
{"HW_COUNT_ERR_CAL", tVMEADR, NULL, 0, 0.0, NULL, 0x84, NULL},
{"HW_COUNT_ERR_BCNT", tVMEADR, NULL, 0, 0.0, NULL, 0x88, NULL},
{"SCOPE_SELECTED_A", tVMEADR, NULL, 0, 0.0, NULL, 0x90, NULL},
{"SCOPE_SELECTED_B", tVMEADR, NULL, 0, 0.0, NULL, 0x94, NULL},
{"SERIAL_NUMBER", tVMEADR, NULL, 0, 0.0, NULL, 0x98, NULL},
{"HW_DELAY_SSM_STOP", tVMEADR, NULL, 0, 0.0, NULL, 0x9c, NULL},
{"HW_BCNT_DIFFERENCE", tVMEADR, NULL, 0, 0.0, NULL, 0xa0, NULL},
{"HW_PP_COUNTER", tVMEADR, NULL, 0, 0.0, NULL, 0xa4, NULL},
{"TTCITinit", tFUN+0x400, (funcall)TTCITinit, 0xdead, 0.0, NULL, 0, TTCITinit_usagehelp},
{"FPGAcodeVersion", tFUN+0x200, (funcall)FPGAcodeVersion, 0xdead, 0.0, NULL, 0, FPGAcodeVersion_usagehelp},
{"GetSerialNumber", tFUN+0x200, (funcall)GetSerialNumber, 0xdead, 0.0, NULL, 0, GetSerialNumber_usagehelp},
{"TTCRxReset", tFUN+0x200, (funcall)TTCRxReset, 0xdead, 0.0, NULL, 0, TTCRxReset_usagehelp},
{"ResetTTCit", tFUN+0x200, (funcall)ResetTTCit, 0xdead, 0.0, NULL, 0, ResetTTCit_usagehelp},
{"clearCounters", tFUN+0x400, (funcall)clearCounters, 0xdead, 0.0, NULL, 0, clearCounters_usagehelp},
{"ScopeSelect_AB", tFUN+0x400, (funcall)ScopeSelect_AB, 0xdead, 0.0, ScopeSelect_AB_parameters, 2, ScopeSelect_AB_usagehelp},
{"ScopeGet_AB", tFUN+0x400, (funcall)ScopeGet_AB, 0xdead, 0.0, ScopeGet_AB_parameters, 1, ScopeGet_AB_usagehelp},
{"OM_Reset", tFUN+0x400, (funcall)OM_Reset, 0xdead, 0.0, NULL, 0, OM_Reset_usagehelp},
{"OM_ON_Start", tFUN+0x400, (funcall)OM_ON_Start, 0xdead, 0.0, NULL, 0, OM_ON_Start_usagehelp},
{"OM_OFF", tFUN+0x400, (funcall)OM_OFF, 0xdead, 0.0, NULL, 0, OM_OFF_usagehelp},
{"OM_Status", tFUN+0x400, (funcall)OM_Status, 0xdead, 0.0, NULL, 0, OM_Status_usagehelp},
{"OM_PrintStatusSSM", tFUN+0x400, (funcall)OM_PrintStatusSSM, 0xdead, 0.0, NULL, 0, OM_PrintStatusSSM_usagehelp},
{"OM_SetErrorMask_msg", tFUN+0x400, (funcall)OM_SetErrorMask_msg, 0xdead, 0.0, OM_SetErrorMask_msg_parameters, 8, OM_SetErrorMask_msg_usagehelp},
{"OM_SetErrorMask_sig", tFUN+0x400, (funcall)OM_SetErrorMask_sig, 0xdead, 0.0, OM_SetErrorMask_sig_parameters, 5, OM_SetErrorMask_sig_usagehelp},
{"OM_ShowErrorMask", tFUN+0x400, (funcall)OM_ShowErrorMask, 0xdead, 0.0, NULL, 0, OM_ShowErrorMask_usagehelp},
{"OM_ClearErrorMask", tFUN+0x400, (funcall)OM_ClearErrorMask, 0xdead, 0.0, NULL, 0, OM_ClearErrorMask_usagehelp},
{"OM_SaveErrorMask", tFUN+0x400, (funcall)OM_SaveErrorMask, 0xdead, 0.0, NULL, 0, OM_SaveErrorMask_usagehelp},
{"OM_ReloadLastErrorMask", tFUN+0x400, (funcall)OM_ReloadLastErrorMask, 0xdead, 0.0, NULL, 0, OM_ReloadLastErrorMask_usagehelp},
{"OM_SetTimeL0_L1", tFUN+0x400, (funcall)OM_SetTimeL0_L1, 0xdead, 0.0, OM_SetTimeL0_L1_parameters, 1, OM_SetTimeL0_L1_usagehelp},
{"OM_ShowCounters", tFUN+0x400, (funcall)OM_ShowCounters, 0xdead, 0.0, NULL, 0, OM_ShowCounters_usagehelp},
{"OM_ResetCounters", tFUN+0x400, (funcall)OM_ResetCounters, 0xdead, 0.0, NULL, 0, OM_ResetCounters_usagehelp},
{"OM_TriggerCounters", tFUN+0x400, (funcall)OM_TriggerCounters, 0xdead, 0.0, NULL, 0, OM_TriggerCounters_usagehelp},
{"OM_ErrorCounters", tFUN+0x400, (funcall)OM_ErrorCounters, 0xdead, 0.0, NULL, 0, OM_ErrorCounters_usagehelp},
{"OM_Detected_Errors", tFUN+0x400, (funcall)OM_Detected_Errors, 0xdead, 0.0, NULL, 0, OM_Detected_Errors_usagehelp},
{"OM_FetchSSM_Dump", tFUN+0x400, (funcall)OM_FetchSSM_Dump, 0xdead, 0.0, NULL, 0, OM_FetchSSM_Dump_usagehelp},
{"OM_FetchSSM_Analyze", tFUN+0x400, (funcall)OM_FetchSSM_Analyze, 0xdead, 0.0, NULL, 0, OM_FetchSSM_Analyze_usagehelp},
{"OM_ErrMaskSync", tFUN+0x400, (funcall)OM_ErrMaskSync, 0xdead, 0.0, OM_ErrMaskSync_parameters, 1, OM_ErrMaskSync_usagehelp},
{"OM_SSM_DumpAfterStop", tFUN+0x400, (funcall)OM_SSM_DumpAfterStop, 0xdead, 0.0, OM_SSM_DumpAfterStop_parameters, 1, OM_SSM_DumpAfterStop_usagehelp},
{"OM_SSM_AnalyzeAfterStop", tFUN+0x400, (funcall)OM_SSM_AnalyzeAfterStop, 0xdead, 0.0, OM_SSM_AnalyzeAfterStop_parameters, 1, OM_SSM_AnalyzeAfterStop_usagehelp},
{"OM_SetDelayedSSMstop", tFUN+0x400, (funcall)OM_SetDelayedSSMstop, 0xdead, 0.0, OM_SetDelayedSSMstop_parameters, 1, OM_SetDelayedSSMstop_usagehelp},
{"OM_GetDelayedSSMstop", tFUN+0x200, (funcall)OM_GetDelayedSSMstop, 0xdead, 0.0, NULL, 0, OM_GetDelayedSSMstop_usagehelp},
{"RA", tFUN+0x400, (funcall)RA, 0xdead, 0.0, NULL, 0, RA_usagehelp},
{"L0signal", tFUN+0x400, (funcall)L0signal, 0xdead, 0.0, L0signal_parameters, 1, L0signal_usagehelp},
{"StartMONITOR", tFUN+0x200, (funcall)StartMONITOR, 0xdead, 0.0, NULL, 0, StartMONITOR_usagehelp},
{"getCounters", tFUN+0x400, (funcall)getCounters, 0xdead, 0.0, getCounters_parameters, 2, getCounters_usagehelp},
{"ReadLastSSM", tFUN+0x200, (funcall)ReadLastSSM, 0xdead, 0.0, NULL, 0, ReadLastSSM_usagehelp},
{"RawDumpSSM", tFUN+0x400, (funcall)RawDumpSSM, 0xdead, 0.0, RawDumpSSM_parameters, 2, RawDumpSSM_usagehelp},
{"ClearSSM", tFUN+0x400, (funcall)ClearSSM, 0xdead, 0.0, NULL, 0, ClearSSM_usagehelp},
{"ClearSSMemoryBuffer", tFUN+0x400, (funcall)ClearSSMemoryBuffer, 0xdead, 0.0, NULL, 0, ClearSSMemoryBuffer_usagehelp},
{"GetNrSSMwords", tFUN+0x200, (funcall)GetNrSSMwords, 0xdead, 0.0, NULL, 0, GetNrSSMwords_usagehelp},
{"HexBinDump", tFUN+0x400, (funcall)HexBinDump, 0xdead, 0.0, NULL, 0, HexBinDump_usagehelp},
{"HexBinDumpNext", tFUN+0x400, (funcall)HexBinDumpNext, 0xdead, 0.0, NULL, 0, HexBinDumpNext_usagehelp},
{"SelDump", tFUN+0x200, (funcall)SelDump, 0xdead, 0.0, NULL, 0, SelDump_usagehelp},
{"SelFetchHexBinDump", tFUN+0x200, (funcall)SelFetchHexBinDump, 0xdead, 0.0, NULL, 0, SelFetchHexBinDump_usagehelp},
{"SelFetchDump", tFUN+0x200, (funcall)SelFetchDump, 0xdead, 0.0, NULL, 0, SelFetchDump_usagehelp},
{"SelDumpNext", tFUN+0x200, (funcall)SelDumpNext, 0xdead, 0.0, NULL, 0, SelDumpNext_usagehelp},
{"SelDumpOptions", tFUN+0x400, (funcall)SelDumpOptions, 0xdead, 0.0, SelDumpOptions_parameters, 7, SelDumpOptions_usagehelp},
{"SelPrintDumpOpt", tFUN+0x400, (funcall)SelPrintDumpOpt, 0xdead, 0.0, NULL, 0, SelPrintDumpOpt_usagehelp},
{"SelDumpN", tFUN+0x200, (funcall)SelDumpN, 0xdead, 0.0, SelDumpN_parameters, 1, SelDumpN_usagehelp},
{"SelDumpTimeouts", tFUN+0x400, (funcall)SelDumpTimeouts, 0xdead, 0.0, SelDumpTimeouts_parameters, 1, SelDumpTimeouts_usagehelp},
{"SelDump1stEvent", tFUN+0x400, (funcall)SelDump1stEvent, 0xdead, 0.0, SelDump1stEvent_parameters, 1, SelDump1stEvent_usagehelp},
{"SelDump1stMenu", tFUN+0x400, (funcall)SelDump1stMenu, 0xdead, 0.0, SelDump1stMenu_parameters, 8, SelDump1stMenu_usagehelp},
{"SelDumpL0", tFUN+0x400, (funcall)SelDumpL0, 0xdead, 0.0, SelDumpL0_parameters, 1, SelDumpL0_usagehelp},
{"SelDumpDefaults", tFUN+0x400, (funcall)SelDumpDefaults, 0xdead, 0.0, NULL, 0, SelDumpDefaults_usagehelp},
{"SelDumpCountSSM", tFUN+0x400, (funcall)SelDumpCountSSM, 0xdead, 0.0, NULL, 0, SelDumpCountSSM_usagehelp},
{"SelDumpSetEvent", tFUN+0x200, (funcall)SelDumpSetEvent, 0xdead, 0.0, SelDumpSetEvent_parameters, 1, SelDumpSetEvent_usagehelp},
{"GetNbcntFIFO", tFUN+0x200, (funcall)GetNbcntFIFO, 0xdead, 0.0, NULL, 0, GetNbcntFIFO_usagehelp},
{"FetchBcntFIFO", tFUN+0x200, (funcall)FetchBcntFIFO, 0xdead, 0.0, NULL, 0, FetchBcntFIFO_usagehelp},
{"StopMONITOR", tFUN+0x400, (funcall)StopMONITOR, 0xdead, 0.0, NULL, 0, StopMONITOR_usagehelp},
{"StatusMONITOR", tFUN+0x200, (funcall)StatusMONITOR, 0xdead, 0.0, NULL, 0, StatusMONITOR_usagehelp},
{"Rescan", tFUN+0x400, (funcall)Rescan, 0xdead, 0.0, NULL, 0, Rescan_usagehelp},
{"RescanLeave", tFUN+0x400, (funcall)RescanLeave, 0xdead, 0.0, NULL, 0, RescanLeave_usagehelp},
{"RecsanCont", tFUN+0x400, (funcall)RecsanCont, 0xdead, 0.0, NULL, 0, RecsanCont_usagehelp},
{"WriteFile_ON", tFUN+0x400, (funcall)WriteFile_ON, 0xdead, 0.0, NULL, 0, WriteFile_ON_usagehelp},
{"WriteFile_OFF", tFUN+0x400, (funcall)WriteFile_OFF, 0xdead, 0.0, NULL, 0, WriteFile_OFF_usagehelp},
{"OnlineDiag_ON", tFUN+0x400, (funcall)OnlineDiag_ON, 0xdead, 0.0, NULL, 0, OnlineDiag_ON_usagehelp},
{"OnlineDiag_OFF", tFUN+0x400, (funcall)OnlineDiag_OFF, 0xdead, 0.0, NULL, 0, OnlineDiag_OFF_usagehelp},
{"ShowMONITORoptions", tFUN+0x400, (funcall)ShowMONITORoptions, 0xdead, 0.0, NULL, 0, ShowMONITORoptions_usagehelp},
{"SetStopCondition", tFUN+0x400, (funcall)SetStopCondition, 0xdead, 0.0, SetStopCondition_parameters, 10, SetStopCondition_usagehelp},
{"SetStopAnyError", tFUN+0x400, (funcall)SetStopAnyError, 0xdead, 0.0, NULL, 0, SetStopAnyError_usagehelp},
{"SetStopConditionNSEQ", tFUN+0x400, (funcall)SetStopConditionNSEQ, 0xdead, 0.0, SetStopConditionNSEQ_parameters, 1, SetStopConditionNSEQ_usagehelp},
{"SetNEVERstop", tFUN+0x400, (funcall)SetNEVERstop, 0xdead, 0.0, NULL, 0, SetNEVERstop_usagehelp},
{"ShowStopConditions", tFUN+0x400, (funcall)ShowStopConditions, 0xdead, 0.0, NULL, 0, ShowStopConditions_usagehelp},
{"ResetSSManalyzer", tFUN+0x400, (funcall)ResetSSManalyzer, 0xdead, 0.0, NULL, 0, ResetSSManalyzer_usagehelp},
{"ShowCounters", tFUN+0x400, (funcall)ShowCounters, 0xdead, 0.0, NULL, 0, ShowCounters_usagehelp},
{"ShowErrors", tFUN+0x400, (funcall)ShowErrors, 0xdead, 0.0, NULL, 0, ShowErrors_usagehelp},
{"ShowTiming", tFUN+0x400, (funcall)ShowTiming, 0xdead, 0.0, NULL, 0, ShowTiming_usagehelp},
{"SetTimeWindows", tFUN+0x400, (funcall)SetTimeWindows, 0xdead, 0.0, SetTimeWindows_parameters, 7, SetTimeWindows_usagehelp},
{"SetBCconst", tFUN+0x400, (funcall)SetBCconst, 0xdead, 0.0, SetBCconst_parameters, 3, SetBCconst_usagehelp},
{"DefaultTimeWindows", tFUN+0x400, (funcall)DefaultTimeWindows, 0xdead, 0.0, NULL, 0, DefaultTimeWindows_usagehelp},
{"ShowTimeWindows", tFUN+0x400, (funcall)ShowTimeWindows, 0xdead, 0.0, NULL, 0, ShowTimeWindows_usagehelp},
{"AnalyzeOneSnapShot", tFUN+0x400, (funcall)AnalyzeOneSnapShot, 0xdead, 0.0, NULL, 0, AnalyzeOneSnapShot_usagehelp},
{"AnalyzeN", tFUN+0x400, (funcall)AnalyzeN, 0xdead, 0.0, AnalyzeN_parameters, 1, AnalyzeN_usagehelp},
{"BcidMismatch", tFUN+0x400, (funcall)BcidMismatch, 0xdead, 0.0, BcidMismatch_parameters, 1, BcidMismatch_usagehelp},
{"PrintBcntFIFO", tFUN+0x400, (funcall)PrintBcntFIFO, 0xdead, 0.0, PrintBcntFIFO_parameters, 1, PrintBcntFIFO_usagehelp},
{"TTCitCounters", tFUN, NULL, 0xdead, 0.0, NULL, 0, TTCitCounters_usagehelp},
{"Scope_Signals", tFUN, NULL, 0xdead, 0.0, NULL, 0, Scope_Signals_usagehelp},
{"TestFetchSSM", tFUN+0x400, (funcall)TestFetchSSM, 0xdead, 0.0, NULL, 0, TestFetchSSM_usagehelp},
{"GetBoardType", tFUN+0x200, (funcall)GetBoardType, 0xdead, 0.0, NULL, 0, GetBoardType_usagehelp},
{"GetVMEContVersion", tFUN+0x200, (funcall)GetVMEContVersion, 0xdead, 0.0, NULL, 0, GetVMEContVersion_usagehelp},
{"LoopTestSSM", tFUN+0x400, (funcall)LoopTestSSM, 0xdead, 0.0, LoopTestSSM_parameters, 2, LoopTestSSM_usagehelp},
{"SS_top", tFUN+0x200, (funcall)SS_top, 0xdead, 0.0, NULL, 0, SS_top_usagehelp},
{"GetWordBCfifo", tFUN+0x200, (funcall)GetWordBCfifo, 0xdead, 0.0, NULL, 0, GetWordBCfifo_usagehelp},
{"PrintTTCITLogic", tFUN+0x400, (funcall)PrintTTCITLogic, 0xdead, 0.0, NULL, 0, PrintTTCITLogic_usagehelp},
{"DumpWrittenData", tFUN+0x400, (funcall)DumpWrittenData, 0xdead, 0.0, DumpWrittenData_parameters, 1, DumpWrittenData_usagehelp},
{"DumpFileEvents", tFUN+0x400, (funcall)DumpFileEvents, 0xdead, 0.0, NULL, 0, DumpFileEvents_usagehelp},
{"GUI_ClearCounters", tFUN+0x400, (funcall)GUI_ClearCounters, 0xdead, 0.0, NULL, 0, GUI_ClearCounters_usagehelp},
{"GUI_GetCounters", tFUN+0x400, (funcall)GUI_GetCounters, 0xdead, 0.0, GUI_GetCounters_parameters, 1, GUI_GetCounters_usagehelp},
{"DBG_TestClearSSM", tFUN+0x400, (funcall)DBG_TestClearSSM, 0xdead, 0.0, NULL, 0, DBG_TestClearSSM_usagehelp},
{"OM_ON_nostart", tFUN+0x400, (funcall)OM_ON_nostart, 0xdead, 0.0, NULL, 0, OM_ON_nostart_usagehelp},
{"WriteCodeFM", tFUN+0x200, (funcall)WriteCodeFM, 0xdead, 0.0, NULL, 0, WriteCodeFM_usagehelp},
{"LoadFPGA", tFUN+0x200, (funcall)LoadFPGA, 0xdead, 0.0, NULL, 0, LoadFPGA_usagehelp},
{"dummyDebugStop", tFUN+0x400, (funcall)dummyDebugStop, 0xdead, 0.0, NULL, 0, dummyDebugStop_usagehelp}};
