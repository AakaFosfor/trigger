#! /usr/bin/env python
"""
22.11. -write2hw only modified ctp config. values
2 phases:
1.  Classes Klas,PFboard,PFcircuit,Fanout, Attr (Attr2, AttrLUT)
have variable 'writeme' and corresponding methods (dedicated from
class Genhw). Their methods readhw/writehw update writeme
variable automatically:
readhw(line) 
 - readhw (update writeme=0) or loadfrom line (writeme=1)
writehw(cf)
 - write2hw always and update hwwritten(1)
 - save2file always (don't touch writeme) 

Method writehw() should not be called if not necessary -this
can be found out by calling modified() method. E.g. see 
Ctpconfig.writehw()

Attributes of the instances of these classes can be changed:
- from the widget -> hwwritten(0) called from inside the class method
   (usually handler routine)
- from outside -> if modified not through readhw/writehw,
   the call hwwritten(0) should be arranged approppriately

I.e. by this arrangment, all the conf. parameters are divided
into groups (e.g. if only 1 attribute of 1 PFcircuit was
modified, when written to hw, all the attributes of this PFcircuit
will be written (the whole group))

2. phase:
shared memory and check in ctp.c is organised as follows:
read:  - don't read from hw (instead read from memory)
       - possible 'forced' read and check 
write: - don't write to hw, if the memory is the same
       - possible 'forced' write
10.1.2006
fixed: incorrect group-2 shared resources (INTSEL) reading from ctpcfg file 
"""

from Tkinter import *
import string,os,types
import myw,txtproc

COLOR_SHARED="#cc66cc"
COLOR_FOS="#cc6600"
COLOR_PFS="#cc0066"
COLOR_LUT="#ffccff"
ORBITLENGTH=3564

def IntErr(fstr):
  print "Internal error:",fstr
def PrintError(fstr):
  print "Error:",fstr
def prt(o, *pars):
  print "DBGPRT in ", o.__class__.__name__,":",pars

def InvertBit(w32,bit):   # bit: 0..31
  mi= w32 & (1<<bit)
  if mi:  
    iw32= w32 & (w32 & (~mi))
  else:   
    iw32= w32 | (1<<bit)
  #print "InverBit %d: 0x%x -> 0x%x"%(bit,w32,iw32)
  return iw32

vbexec= myw.vbexec

class Genhw:
  def __init__(self,attrs=None):
    self.attrs=attrs
    if attrs==None:
      self.writeme=1
  def modified(self):
    """ Test if HW != MEMORY
    rc: 1 if this class (descandant of this class) was changed,i.e.
           HW contains different value
        0 if HW registers are the same as attributes
    """
    if self.attrs==None:
      return self.writeme
    else:
      for atr in self.attrs:
        #print "Genhw.modified:",atr.modified(), atr.atrname
        if atr.modified():
          return 1
      return 0
  def hwwritten(self, newval=1):
    """ Set condition: if HW == MEMORY
    newval:
    1 -to be called when memory equals to HW, i.e. after:
       - reading HW
       - writing HW
    0 -to be called always after attribute value changed
       i.e. memory differs from HW -always after:
       - value modification from the screen
       - value modification by other program (not considered yet-
         perhaps after introducing 'shared memory')
       - value modification by reading from file
    """
    if self.attrs==None:
      self.writeme=1-newval
      if self.writeme==1: wcolor='red'
      else: wcolor='green'
      vbexec.setWarning(wcolor)
    else:
      for atr in self.attrs:
        #print "Genhw.hwwritten:",newval, atr.atrname
        atr.hwwritten(newval)

class Ctpconfig:
  clusterx0=17    # left top corner of cluster's rectangles 
  l0x0=30         # left top corner of classes L0 bit rectangles 
  l0y0=10         # class 0 -not class, instead reserved for text header
  int12bits=["INTfun1","BC1","BC2","RND1","RND2"]
  #vonint2bits=[("i0",1),("i1",1),("i2",1),("i3",1),("i4",1),"INTfun2","BC1","BC2","RND1","RND2"]
  AllRarebits=["All"]
  lastshrgrp1=8   # index in self.sharedrs
  def __init__(self, vb):
    self.caclstl= None   # Classes toplevel window not displayed
    self.canvas=None     # Canvas (only class per line) not displayed
    self.allorenabled=0   # 1->all 0->only enabled classes shown in 'Classes'
    self.bcmasks=[]; 
    for i in range(ORBITLENGTH):
      self.bcmasks.append(0)
    self.shrtl=None      # Shared resources not displayed
    self.sharedrs= [
    AttrRndgen('RND1',0, TrgSHR.RNDxHelp),
    AttrRndgen('RND2',0, TrgSHR.RNDxHelp),        # 2 RND inputs
    Attr('BC1', 0, TrgSHR.BCxHelp),
    Attr('BC2', 0, TrgSHR.BCxHelp), # 2 BC scaled down inputs 
    AttrLUT('INTfun1',["0x0",4,0], TrgSHR.L0FUNxHelp),
    AttrLUT('INTfun2',["a|d",4,0], TrgSHR.L0FUNxHelp),
    AttrLUT('INTfunT',["a&b&(c|d)",4,0], TrgSHR.L0FUNxHelp),
    AttrLUT('L0fun1',["a|b|c|d",4,0], TrgSHR.L0FUNxHelp),
    AttrLUT('L0fun2',["a|b|c|d",4,0], TrgSHR.L0FUNxHelp),#eof grp1-lastshrgrp1
    AttrBits('INT1',0, helptext=TrgSHR.INTxHelp,bits=Ctpconfig.int12bits),
    AttrBits('INT2',0, helptext=TrgSHR.INTxHelp,bits=Ctpconfig.int12bits),
    AttrBits('All/Rare',0, helptext=TrgSHR.AllRareHelp,
      bits=Ctpconfig.AllRarebits),   # lastshrgrp1+3
    AttrBCmask('BCM1','bitmap',TrgSHR.BCMxHelp, self),  #lastshrgrp1+4
    AttrBCmask('BCM2','bitmap',TrgSHR.BCMxHelp, self),
    AttrBCmask('BCM3','bitmap',TrgSHR.BCMxHelp, self),
    AttrBCmask('BCM4','bitmap',TrgSHR.BCMxHelp, self)
    ]
    self.interactionsel=0
    self.pfs= []
    ixinbt=1
    for ix in range(3):
      cct= vbexec.get2("notInCrate("+str(ixinbt)+")")
      if cct[0]=='0':
        self.pfs.append(PFboard(ix))
      ixinbt= ixinbt+1
    cct= vbexec.get2("notInCrate(1)")
    if cct[0]=='0':
      self.readShared()
      self.klasses=[]
      for ix in range(1,51):   #keep this order ! 
        k=Klas(self,ix)
        k.readhw()    # should be OK with shared memory
        self.klasses.append(k)
    else:
      self.klasses= [
      Klas(self,31, 0xaa55, 0x3230),
      Klas(self, 3, 0xaa55, 0x3236),
      Klas(self,47, 0xaa55, 0x3233),
      Klas(self,50, 0xaa55, 0x3236),
      Klas(self, 8, 0xaa55, 0x3232)]
    self.fanouts=[]; ixinbt=5; 
    self.fotl=None
    for ix in range(6):
      cct= vbexec.getline("getFO("+str(ixinbt)+")")   # cct: 'cl tcl'
      #print "Ctpconfig.fo:",cct, type(cct), len(cct)
      if len(cct)>0:
        self.fanouts.append(Fanout(ix+1,None))
        # let's read FO once more when initialised
      ixinbt= ixinbt+1
  def findKlass(self,clnumber):
    for cl in self.klasses:
      if cl.clnumber==clnumber: return cl
    return None
  def doClasses(self):
    if self.caclstl:
      myw.RiseToplevel(self.caclstl); return
    self.caclstl= myw.NewToplevel("CTP classes",self.classesDestroyed)
    self.cmdbuts= myw.MywHButtons(self.caclstl, [
      ("blabla",self.cmdallenabled)
      ],side=TOP, helptext="""
All/Enabled -show all or only enabled classes. This button becomes red
             if some ENABLED classes are not shown
""")
    self.doCanvas()
  def doCanvas(self):
    if self.allorenabled==1:
      nclines= len(self.klasses)
      aetx=Klas.txenabled
    else:
      aetx=Klas.txall
      nclines=0
      for k in self.klasses:
        if (k.l0vetos & 0x10000)==0:   #class enabled
          nclines= nclines+1
    self.cmdbuts.buttons[0].setLabel(aetx)
    self.cmdbuts.buttons[0].setColor(myw.COLOR_BGDEFAULT)
    canvash= (nclines+1)*Klas.bitHeight + Ctpconfig.l0y0
    canvasw= 600
    if self.canvas: print "error -canvs not deleted"
    self.freenumber=1   #line (from 1) on canvas
    self.canvas= Canvas(self.caclstl,width=canvasw,height=canvash,
      background='yellow', borderwidth=1)
    self.canvas.pack(expand=1,fill=BOTH, side=BOTTOM)
    self.canvas.bind("<Destroy>",self.canvasDestroyed)
    id0=self.canvas.create_text(1, Ctpconfig.l0y0,
      anchor=NW,text="Cl#")
    self.doHelp(id0, """
Class number and Cluster it belongs to
""")
    id1=self.canvas.create_text(Ctpconfig.l0x0, Ctpconfig.l0y0,
      anchor=NW,text="L0 inputs")
    self.doHelp(id1, """
L0 inputs: 1-24, 2 special functions, 2 scaled down BC, 2 random triggers.
Mouse buttons clicks:
Left  -> modify
         red:         don't care (1)
         green:       enabled    (0)
         light green: enabled (0), inverted (1)
Middle-> modify the invert bit (only for classes 45-50)
""")
    id2=self.canvas.create_text(Klas.l0vetosx0, Ctpconfig.l0y0,
      anchor=NW,text="L0 vetos sel.")
    self.doHelp(id2,"""
L0 selectable vetos. As with L0 inputs:
         red:         don't care    (1)
         green:       veto selected (0)
Bit 'Class mask' must be selected to get triggers through
""")
    id3=self.canvas.create_text(Klas.l0scalerx0, Ctpconfig.l0y0,
      anchor=NW,text="L0 pre-scaler")
    self.doHelp(id3,"""
L0 pre-scaler. 21 bits (0-no downscaling 0x1fffff-supress all triggers).
% character can be used to enter the down-scale rate. Examples:
%50 -reduce triggers by half
%1  -full trigger rate down-scaled 100 times
""")
    # sort klasses according to their cluster:
    sorted= self.klasses
    sorted.sort(self.compCluster)
    for k in sorted:
    #for k in self.klasses:
      if self.allorenabled==1:
        k.doClass()
      else:
        if (k.l0vetos & 0x10000)==0:   #class enabled
          k.doClass()
  def canvasDestroyed(self,event):
    #print "canvasDestroyed: marking classes 'not-visible'"
    for k in self.klasses:
      k.linenumber=0      # not visible
    self.freenumber=1   #line (from 1) on canvas
    self.canvas=None
  def compCluster(self,k1,k2):
    c1= k1.getCluster(); 
    c2= k2.getCluster()
    if c1==0: c1=7   # unassigned classes at the end of the list
    if c2==0: c2=7
    if c1<c2: rc=-1
    elif c1>c2: rc=1
    else: 
      if k1.clnumber<k2.clnumber: rc=-1
      elif k1.clnumber>k2.clnumber: rc=1
      else: 
        rc=0
        IntErr("2 classes with equal numbers:%d %d"%(k1.clnumber,k2.clnumber))
    #print c1,c2,rc
    return rc
  def classesDestroyed(self,event):
    # when destroyed, called 2x, keycode the same 2nd time for more
    # repeatedly created/destryed canvases
    #print "classesDestroyed:",event 
    #print dir(event)
    #print "keycode keysym:",event.keycode, event.keysym
    if event.widget==self.caclstl:
      self.caclstl=None
    #if (event.widget==self.canvas) or (event.widget==self.caclstl):
    #always (when toplevel 'Classes' or only canvas destroyed):
  def doline(self, xy1, xy2, color="white",width=1):
    self.canvas.create_line(xy1[0],xy1[1],xy2[0],xy2[1],
      fill=color, width=width)
  def doEntry(self, xy, klas_method):
    entw= myw.MywEntry(self.caclstl,bind='lr', label='',
      cmdlabel=klas_method, width=10)
      #cmdlabel=self.entryhandler, width=10)
    #entw= Entry(self.caclstl, font=("Times",8))
    #entw.insert('end','defval'); entw.pack()
    id= self.canvas.create_window(xy[0], xy[1],window=entw,
      anchor=NW)
    #self.canvas.addtag_withtag("TAGl0pr",id)
    #self.canvas.tag_lower(id)
    return entw
  #def entryhandler(self,event):
  #  print "entryhandler:"
  def dobit(self, xy, color=None, hlptxt=None):
    """
    bitposition: parameter passed to bithandler
    """
    if color==None: color="white"
    bitid= self.canvas.create_rectangle(xy[0],xy[1],
      xy[0]+Klas.bitWidth-1, xy[1]+Klas.bitHeight-1, fill=color)
    # handlers:
    #if bithandler == Klas.modL0handler:
    #if isinstance(bithandler, Klas.modL0handler):
    #print "bithandler:",bithandler
    #handler= lambda e,s=self,k=bitposition:s.bithandler(e, k)
    if hlptxt: self.doHelp(bitid, hlptxt)
    return bitid
  #def bithandler(self,e,k):
  #  print "s.bithandler:",e,k
  def doHelp(self, id, hlptxt):
    enthandler= lambda e,s=self,k=hlptxt:s.enterbit(e, k)
    self.canvas.tag_bind(id, "<Enter>", enthandler)
    self.canvas.tag_bind(id, "<Leave>", self.leavebit)
  def enterbit(self, event, hlptext="entering bit"):
    obrd=5
    x= event.x+20; y=event.y+20
    if hlptext==None: hlptext="Entering bit"
    if hlptext[0:2]=='XX':
      k= self.findKlass(int(hlptext[2:]))
      hlptext= "Cluster "+str(k.getCluster())
    self.hlptxt= self.canvas.create_text(x,y,anchor=NW,
      tags="TAGhlptemp", text=hlptext)
    cs=self.canvas.bbox(self.hlptxt)
    if cs[2] > Klas.l0scalerx0:
      # recreate it shifted to the left:
      #print "enterbit. cs:",cs, "l0prescaler-x:",Klas.l0scalerx0
      self.canvas.delete("TAGhlptemp")
      x= x-(cs[2] - Klas.l0scalerx0+6)
      self.hlptxt= self.canvas.create_text(x,y,anchor=NW,
        tags="TAGhlptemp", text=hlptext)
      cs=self.canvas.bbox(self.hlptxt)
    self.ovalhelp= self.canvas.create_rectangle(cs[0]-obrd,cs[1]-obrd,
      cs[2]+obrd,cs[3]+obrd,tags="TAGhlptemp", fill=Klas.colHelpBg)
    #self.canvas.tag_raise(self.ovalhelp, "TAGl0pr")
    self.canvas.tag_raise(self.hlptxt, self.ovalhelp)
  def leavebit(self, event):
    #print "leavebit:"
    self.canvas.delete("TAGhlptemp")
    #self.canvas.delete(self.ovalhelp)
  def loadfile(self,fname=None):
    #if fname==None:
    #  fname= os.environ['VMECFDIR'] +"/WORK/ctp.cfg"
    cf= open(fname,"r")
    if cf: vbexec.printmsg("Loading file:"+fname+"\n")
    newcanvas=None
    for line in cf.readlines():
      lab,rest= string.split(line,None,1)
      rest= rest[:-1]
      #print lab,':',rest,':'
      if lab=='RBIF': 
        self.readSharedline(rest,0, Ctpconfig.lastshrgrp1,sep=':')
      elif lab=='INTSEL': 
        self.readSharedline(rest, 
          Ctpconfig.lastshrgrp1+1, Ctpconfig.lastshrgrp1+3)
      elif lab=='BCMASKS':
        self.str2masks(rest[:ORBITLENGTH])
      elif lab[:7]=='BCMASK.':
        bcix= int(lab[7])
        ishr= Ctpconfig.lastshrgrp1+(4-1)+bcix
        self.sharedrs[ishr].setattr(rest)
        self.sharedrs[ishr].hwwritten(0) #anyhow already set with BCMASKS:
      elif lab[:4]=='CLA.':
        clnmb= int(lab[4:6])
        kl= self.findKlass(clnmb)
        kl.readhw(rest)
        if kl.linenumber==0:     # not displayed
          if (kl.l0vetos&0x10000)==0:
            newcanvas=1          # but choosen
        else:
          kl.refreshClass();
      elif lab[:3]=='FO.':
        clix= int(lab[3])   # FO number (1..6)
        fo= self.findFO(clix)
        if fo:
          fo.readhw(rest)
        else:
          PrintError("FO%d board not in the crate"%(clix))   
      elif lab[:4]=='PFL.':
        pfl= string.split(lab[4:],'.')
        if len(pfl)==1:
          brd= int(lab[4])
          self.pfs[brd].readhw(rest)
        else:
          pfcirc= (int(pfl[0]), int(pfl[1]))
          pfc= self.findPFC(pfcirc)
          if pfc:
            pfc.readhw(rest)
          else:
            PrintError("PFcircuit "+str(pfcirc)+" not in the crate")
      else:
        PrintError("unknown label %s in WORK/%s file"%(lab,fname))   
    cf.close()
    if newcanvas and self.caclstl:
      #self.canvas.destroy(); self.doCanvas()
      self.cmdbuts.buttons[0].setColor('red')
  def save2file(self,fname=None):
    #workfname= os.environ['VMECFDIR'] +"/WORK/"+fname
    cf= open(fname,"w")
    if cf: vbexec.printmsg("Writing to file:"+fname+"\n")
    self.writeShared(cf)         # shared resources
    for k in self.klasses:       # class definitions
      k.writehw(cf)
    for k in self.fanouts:       # cluster definitions
      k.writehw(cf)
    for k in self.pfs:           # pfs definitions
      k.writehw(cf)
      for circ in k.pfs:                # circuits on 1 board
        circ.writehw(cf)
    cf.close()
  def readhw(self):
    self.readShared()
    newcanvas=None
    vbexec.get1("hw2rates()")# has to be before following cycle:
    for k in self.klasses:   # class definitions
      k.readhw(); 
      if k.linenumber==0:    # class not displayed
        if (k.l0vetos&0x10000)==0:
          newcanvas=1        # and choosen
      else:
        k.refreshClass()
    for k in self.fanouts:   # clusters defs (FOs)
      k.readhw()
    for k in self.pfs:       # PF on L0,1,2 boards
      k.readhw()
      for circ in k.pfs:                # circuits on 1 board
        circ.readhw()
    if newcanvas and self.caclstl:
      #self.canvas.destroy(); self.doCanvas()
      self.cmdbuts.buttons[0].setColor('red')
  def writehw(self):
    self.writeShared()
    updaterates=None
    for k in self.klasses:   # class definitions
     if k.modified(): 
       k.writehw(); updaterates=1   #in case of at least 1 class changed
    if updaterates: vbexec.get1("rates2hw()")
    for k in self.fanouts:   # clusters defs
     if k.modified(): k.writehw()
    for k in self.pfs:       # PF on L0,1,2 boards
      if k.modified(): k.writehw()
      for circ in k.pfs:         # circuits on 1 board
        if circ.modified(): circ.writehw()
  def readSharedline(self, line, ix1, ix2, sep=' '):
    shr=string.split(line, sep)
    inx=0
    for ishr in range(ix1, ix2+1):
      if (len(shr)!=(Ctpconfig.lastshrgrp1+1)) and (inx==0): 
        # INTSEL group, INT1,2 in 1 word
        try:
          binval= eval(shr[0])
        except:
          print "readSharedline: Wrong INTSEL line:",line
          return
        if ishr==(Ctpconfig.lastshrgrp1+1): 
          binval= binval&0x01f
        if ishr==(Ctpconfig.lastshrgrp1+2): 
          binval= (binval>>5)&0x01f
          inx= inx+1
      else:
        binval= eval(shr[inx])
        inx= inx+1
      self.sharedrs[ishr].setattr(binval)
      self.sharedrs[ishr].hwwritten(0)
  def readShared(self):
    shr= vbexec.getsl("getShared()")
    # get first (lasthgrp1+1)=12 values of share resources from hw
    #shr2= vbexec.getsl("getShared2()"); shr=shr+shr2
    #print "readShared:",shr
    for ishr in range(len(shr)-1):
      v=shr[ishr]
      self.sharedrs[ishr].setattr(eval(v))
      self.sharedrs[ishr].hwwritten(1)
    vbexec.get1("hw2rates()");
    longs=vbexec.getline("getBCmasks()");
    self.str2masks(longs)
    for ishr in range(Ctpconfig.lastshrgrp1+4,Ctpconfig.lastshrgrp1+8):
      self.sharedrs[ishr].setattr('bitmap')
      self.sharedrs[ishr].hwwritten(1)
  def writeShared(self, cf=None):
    intselw= (self.sharedrs[9].getbinval()&0x01f) | \
             ((self.sharedrs[10].getbinval()&0x01f)<<5)
    allrare= self.sharedrs[11].getbinval()&1
    if cf:
      #writeit=1   # write always to file
      cmd="RBIF "
      #for ishr in range(len(self.sharedrs)):
      for ishr in range(Ctpconfig.lastshrgrp1+1):
        if ishr>=4 and ishr<=8:
          cmd= "%s%s:"%(cmd, str(self.sharedrs[ishr].getattr()))
        else:
          cmd= "%s0x%x:"%(cmd, self.sharedrs[ishr].getbinval())
      cmd=cmd[:-1]+"\n"
      cf.write(cmd)
      cmd="INTSEL 0x%x 0x%x\n"%(intselw, allrare)
      cf.write(cmd)
      cmd="BCMASKS %s\n"%(self.masks2str())
      cf.write(cmd)
      #write mask-patterns if available (than they will be used
      # instead of bitmap):
      for bcix in range(1,5):
        ishr= Ctpconfig.lastshrgrp1+(4-1)+bcix
        if self.sharedrs[ishr].value!='bitmap':
          cmd="BCMASK.%1d %s\n"%(bcix,self.sharedrs[ishr].value)
          cf.write(cmd)
    else:
      writeit=0   # update hw only if at least 1 changed
      cmd="setShared("
      for ishr in range(Ctpconfig.lastshrgrp1+1):
        if self.sharedrs[ishr].modified(): writeit=1
        cmd= "%s0x%x,"%(cmd, self.sharedrs[ishr].getbinval())
        self.sharedrs[ishr].hwwritten(1)
      cmd=cmd[:-1]+")"
      if writeit: vbexec.get1(cmd)
      writeit=0
      for ishr in range(Ctpconfig.lastshrgrp1+1,Ctpconfig.lastshrgrp1+3):
        if self.sharedrs[ishr].modified(): writeit=1
        self.sharedrs[ishr].hwwritten(1)
      cmd="setShared2(0x%x,0x%x)"%(intselw,allrare)
      if writeit: vbexec.get1(cmd)
      writeit=0
      for ishr in range(Ctpconfig.lastshrgrp1+4,Ctpconfig.lastshrgrp1+8):
        if self.sharedrs[ishr].modified(): writeit=1
        self.sharedrs[ishr].hwwritten(1)
      cmd="setBCmasks()\n"+self.masks2str()
      if writeit: 
        rcstr=vbexec.getline(cmd)
        #print "writeShared1:",rcstr,':'
        #rcstr2=vbexec.getoutput()
        #print "writeShared2:",rcstr2,':'
        #print "writeShared thread"
        #self.dooutmskthd=vbexec.cmdthread(cmd, self.dooutmsk)
        #print "writeShared thread:",self.dooutmskthd
  #def dooutmsk(self, outstr):
  #  print "dooutmsk:",outstr,":"
  #  vbexec.pwrite0(self.dooutmskthd,self.masks2str()+'\n')
  #  print "dooutmsk2:",outstr,":"
  def showShared(self):
    if self.shrtl:
      myw.RiseToplevel(self.shrtl); return
    else:
      self.shrtl= myw.NewToplevel("CTP shared resources", self.hideShared)
    self.shrtl.configure(bg=COLOR_SHARED)
    for shrres in self.sharedrs:
      shrres.show(self.shrtl)
    #vonint12fr= myw.MywFrame(self.shrtl, side=TOP, relief=FLAT)
    # show buttons activating PF circuits:
    pffr= myw.MywFrame(self.shrtl, side=TOP, relief=FLAT)
    pfbuts=[]
    for pf in self.pfs:
      pfbuts.append(["PF-L%1d"%pf.level, pf.show]) 
    myw.MywHButtons(pffr, pfbuts)   
    #myw.MywHButtons(self.shrtl, pfbuts)   
  def modint12(self, bitstoshift):
    if bitstoshift==5:
      intsel= self.int2b.getEntry()
      self.interactionsel= (self.interactionsel&0x01f) | (intsel<<5)
    elif bitstoshift==0:
      intsel= self.int1b.getEntry()
      self.interactionsel= (self.interactionsel&0x3e0) | intsel
    else:
      IntErr("bad parameter in Ctpconfig.modint12:"+str(bitstoshift))
  def hideShared(self,event):
    #print "hideShared:"
    self.shrtl=None
  def showFOs(self):
    #self.hideds=0
    if self.fotl:
      myw.RiseToplevel(self.fotl); return
    else:
      self.fotl= myw.NewToplevel("CTP fanout boards", self.hideFOs)
    self.fotl.configure(bg=COLOR_FOS)
    for fanout in self.fanouts:
      fofr= myw.MywFrame(self.fotl, side=LEFT, bg=COLOR_FOS)
      fanout.show(fofr)
  def hideFOs(self, event):
  #  self.hideds=self.hideds+1
    #print "hideFOs:" #,self.hideds
    self.fotl= None
  def findFO(self,fonumber):
    for fo in self.fanouts:
      if fonumber==fo.fonumber: return fo
    return None
  def findPFC(self,pfcirc):
    for pfb in self.pfs:
      if pfcirc[0]==pfb.level:
        for pfc in pfb.pfs:
          if pfcirc[1]==pfc.pfnumber[1]: return pfc
    return None
  def cmdallenabled(self, setv=None):
    if setv==None:
      self.allorenabled= 1-self.allorenabled
    else:
      if self.allorenabled==setv: return
      self.allorenabled= setv
    a=""" not necessary (done in doCanvas)
    if self.allorenabled==1:
      aetx=Klas.txenabled
    else:
      aetx=Klas.txall
    self.cmdbuts.buttons[0].setLabel(aetx)
    """
    self.canvas.destroy(); self.doCanvas()
  def masks2str(self):
    s=''
    for v in self.bcmasks:
      s= s+"%x"%v
    return s
  def str2masks(self,longs):
    if len(longs) != ORBITLENGTH:
      IntErr("short string (%d<3564) from getBCmasks()"%len(longs))
    else:
      for ix in range(len(self.bcmasks)):
        try:
          self.bcmasks[ix]= eval('0x'+longs[ix])
        except:
          print "except str2masks:", ix, longs[ix],longs
    for ishr in range(Ctpconfig.lastshrgrp1+4,Ctpconfig.lastshrgrp1+8):
      self.sharedrs[ishr].setattr('bitmap')
      self.sharedrs[ishr].hwwritten(0)
class TrgSHR:
  """Shared resource properties:
  - probably single VME register for BC1/2,RND1/2
  - string for BCM1-4, L0func1, L0func2
  """
  BCxHelp="""Scaled-down BC. 
Class L0 trigger condition is: L0input AND BCx AND RNDx.
BCx (x=1..2) and RNDx (x=1..2) is applicable for any Class
The number entered here represents number of BCs between two
pulses generated by BC-downscaled generator
0:         -always 1 (i.e. pulse in each BC)
0x7fffffff -pulses are not generated
"""
  RNDxHelp="""Random trigger. 
Class L0 trigger condition is: L0input AND BCx AND RNDx.
BCx (x=1..2) and RNDx (x=1..2) is applicable for any Class
0 -trigger never produced

Following special syntax can be used for this field:
bN  where N is the average number of BC between 2 triggers,
Examples:
b0   -always 1 (in each BC)
b3   -in average, 3 BC between 2 triggers"""
  BCMxHelp="""BC mask. 
There are 4 BC mask applicable (as 4 vetos) for any Class.
If more BCmasks are enabled, the resulting BCmask is
logical OR of all of them.
One BC mask contains 3564 bits.
BCMx[bcnumber] (bcnumber=1..3564) bit set to 1 vetos possible
trigger in that BC.
\"bitmap\" in BC mask field denotes \"bit map definition\" -it 
can be viewed by pressing Mask name (BCM1-4) button.
Otherwise, the BCmask field contains \"PATTERN definition\" which has
the following syntax:
L or l    -means '0' or don't care
H or h    -means '1' or 'this BC is masked'
()        -can be used for grouping repeated patterns
Examples:
2l4h      means 001111
2h 3(lhl) means 11010010010
1000L H 2562L   means masking just BC number 1001
"""
  L0FUNxHelp="""INTfun1, INTfun2, INTfunT (interaction functions) and
L0fun1, L0fun2 (L0 functions) are programmable functions of the first 
four CTP L0 inputs. 
These functions are defined by 16 bits Lookup table (LUT).
"""
  INTxHelp="""Interaction selector
"""
  AllRareHelp="""All/Rare selector
"""
  #UnnecessaryCode="""
  def __init__(self, name, helptext=None):
    self.name=name
    self.helptext=helptext
    # 3 types of shared resources:
    if name[:3]=='BCM':                           #mask (3564 bits)
      self.value="3564L"
      self.showme= self.showsingle
    elif name[:6]=='L0FUN1' or name[:4]=='INTT':  # LUT (4 inputs)
      self.value= AttrLUT(name,["a&b&c&d",4,0], helptext)
      self.showme= self.value.show
    elif name[:6]=='L0FUN2' or name[:3]=='INT':
      self.value= AttrLUT(name,["a|b|c|d",4,0], helptext)
      self.showme= self.value.show
    else:
      self.value= Attr(name,0,helptext)           # single register
      self.showme= self.value.show
  def showsingle(self,master):
    self.ebut= myw.MywEntry(master, label=self.name,side=TOP,
      helptext=self.helptext, bind='lr', expandentry='no',
      bg=COLOR_SHARED,
      defvalue=str(self.value), cmdlabel=self.updt)
  def show(self, master):
    self.showme(master)
  def hide(self):
    self.ebut.destroy()
  def updt(self, event=None):
      self.setValue(self.ebut.getEntry())
  def setValue(self, newvaluetxt):
    if self.name[0:3]=='BCM' or self.name[0:5]=='L0FUN' or\
      self.name[0:3]=='INT':
      self.value=newvaluetxt
    else:
      self.value=int(newvaluetxt)
    #print "TrgSHR.updt:",self.value
  def save2file(self):
    #outfile.write(self.name+' '+str(self.value)+'\n')
    if self.name== 'INTTneverlikethat':
      asbits= ' ='+hex(txtproc.log2tab(self.value,["i1","i2","i3","i4"]))
    else:
      asbits=''
    print self.name+' '+str(self.value) + asbits
  #"""
class Klas(Genhw):
  txenabled="Show only enabled classes"
  txall="Show all classes"
  bitWidth=10   # including border lines
  bitHeight=18
  bitBorder=1
  interspace=1
  l0allinputs=30   # numb. of valid bits in L0_CONDITION_n word
  l0allvetos=10    # numb. of L0 vetos in L0_VETO_n word
  l0inputs=24
  #l0vetos=Klas.bitWidth*24 +Ctpconfig.l0x0+ Klas.interspace
  l0vetosx0=bitWidth*l0allinputs + Ctpconfig.l0x0 + interspace
  # 15 -2 vetos overwritten
  l0scalerx0= l0vetosx0+ bitWidth*10 + interspace
  colDontCare='#ff0000'    # red
  colValid='#009900'       #dark green
  colValidInv='#00ff66'
  colHelpBg='#ccffff'
  #colCluster=("white",'#cc00ff','#ffff00','#ccffcc','#ccff00',
  #  '#66ffff','#6600ff')
  colCluster=('black','brown','red','orange','yellow','green','blue')
  def __init__(self,ctpcfg, number, inputs=0, vetos=0, scaler=0):
    Genhw.__init__(self)
    self.clnumber=number      # hw. number of the class (1-50)
    self.linenumber= 0        # line number on Canvas (1...) 0-not displayed
    self.ctpcfg=ctpcfg
    self.l0inputs=inputs
    self.l0inverted=0x2f
    self.l0vetos=vetos        # bit16:classmask
    self.scaler=0
    self.clusbitid=None       # cluster bit id (canvas item)
    #self.iinvetos[i] -> position of bit in self.l0vetos
    self.iinvetos= range(4,13)+[16]   # bit numbers in self.vetos
  def readhw(self, line=None):
    #print "Klas.readhw: fake read"
    #self.l0inputs=0x55555555
    #self.l0inverted=1
    #self.l0vetos=0x55555555 & 0xfffffff8   # cluster=0 (i.e. not assigned)
    #self.scaler=10
    if line:
      c5txt= string.split(line)
      self.hwwritten(0)
    else:
      c5txt= vbexec.get1("getClass("+str(self.clnumber)+")")
      self.hwwritten(1)
    #print "c5:",c5, self.clnumber
    c5= map(eval, c5txt)
    self.l0inputs= c5[0]    #30 bits
    self.l0inverted= c5[1]  #24 bits
    self.l0vetos= c5[2]     #16 bits. bit16:CLassMask,bit0-12->see hw
    self.scaler= c5[3]
  def writehw(self,cf=None):
    if cf:
      fmt="CLA.%02d 0x%x 0x%x 0x%x 0x%x\n"
      cmdout= cf.write
    else:
      fmt="setClass(%d,0x%x,0x%x,0x%x,0x%x)"
      cmdout= vbexec.get2
      self.hwwritten(1)
    cmd=fmt%(self.clnumber, self.l0inputs,self.l0inverted, 
      self.l0vetos,self.scaler)
    #vbexec.get2(cmd)
    cmdout(cmd)
  def doClass(self):
    if self.linenumber!=0:
      IntErr("doClass:linenumber:%d !=0"%self.linenumber)
    self.linenumber= self.ctpcfg.freenumber   # line number on Canvas
    self.ctpcfg.freenumber= self.ctpcfg.freenumber+1
    #self.canvas.create_rectangle(0,0,200,10, fill='blue')
    self.ctpcfg.canvas.create_text(1,
      self.linenumber*Klas.bitHeight - Klas.bitBorder + Ctpconfig.l0y0, 
      anchor=NW,text=str(self.clnumber))
    self.doScaler()
    self.doL0Inputs(); self.doVetos();  # calls doCluster
  #def hideClass(self):
  #  if self.linenumber==0:
  #    IntErr("hideClass: linenumber %d!=0"%linenumber)   
  def refreshClass(self):
    for i in range(Klas.l0allinputs):
      self.refreshL0bit(i)
    for i in range(Klas.l0allvetos):
      self.refreshVetobit(i)
    self.refreshScaler()
    self.refreshCluster()
  def getCluster(self):
    rc= self.l0vetos&7
    if rc>6: 
      IntErr(" L0_VETO.ClusterCode >6 for class "+str(self.clnumber))
      rc=0
    #print "getCluster:",self.clnumber,self.linenumber,rc
    return rc
  def setCluster(self,cluster):
    self.l0vetos= self.l0vetos&0xfffffff8 | cluster&7
    self.refreshCluster()
    self.hwwritten(0)
  def refreshCluster(self):
    cluster=self.getCluster()
    if self.clusbitid:
      self.ctpcfg.canvas.itemconfigure(self.clusbitid,
      fill=Klas.colCluster[cluster])
      #debilina self.ctpcfg.canvas.tag_bind(self.clusbitid, "<Enter>", enthandler)
    if cluster>0:
      self.clushlp="Cluster "+str(cluster)
    else:
      self.clushlp="Cluster not assigned"
  def doCluster(self):
    xy= (Ctpconfig.clusterx0, \
      self.linenumber*Klas.bitHeight - Klas.bitBorder + Ctpconfig.l0y0)
    cluster= self.getCluster()
    #color= Klas.colCluster[cluster]
    self.clusbitid=self.ctpcfg.dobit(xy, Klas.colCluster[cluster], "XX"+str(self.clnumber))
    handler= lambda e,s=self,k=cluster:s.clusterhandler(e, k)
    self.ctpcfg.canvas.tag_bind(self.clusbitid, "<Button-1>", handler)
    self.refreshCluster()
  def clusterhandler(self,event, clustern):
    #print "clusterhandler: class# cluster",self.clnumber,clustern,self.linenumber
    xy= [Ctpconfig.l0x0-Klas.bitWidth/2,
         Ctpconfig.l0y0+ Klas.bitHeight*self.linenumber]
    #self.clentry= self.ctpcfg.doEntry(xy, self.modCluster)
    self.newclss=[]
    for newcl in range(7):
      bitid=self.ctpcfg.dobit(xy, Klas.colCluster[newcl], 
        "New cluster:"+str(newcl))
      xy[0]= xy[0]+ Klas.bitWidth
      handler= lambda e,s=self,k=newcl:s.clha2(e, k)
      self.ctpcfg.canvas.tag_bind(bitid, "<Button-1>", handler)
      #self.ctpcfg.canvas.tag_bind(bitid, "<Leave>", handler,add='+')
      self.newclss.append(bitid)
      #self.vetobitids.append(bitid)
  def clha2(self, event, newclust):
    #print "clha2:",newclust,dir(event)
    #print "clha2:",event.keysym_num,event.keycode,event.num,event.type
    # 0 0 0 8 <Leave>
    # 1 1 1 4 <Button-1>
    for bitid in self.newclss:
      self.ctpcfg.canvas.delete(bitid)
    if newclust != self.getCluster():
      self.setCluster(newclust)
  def doL0Inputs(self, inps=None):
    """todo: doL0inpu1()
    """
    if inps: self.l0inputs=inps
    self.l0inpbitids=[]
    for i in range(Klas.l0allinputs):
      xy= (i*Klas.bitWidth - Klas.bitBorder + Ctpconfig.l0x0, \
        self.linenumber*Klas.bitHeight - Klas.bitBorder + Ctpconfig.l0y0)
      # 24,25: random,  26,27:Scaled-down BC, 28,29 L0function
      if i==24:
        hlptext="L0 function 1"
      elif i==25:
        hlptext="L0 function 2"
      elif i==26:
        hlptext="L0 random 1"
      elif i==27:
        hlptext="L0 random 2"
      elif i==28:
        hlptext="L0 scaled-down 1"
      elif i==29:
        hlptext="L0 scaled-down 2"
      else:
        hlptext="L0 input "+str(i+1)
      bitid= self.ctpcfg.dobit(xy,hlptxt=hlptext)
      self.l0inpbitids.append(bitid)
      handler= lambda e,s=self,k=i:s.modL0handler(e, k)
      self.ctpcfg.canvas.tag_bind(bitid, "<Button-1>", handler)
      if self.clnumber>=45 and i<Klas.l0inputs:
        self.ctpcfg.canvas.tag_bind(bitid, "<Button-2>", handler)
        #print "dobit %d:inverted"%(bitposition)
      self.refreshL0bit(i)
    xy1= (24*Klas.bitWidth - Klas.bitBorder + Ctpconfig.l0x0, \
      self.linenumber*Klas.bitHeight + Klas.bitBorder + Ctpconfig.l0y0)
    xy2= (xy1[0], xy1[1]+Klas.bitHeight - 3*Klas.bitBorder)
    self.ctpcfg.doline(xy1, xy2, "white", 2*Klas.bitBorder)
  def refreshL0bit(self,ibit):
    # ibit:0-29
    bitn= 1<<ibit
    if self.l0inputs & bitn==0:
      if self.clnumber>=45 and ibit<Klas.l0inputs:
        if self.l0inverted & bitn:
          color= Klas.colValidInv;
        else:
          color= Klas.colValid;
      else:
        color= Klas.colValid;
    else:
      color= Klas.colDontCare
    self.ctpcfg.canvas.itemconfigure(self.l0inpbitids[ibit],fill=color)
  def testhandler(self,event, klasbit):
    #print "testhandler. event x y:",event.x, event.y
    print "testhandler. event:",event
    print "testhandler. class# klasbit:",self.linenumber,klasbit
    #print self.ctpcfg.canvas,'\n',event.widget
  def modL0handler(self,event, klasbit):
    """klasbit: 0..
    """
    #print "modL0handler1:", klasbit,self.l0inputs
    #print "modL0handler2:", event, dir(event)
    #print "modL0handler3:", event.keycode
    mi= self.l0inputs& (1<<klasbit)
    if event.keycode==1:
      self.l0inputs= InvertBit(self.l0inputs, klasbit )
    if event.keycode==2:
      self.l0inverted= InvertBit(self.l0inverted, klasbit )
    #print "modL0handler2:", self.l0inputs
    self.refreshL0bit(klasbit)
    self.hwwritten(0)
  def doVeto1(self, ibitcanvas):
    #ibitcanvas: 0..9
    #print "doVeto1:",ibitcanvas
    i= self.iinvetos[ibitcanvas]
    xy= (ibitcanvas*Klas.bitWidth - Klas.bitBorder + Klas.l0vetosx0, \
      self.linenumber*Klas.bitHeight - Klas.bitBorder + Ctpconfig.l0y0)
    if i>=4 and i<=7:
      hlptext="P/F "+str(i-3)
    elif i>=8 and i<=11:
      hlptext="BCmask "+str(i-8+1)
    elif i==12:
      #if self.l0vetos & (1<<self.iinvetos[ibitcanvas]):
      hlptext="All/Rare red->1 green->0"
      #else:
      #  hlptext="All/Rare now Rare"
    elif i==16:
      hlptext="Class Mask"
    else:
      IntErr("doVeto1")
    bitid= self.ctpcfg.dobit(xy, hlptxt=hlptext)
    handler= lambda e,s=self,k=ibitcanvas:s.modVetohandler(e, k)
    self.ctpcfg.canvas.tag_bind(bitid, "<Button-1>", handler)
    self.vetobitids.append(bitid)
    self.refreshVetobit(ibitcanvas)
  def refreshVetobit(self, ibit):
    vetobit= self.iinvetos[ibit] 
    if self.l0vetos & (1<<vetobit):
      color=Klas.colDontCare
    else:
      color=Klas.colValid
    #print "refreshVetobit: canvasbit:",ibit," vetobit:", vetobit
    self.ctpcfg.canvas.itemconfigure(self.vetobitids[ibit],fill=color)
  def doVetos(self, vetos=None):
    if vetos:self.l0vetos=vetos
    self.doCluster()   # let's keep it with vetos (1 common vme word)
    self.vetobitids=[]
    for ibitcanvas in range(Klas.l0allvetos):
      self.doVeto1(ibitcanvas)
  def modVetohandler(self,event,canvbit):
    #if klasbit==9:   #Class mask
    #print "modVetohandler:",event,canvbit
    # VME L0_MASK word will be updated according to self.l0vetos[31] bit
    self.l0vetos= InvertBit(self.l0vetos, self.iinvetos[canvbit] )
    self.refreshVetobit(canvbit)
    self.hwwritten(0)
  def doScaler(self):
    xy= (Klas.l0scalerx0, \
      #self.linenumber*Klas.bitHeight)
      self.linenumber*Klas.bitHeight - Klas.bitBorder + Ctpconfig.l0y0)
    self.scalentry= self.ctpcfg.doEntry(xy, self.modScaler)
    self.refreshScaler()
  def refreshScaler(self):
    percentrate=str(self.scaler)
    #if self.scaler==0: percentrate="%100"
    #percentrate= "%%%5.2f"%(100-self.scaler*100./0x1fffff)
    self.scalentry.setEntry(percentrate)
  def modScaler(self,event):
    ntv=self.scalentry.getEntry(); ratemsg=None
    try:
      if ntv[0]=='%':   # 21bits, 0->max. rate, 1fffff->min rate
        pr= float(ntv[1:])
        newscaler= int(round((100-pr)*0x1fffff/100))
        ratemsg="%s -> %d(0x%x) rate for class %d\n"%\
          (ntv, newscaler,newscaler,self.clnumber)
      else:
        newscaler=self.scalentry.getEntryBin()
    except:
      newscaler=0
      ratemsg="Error:%s -bad rate for class %d, 0 used instead\n"%\
        (ntv, self.clnumber)
    #print "modScaler:", self.scaler  #, dir(event)
    if newscaler!= self.scaler:
      self.scaler= newscaler
      self.refreshScaler()
      self.hwwritten(0)
      if ratemsg: vbexec.printmsg(ratemsg)

class FanoutCon:
  def __init__(self,fo,connector, clusters=0, roc=0, detname=''):
    self.fo= fo                # Fanout instance it belongs to
    self.connector=connector   # 1..4
    # Toggle bit + clusters it belongs to (bits:XT654321)
    self.clusters=clusters     
    self.roc= roc                # RoC bits 4..1
    if detname=='':
      self.detname="ltu"+ str((self.fo.fonumber-1)*4 + connector)
    else:
      self.detname=detname
    self.mb=None               # not shown
  def showrefresh(self, fr=None):
    """ Show connector, or refresh the hw and widget (fr==None)
    fr==None: we are called from readhw 
              - refresh widget if self.mb!=None
    fr!=None: display new widget only
    """
    if fr !=None:
      if self.mb:
        print "FanoutCon.show: self.mb already exists, but fr!=None"
        return
      else:         # refresh
        # refresh hw part 
        pass
    if self.mb:   #refresh
      self.mb.setEntry(self.clusters)
      self.rocw.setEntry(self.roc)
    else:
      if fr:
        connfr= myw.MywFrame(fr, relief=FLAT)
        self.mb= myw.MywBits(connfr, side=LEFT, relief=FLAT,
          defval= self.clusters, label=self.detname,
          cmd= self.modclusters, bits=["1","2","3","4","5","6","T","X"],
          helptext="""Clusters this fanout connector belongs to
1,2,3,4,5,6 and T-test cluster and TOGGLE bit (X), which
set the 'toggling L1 data' on corresponding connector.
Toggle bit is valid when 'real_out' is enabled -i.e. SSMEnable[0] (Output
flag bit) is 0. If SSMEnable[0]==1, 
""")
        self.rocw= myw.MywEntry(connfr,label='',
          bind='lr', defvalue=str(self.roc), relief=SUNKEN,
          width=3, side=RIGHT, cmdlabel= self.modroc)
  def modclusters(self):
    newclus= self.mb.getEntry()
    #print "FanoutCon:",hex(newclus)
    if newclus!=self.clusters:
      self.fo.hwwritten(0)
      self.clusters= newclus
  def modroc(self,ev):
    newroc= self.rocw.getEntry()
    #print "FanoutCon.modroc:",newroc
    try:
      enewroc= eval(newroc)
    except:
      self.rocw.setEntry(str(self.roc))
    else:
      if enewroc!=self.roc:
        self.fo.hwwritten(0)
        self.roc= enewroc

class Fanout(Genhw):
  def __init__(self, fonumber, ctc=None):
    """ fonumber: 1..6   ctc="0xcluster 0xtestcluster"
    """
    self.fowidget=None   # not shown
    self.fonumber= fonumber   # 1..6 (+4 to get position in ctpboards)
    self.cons=[]              # list of 4 connectors
    self.calflag=0
    for ix in range(4):
      self.cons.append(FanoutCon(self, ix+1))
    Genhw.__init__(self)
    self.readhw(ctc)
  def readhw(self,line=None):
    """Set Fanout attributes according to ctc. If ctc==None, read HW
    refresh displayed widget, if any
    """
    if line:
      ctctx= string.split(line)
      self.hwwritten(0)
    else:
      ctctx= vbexec.get1("getFO("+str(self.fonumber+4)+")")   # cct: [cl, tcl]
      self.hwwritten(1)
    ctc= map(eval, ctctx)
    self.calflag= (ctc[1]&0x100000)>>20      # cal. flag (0 or 1)
    if self.fowidget: self.cfw.setEntry(self.calflag)
    for ix in range(4):   #all front panel connectors
      clu= (ctc[0] & (0x3f<< (ix*8))) >>(ix*8)    # clusters
      clu= clu | (( (ctc[1]>>(ix+16)) & 1) <<6)   # test cluster
      clu= clu | (( (ctc[1]>>(ix+28)) & 1) <<7)   # toggle
      roc= (ctc[1] >> 4*ix) & 0xf
      self.cons[ix].clusters= clu
      self.cons[ix].roc= roc
      self.cons[ix].showrefresh()
  def writehw(self, cf=None):
    """ prepare cluster and testcluster words for this FO
    and write them to the board
    """
    clu=0; tclu= 0;
    for ix in range(4):
      clu= clu | (( self.cons[ix].clusters & 0x3f) << (8*ix))
      tclu= tclu | \
        (( self.cons[ix].roc & 0xf) << (4*ix)) |\
        (( self.cons[ix].clusters>>6)&1) << (16+ix) |\
        (( self.cons[ix].clusters>>7)&1) << (28+ix) 
    tclu= tclu | (self.calflag<<20)
    if cf:
      fmt= "FO.%d 0x%x 0x%x\n"
      fonum= self.fonumber
      cmdout=cf.write
    else:
      fmt= "setFO(%d,0x%x,0x%x)"
      fonum= self.fonumber+4
      cmdout=vbexec.get1
      self.hwwritten(1)
    cmd= fmt%(fonum,clu,tclu)
    cmdout(cmd)
  def show(self, fr):
    """fr -Frame in which the Fanout attributes will be shown
    """
    if self.fowidget:
      print "Fanout.show: self.fowidget already exists"
      return
    self.fowidget= fr
    self.hideds=0
    self.fowidget.bind("<Destroy>", self.hideFO)
    self.title= myw.MywLabel(self.fowidget,label="fo"+str(self.fonumber),
      bg=COLOR_FOS,
      helptext="""Fanout widget.
For each of 4 fanout connectors, the clusters to which the connector
is assigned are shown""")
    self.cfw= myw.MywBits(self.fowidget, relief=FLAT,
          defval= self.calflag, label='CalFlag',
          cmd= self.modcflag, bits=["yes"],
          helptext="""Calibration flag for this FO. This flag
should be the same for all FOs.
""")
    fr2= myw.MywFrame(self.fowidget, relief=FLAT)
    for ix in range(4):
      self.cons[ix].showrefresh(fr2)
  def modcflag(self):
    newcflag= self.cfw.getEntry()
    if newcflag!= self.calflag:
      self.hwwritten(0)
      self.calflag= newcflag
  def hideFO(self, event):
    self.hideds=self.hideds+1
    #print "hideFO:",self.fonumber,self.hideds
    for c in self.cons:
      c.mb=None   #garbage collector frees the rest
    self.fowidget= None

class MywLUT(myw.MywEntry):
  """ value=("LUT expression", number_of_inputs)
  """
  expnames=["a","b","c","d"]
  def __init__(self,master, value, **kw):
    #print "mywLUT:", master, value,kw
    selfargs=(self,master)
    self.ninputs= MywLUT.expnames[0:value[1]]
    kw['helptext']= kw['helptext']+"""

Look up table can be given:
- directly as hexa/decimal number (e.g. 0xfa/250) when input 
  field is GRAY or as
- logical function of input variables"""+str(self.ninputs)+"""
  when input field is of PINK color.

  Use following logical operators for logical function definition:
|  -OR                        &  -AND
^  -exclusive OR              ~  -negation
() -for grouping operations with higher priority
0  = 0 on output for any input combination (the same result
     can be reached by entering 0x0 in gray field
1  = 1 on output for any input combination (the same result
     can be reached by entering 0xffff in GRAY field (for LUT with 4 inputs,
     i.e. 16 possible output values)

Example:
a &b | (a|b)     (should result in 0xe LUT given as 4 bits)  
"""
    kw['defvalue']=value[0]
    apply(myw.MywEntry.__init__,selfargs, kw)
    #von self.entry.bind("<Button-3>",self.convertStart)
    #MywEntry.__init__(self, master, kw)
    #self.setEntry(value[0])
  def updateentry(self, event=None):
    newlut= self.getEntry()
    #print "MywLUT.updateentry: ninputs,old,new",self.ninputs,newlut
    # check newlut, if OK call cmdlabel, if not, set back old value
    newluthex= txtproc.log2tab(newlut, self.ninputs)
    if newluthex:
      if self.conv2dec==1:
        # no error, LUT expression
        self.lutexp= newlut
        self.luthex= newluthex
      else:
        # no error, LUT hexadecimally
        self.lutexp= newlut    # expression is lost
        self.luthex= newluthex
      if self.cmdlabel: self.cmdlabel((self.lutexp,self.luthex))
    else:
      # error, LUT expression or hexadecimally
      PrintError("bad LUT expression:%s, not assigned"%newlut)
    self.showEntry()
  def showEntry(self):
    self.entry.delete(0, 'end')
    if self.conv2dec==1:
      self.setColor(COLOR_LUT)
      self.entry.insert(0, self.lutexp)
    else:
      self.setColor(myw.COLOR_BGDEFAULT)
      self.entry.insert(0, self.luthex)
  #def getEntry(self):
  #  return self.luthex
  def setEntry(self,luttext):
    #self.conv2dec: 0:          1:           2: no conversion
    #                  show hex    show LUT     not allowed
    # text: valid LUT-expression
    newluthex= txtproc.log2tab(luttext, self.ninputs)
    if newluthex:
      self.lutexp= luttext
      self.luthex= newluthex
    else:
      PrintError("bad LUT expression:%s, not assigned"%luttext)
      self.lutexp= "n/a"
      self.luthex= 0
    self.conv2dec=1      # show LUT expression
    self.showEntry()
    #errorprint(self,"bad self.hec2dex:%d"%self.conv2dec)
  def convertStart(self,event=None):
    #print "lutconvertStart:"
    if self.conv2dec==0:
      self.conv2dec=1
    else:
      self.conv2dec=0
    self.showEntry()

class MywBCmask(myw.MywEntry):
  def updateentry(self, event=None):
    """event is None in case of activation by button..."""
    #print "MywEntry:",self.getEntry(),event
    ne= self.entry.get()
    self.cmdlabel(ne, event)
  def convertStart(self,event=None):
    print "MywBCmask.convertStart"
    pass

class Attr(Genhw):
  """Info about 'hw written' is set by class itself
    (if modified from the screen) or from outside
    (if set from outside)
  """
  def __init__(self, atrname, value, helptext=None, cci=None):
    """
    value: number (hexa or dec) (simple value)
      list:  of 2 values, or 
      list: ["LUT expression", number_of_inputs, 0] or
      string "3l45H"
    cci: ctpcfg instance
    """
    Genhw.__init__(self)
    self.atrname=atrname     
    #prt(self,"atrname:",atrname, "value:",value)
    self.value=value     
    self.helptext=helptext     
    self.cci=cci     
    self.atrw= None     # associated widget not shown
  def setattr(self, value):
    #print "setattr.atrw:",self.atrw
    self.value=value     
    if self.atrw: self.atrw.setEntry(str(value))
  def getattr(self):
    return self.value
  def getbinval(self):
    #print "Attr.getbinval:", self.value
    return self.value
  def bindparent(self, fr):
    fr.bind("<Destroy>", self.hideAttr, add='+')
  def show(self, fr,side=TOP):
    self.bindparent(fr)
    self.atrw= myw.MywEntry(fr,label=self.atrname,helptext=self.helptext,
      bind='lr', defvalue=str(self.value), relief=SUNKEN,
      width=8, side=side, cmdlabel= self.modatr)
  def hideAttr(self,ev):
    #print "Attr.hideAttr"
    self.atrw=None
  def modatrcommon(self, entwidget, oldbinvalue):
    newval= entwidget.getEntryBin()
    if newval=='': newval='0'
    #print "Attr.modatr:",newval
    #nbvalue= self.conv2bin(newval, oldbinvalue)
    nbvalue= newval
    if nbvalue != oldbinvalue:
      self.hwwritten(0)
    return nbvalue
  def modatr(self, ev=None):
    nbvalue= self.modatrcommon(self.atrw, self.value)
    self.value=nbvalue
  def conv2bin(self, newval, oldval):
    newvalint=oldval
    try:
      newvalint= eval(newval)
    except:
      myw.MywError("bad value: %s, integer or 0x... expected"%newval)
      #self.atrw.setEntry(str(self.value))
    return newvalint
  #def save2file(self, cf):
  #  line= "%s %s\n"%(self.atrname, str(self.value))
  #  cf.write(line)
#class AttrRate(Attr):
#  def modatr(self, ev=None):
#    ntv= self.atrw.getEntry()
#    if ntv[0]=='%':   # 21bits, 0->max. rate, 1fffff->min rate
#      pr= float(ntv[1:])
#      rr= int(round((100-pr)*0x1fffff/100))
#      self.atrw.setEntry(hex(rr))
#    nbvalue= self.modatrcommon(self.atrw, self.value)
#    self.value=nbvalue
class AttrRndgen(Attr):
  def modatr(self, ev=None):
    ntv= self.atrw.getEntry()
    if ntv[0]=='b':
      rr= int(ntv[1:])+1
      rr= 0x7fffffff/rr
      self.atrw.setEntry(hex(rr))
    nbvalue= self.modatrcommon(self.atrw, self.value)
    self.value=nbvalue
class AttrBCmask(Attr):
  def show(self, fr,side=TOP):
    #print "show:",self.value
    self.bindparent(fr)
    #cmd=myw.curry(self.modint12, 0) ,helptext=
    self.atrw= MywBCmask(fr,label=self.atrname,helptext=self.helptext,
      defvalue=self.value, relief=SUNKEN,
      width=8, side=side, cmdlabel= self.modatr)
    self.atrw.entry.bind("<Leave>", self.atrw.updateentry)
    self.atrw.entry.bind("<Key-Return>", self.atrw.updateentry)
  def modatr(self, newval, ev=None):
    #nmask= newval   # or self.atrw.getEntry()
    bit=int(self.atrname[3])-1   #BCM1-4
    #print "AttrBCmask.modatr:",newval,self.value,ev
    if ev==None:
      #print "AttrBCmask: label cmd"
      vbexec.printmsg(self.cci.masks2str()+'\n')
      return
    if newval == 'bitmap': return
    if newval != self.value:
      #check correctness:
      bm=txtproc.BCmask(newval)
      errmsg= bm.setbits([self.cci.bcmasks, bit])
      if errmsg!=None:
        vbexec.printmsg(errmsg)
        if errmsg[:4]=="Warn": errmsg=None
      if errmsg==None:
        #print "->modatr:",self.cci.bcmasks[0:9]
        self.value= newval
        self.hwwritten(0)
    #return nbvalue
class AttrBits(Attr):
  def __init__(self,*fixedarg, **kw):
    fa= tuple([self]+list(fixedarg))
    #print "AttrBits.init:",fixedarg,fa
    #print "AttrBits.init:",kw
    self.bits=kw['bits']
    del kw['bits']
    #fixedarg= [self]+fixedarg
    apply(Attr.__init__,fa, kw)
  def show(self, fr,side=TOP):
    #print "show:",self.value
    self.bindparent(fr)
    #cmd=myw.curry(self.modint12, 0) ,helptext=
    self.atrw=myw.MywBits(fr, side=TOP, defval= self.value,
      label= self.atrname, bits=self.bits,
      cmd=self.modatr ,helptext=self.helptext) 
  def setattr(self, value):
    #print "Attrbits.setattr.atrname,value,atrw:",self.atrname,hex(value),self.atrw
    self.value=value     
    if self.atrw: self.atrw.setEntry(self.value)
class Attr2(Attr):
  """ value is list"""
  def getattr(self, ix=None):
    #print "getattr:",self.value
    if ix!=None:
      return self.value[ix]
    else:
      return self.value
  def setattr(self, value):
    #print "setattr.atrw:",self.atrw
    self.value=value     
    if self.atrw: 
      self.atrw.setEntry(str(value[0]))
      self.atrw2.setEntry(str(value[1]))
  def show(self, fr,side=TOP):
    #print "show:",self.value
    self.bindparent(fr)
    fratr= myw.MywFrame(fr, relief=FLAT, borderwidth=0, side=side)
    self.atrl= myw.MywLabel(fratr,label=self.atrname,expand='no',
      relief=SUNKEN,
      width=12, side=LEFT, helptext=self.helptext)
    self.atrw= myw.MywEntry(fratr,label='',expandentry='no',
      bind='lr', defvalue=str(self.value[0]), relief=SUNKEN,
      width=8, side=LEFT, cmdlabel= self.modatr)
    self.atrw2= myw.MywEntry(fratr,label='',expandentry='no',
      bind='lr', defvalue=str(self.value[1]), relief=SUNKEN,
      width=8, side=LEFT, cmdlabel= self.modatr2)
  def modatr(self, ev):
    #print "Attr.modatr:",self.value,newval
    nbvalue= self.modatrcommon(self.atrw, self.value[0])
    self.value[0]=nbvalue
  def modatr2(self, ev):
    #print "Attr.modatr2:",self.atrname,self.value,newval, type(newval)
    nbvalue= self.modatrcommon(self.atrw2, self.value[1])
    self.value[1]=nbvalue
class AttrLUT(Attr):
  def show(self, fr,side=TOP):
    #prt(self,'AttrLUT.show:',self.value)
    self.bindparent(fr)
    self.atrw= MywLUT(fr,self.value, label=self.atrname,helptext=self.helptext,
      bind='lr', relief=SUNKEN,cmdlabel= self.updatevals,
      width=8, side=side)
  def updatevals(self,new2):
    """new2 ("a&b", 0xde)   i.e. (text,hexa)
    """
    #prt(self,"updatevals:", new2)
    self.value[0]= new2[0]
    newbin= self.conv2bin(new2[1], self.value[2])   #binary value of LUT table
    if newbin != self.value[2]:
      self.value[2]= newbin
      self.hwwritten(0)
  #def setbinval(self, nv):
  #    self.value[2]= nv
  def setattr(self, val):
    # val: if val[], then val[0] is preferred to val[3]
    #print "LUTsetattr.atrw:",self.atrw
    if type(val)== types.IntType:
      self.value[2]= val        # bin. value of LUT
      self.value[0]= hex(val)   # text value of LUT
      if self.atrw: self.atrw.setEntry(self.value[0])
    elif type(val)== types.ListType:
      if len(val)==3:   # ! val[0] has to conform with val[2] !
        self.value=val
        self.value[2]= eval(txtproc.log2tab(self.value[0], self.value[1]))
        if self.atrw: self.atrw.setEntry(self.value[0])
      else:
        PrintError('For LUT expected e.g.: ["a&b",4,0x0f] but got:'+str(val))
    else:
      PrintError("bad value for LUT:"+str(val))
  def getbinval(self):
    #print "LUTgetbinval:", self.value
    return self.value[2]   #binary value of LUT table

class PFcircuit(Genhw):
  """ 15 instances (5 per board)
  """
  L0_L1time=(6.4-0.8)*1000       # L0 - L1 time in ns
  def __init__(self, pfnumber):
    """ pfnumber: (0..2,1..5)    5 -is dedicated for Test class only  
    """
    self.pfwidget=None   # not shown
    self.pfnumber= pfnumber # (0..2,1..5)
    self.attrs=[ Attr2("TH1",[0,0],            # 0
"Threshold1:  2x 6 bits for blocks A, B"), 
      Attr2("TH2",[0,0],                       # 1
"Threshold2:  2x 6 bits for blocks A, B"),
      Attr2("DeltaT",[0,0],                    # 2
"Protection interval: 2x 8 bits"), 
      Attr2("Delay",[0,0],                     # 3 (including flag in bit11)
"""2x 12 bits Delay for blocks A,B
Left most bit (0x800) represents the NO DELAY FLAG a/b
11 right bits represent delay a/b (they have no sense for L0 board)
"""),
      Attr2("Scaled-down",[0,0],               # 4
"Clock scaled-down factor: 2x 5 bits for blocks A,B"),
      AttrLUT("P signal LUT",["0x0",3,0],                   # 5
"Output P signal look-up table: 8 bits")]
    Genhw.__init__(self, self.attrs)
    self.readhw()
  def getwidths(self):
    widths=[]
    for ix in (0,1):
      dtx= self.attrs.value[2][ix]+1
      if dtx==1: dtx=257
      n= self.attrs.value[4][ix]+1
      w= dtx*n*25/40.    # in micsecs
      widths.append(w)
    print "PFcircuit:", self.pfnumber, widths, " micsecs"
  def readhw(self,line=None):
    """Set PFcircuit attributes according to pfpc. If pfpc==None, read HW
    """
    if line==None:
      #pftx= vbexec.get1("getPF("+str(self.pfnumber[0])+","+
      # str(self.pfnumber[1])+  ")")   # + board
      #pfpc= map(eval, pftx)
      #pfpc=[1,2,3,4,5,6,7,8,9,10,("P-lut",3)]
      line= vbexec.getline("getPFc(%d,%d)"%(self.pfnumber[0]+1, 
        self.pfnumber[1]))
      self.hwwritten(1)
    else:
      self.hwwritten(0) # from file (likely different from what is in hw)
    pfpctx= string.split(line)
    #prt(self, "getPFc():",pfpctx)
    p3= map(eval, pfpctx)
    self.attrs[0].setattr([p3[0]&0x3f, p3[1]&0x3f])
    self.attrs[1].setattr([(p3[0]>>6)&0x3f, (p3[1]>>6)&0x3f])
    self.attrs[2].setattr([(p3[0]>>12)&0xff, (p3[1]>>12)&0xff])
    self.attrs[3].setattr([(p3[0]>>20)&0xfff, (p3[1]>>20)&0xfff])
    self.attrs[4].setattr([(p3[2]>>8)&0x1f, (p3[2]>>13)&0x1f])
    self.attrs[5].setattr([hex(p3[2]&0xff),3,0])
    #if self.pfwidget:
    #  print "PFcircuit.readhw: updating pfwidget todo ->done in setattr"
  def conv2abl(self):
    blockab=[0,0,0];   # A, B, LUT
    for ix in (0,1):
      blockab[ix]= self.attrs[0].getattr(ix)
      blockab[ix]= blockab[ix] | ( self.attrs[1].getattr(ix)<<6)
      blockab[ix]= blockab[ix] | ( self.attrs[2].getattr(ix)<<12)
      blockab[ix]= blockab[ix] | ( self.attrs[3].getattr(ix)<<20)
    blockab[2]= self.attrs[5].getbinval()
    blockab[2]= blockab[2] | (self.attrs[4].getattr(0)<<8)
    blockab[2]= blockab[2] | (self.attrs[4].getattr(1)<<13)
    return blockab
  def writehw(self, cf=None):
    """ prepare PFBLOCK_A/B and PFLUT words
    and write them to the board
    """
    blockab= self.conv2abl()
    if cf:
      fmt= "PFL.%d.%d 0x%x 0x%x 0x%x\n"
      lvl= self.pfnumber[0]
      cmdout=cf.write
    else:
      fmt= "setPFc(%d,%d,0x%x,0x%x,0x%x)"
      lvl= self.pfnumber[0]+1
      cmdout= vbexec.get1
      self.hwwritten(1)
    cmd= fmt%(lvl, self.pfnumber[1],blockab[0],blockab[1],blockab[2])
    cmdout(cmd)
  def show(self, fr):
    """fr -Frame in which the PFcircuit attributes will be shown
    """
    if self.pfwidget:
      print "PFcircuit.show: self.pfwidget already exists"
      return
    self.pfwidget= fr
    self.pfwidget.bind("<Destroy>", self.hidePF)
    self.title= myw.MywLabel(self.pfwidget, side=TOP,
      label="PF"+str(self.pfnumber)+"              A                  B       ",
      helptext="""PFcircuit widget.
1 PF circuit consists of 2 identical blocks A and B.
""")
    for ix in range(len(self.attrs)):
      self.attrs[ix].show(self.pfwidget)
  #def refresh(self):
    #for ix in range(len(self.attrs)):
    #  self.cons[ix].showrefresh(fr2)
  def hidePF(self, event):
    self.pfwidget= None
  def getdeltaN(self, ns):
    """
    ns: interval in nanosecs
    returns: (number_of_intervals, resolution_in_25ns_steps) 
             ->(0..255,0..31,) 
    """
    if ns==0: return (0, 0)
    resolution=1;
    while(1):
      nmax= (ns-1)/25*resolution+1   # number of 25ns intervals
      if nmax<=255: 
        if self.pfnumber[0]==0:
          if nmax*resolution> PFcircuit.L0_L1time:
            print "pf-L2 to be set for %d (>%d)"%(ns,PFcircuit.L0_L1time)
        return (nmax, resolution-1, delay)
      resolution= resolution + 1
    PrintError("Too large prot. interval %d (max. 204000ns)"%(ns))
class PFboard(Genhw):
  """ 3 instances of this for 3 boards: L0, L1, L2"""
  def __init__(self, level):
    self.level= level     # 0,1,2
    self.thispftl=None    # this level not shown
    self.pfs=[]
    for pfonboard in (1,2,3,4,5):
      self.pfs.append(PFcircuit((level,pfonboard)))
    self.atrs=[
      AttrLUT("INTa LUT",["0x0",2, 0],
"INTa function look-up table: 4 bits"),
      AttrLUT("INTb LUT",["0x0",2, 0],
"INTb function look-up table: 4 bits"),
      AttrLUT("Delayed INT LUT",["0x0", 2, 0],
"Delayed INT signal look-up table: 4 bits"),
      Attr("INT signal delay",0,
"Delayed INT signal delay: 12 bits. These 12 bits are always 0 for L0 board")
      ]
    Genhw.__init__(self, self.atrs)
    self.readhw()   # read the whole board
  def readhw(self,line=None):
    """Set PFboard attributes according to ctc. If ctc==None, read HW
    """
    if line:
      ctctx=line
      self.hwwritten(0)
    else:
      ctctx= vbexec.getline("getPF("+str(self.level+1)+")") # ctctx: 'PF_COMMON'
      self.hwwritten(1)
    pfc= eval(ctctx)
    self.atrs[0].setattr([hex(pfc&0xf), 2,0])
    self.atrs[1].setattr([hex((pfc>>4)&0xf), 2,0])
    self.atrs[2].setattr([hex((pfc>>8)&0xf),2,0])
    self.atrs[3].setattr((pfc>>12)&0xfff)
    #if self.thispftl:
    #  print "PFboard.readhw: to do -update widget -> done in setattr"
    #if line==None:
    #  for ix in range(5):
    #    self.pfs[ix].readhw()
  def writehw(self, cf=None):
    """ prepare PF_COMMON word, write it and then 
    update all the 5 circuits
    """
    pfc= self.conv2pfc()
    if cf:
      fmt= "PFL.%1d 0x%x\n"
      lvl= self.level
      cmdout= cf.write
    else:
      fmt= "setPF(%d,0x%x)"
      lvl= self.level+1
      cmdout= vbexec.get1
    cmd= fmt%(lvl,pfc)
    if cf:
      cmdout(cmd)
      #for ix in range(len(self.pfs)):
      #  self.pfs[ix].writehw(cf)
    else:
      if self.modified():
        cmdout(cmd)
        self.hwwritten(1)
        #for ix in range(len(self.pfs)):
        #  if self.pfs[ix].modified():
        #    self.pfs[ix].writehw()
  def conv2pfc(self):
    pfc= self.atrs[0].getbinval()
    pfc= pfc | (self.atrs[1].getbinval()<<4)
    pfc= pfc | (self.atrs[2].getbinval()<<8)
    pfc= pfc | (self.atrs[3].getattr()<<12)
    return pfc
  def show(self,frbrd=None):
    if frbrd==None:
      if self.thispftl:
        myw.RiseToplevel(self.thispftl); return
      else:
        self.thispftl= myw.NewToplevel("PF-L"+str(self.level), self.hidePF)
      self.thispftl.configure(bg=COLOR_PFS)
      frbrd= self.thispftl
    pfsfr= myw.MywFrame(frbrd, side=TOP,relief=FLAT, bg=COLOR_PFS)
    for ix in range(len(self.pfs)):
      pffr= myw.MywFrame(pfsfr, side=LEFT, bg=COLOR_PFS)
      self.pfs[ix].show(pffr)
    pfcfr= myw.MywFrame(frbrd, side=TOP, relief=FLAT,bg=COLOR_PFS)
    for ix in range(len(self.atrs)):
      self.atrs[ix].show(pfcfr,LEFT)
  def hidePF(self,ev=None):
    #print "hidePF:",ev
    self.thispftl=None
def main():
  root=Tk()

  sys.path.append(cfdir+'/'+board[0])   # to find user gui routines
  ctp= Ctpconfig()
  ctp.doClasses() 
  #ctp.save2file() 
  root.mainloop()

if __name__ == '__main__':
    main()

