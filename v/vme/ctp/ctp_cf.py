self.baseAddr="0x820000"
self.spaceLength="0xd000"
self.vmeregs=[('CODE_ADD', '0x4', ''), ('SERIAL_NUMBER', '0x8', ''), ('VERSION_ADD', '0xc', ''), ('SOFT_RESET', '0x28', ''), ('TEMP_START', '0x58', ''), ('TEMP_STATUS', '0x5c', ''), ('TEMP_READ', '0x60', ''), ('FPGAVERSION_ADD', '0x80', ''), ('TEST_ADD', '0x7e0', ''), ('BC_STATUS', '0xc4', ''), ('SSMcommand', '0x19c', ''), ('SSMstart', '0x1a0', ''), ('SSMstop', '0x1a4', ''), ('SSMaddress', '0x1a8', ''), ('SSMdata', '0x1ac', ''), ('SSMstatus', '0x1b0', ''), ('SSMenable', '0x1b4', ''), ('PLLreset', '0x1bc', ''), ('ADC_START', '0xcc', ''), ('ADC_DATA', '0xd0', ''), ('SOFT_LED', '0x15c', ''), ('COPYCOUNT', '0x1d4', ''), ('COPYBUSY', '0x1d8', ''), ('COPYCLEARADD', '0x1dc', ''), ('COPYREAD', '0x1e0', ''), ('CLEARCOUNTER', '0x5ac', ''), ('SPY_MEMORY', '0x400', ''), ('SCOPE_SELECT', '0x4f8', ''), ('ADC_SELECT', '0x500', ''), ('SYNCH_ADD', '0x504', ''), ('PF_COMMON', '0x564', ''), ('PFBLOCK_A', '0x568', ''), ('PFBLOCK_B', '0x56c', ''), ('PFLUT', '0x570', ''), ('FO_CLUSTER', '0x240', ''), ('FO_TESTCLUSTER', '0x244', ''), ('FO_DELAY_L1CLST', '0x248', ''), ('FO_FILTER_L1', '0x84', ''), ('BUSY_DELAY_ADD', '0x84c8', ''), ('BUSY_ORBIT_SELECT', '0x80d4', ''), ('BUSY_DISB_CTP_BUSY', '0x80d8', ''), ('BUSYMAX_DATA', '0x8168', ''), ('BUSYMINI_DATA', '0x816c', ''), ('MINIMAX_SELECT', '0x8570', ''), ('MINIMAX_CLEAR', '0x8174', ''), ('MINIMAX_LIMIT', '0x8578', ''), ('BUSYLAST_SELECT', '0x857c', ''), ('BUSY_CLUSTER', '0x8600', ''), ('BUSY_DAQBUSY', '0x861c', ''), ('BUSY_L0L1DEADTIME', '0x8620', ''), ('BUSY_CTPDEADTIME', '0x8624', ''), ('BUSY_OVERLAP', '0x8640', ''), ('L0_CLEAR_RND', '0x90c8', ''), ('L0_TCSTATUS', '0x91c0', ''), ('L0_TCSTART', '0x91c4', ''), ('L0_TCCLEAR', '0x91c8', ''), ('RATE_DATA', '0x91cc', ''), ('RATE_CLEARADD', '0x91d0', ''), ('MASK_DATA', '0x91e4', ''), ('MASK_CLEARADD', '0x91e8', ''), ('L0_TCSET', '0x9400', ''), ('L0_CONDITION', '0x9400', ''), ('L0_VETO', '0x9600', ''), ('DAQ_LED', '0x9600', ''), ('L0_MASK', '0x9700', ''), ('L0_INVERT', '0x9500', ''), ('L0_INVERTac', '0x9800', ''), ('L0_INTERACT1', '0x94cc', ''), ('L0_INTERACT2', '0x94d0', ''), ('L0_INTERACTT', '0x94d4', ''), ('L0_INTERACTSEL', '0x94d8', ''), ('L0_FUNCTION1', '0x94dc', ''), ('L0_FUNCTION2', '0x94e0', ''), ('RANDOM_1', '0x94e4', ''), ('RANDOM_2', '0x94e8', ''), ('SCALED_1', '0x94ec', ''), ('SCALED_2', '0x94f0', ''), ('ALL_RARE_FLAG', '0x94f4', ''), ('L0_ENA_CRND', '0x94fc', ''), ('MASK_MODE', '0x95a4', ''), ('L0_BCOFFSET', '0x95a8', ''), ('RATE_MODE', '0x9700', ''), ('L0_FUNCTION34', '0x97ec', ''), ('L1_TCSTATUS', '0xa1c0', ''), ('L1_TCCLEAR', '0xa1c8', ''), ('L1_TCSET', '0xa400', ''), ('L1_DEFINITION', '0xa400', ''), ('L1_DELAY_L0', '0xa4cc', ''), ('L1_INVERT', '0xa500', ''), ('ROIP_BUSY', '0xa600', ''), ('L2_DEFINITION', '0xb400', ''), ('L2_ORBIT_READ', '0xb140', ''), ('L2_ORBIT_CLEAR', '0xb144', ''), ('L2_TCSTATUS', '0xb1c0', ''), ('L2_TCCLEAR', '0xb1c8', ''), ('L2_TCSET', '0xb400', ''), ('L2_DELAY_L1', '0xb4cc', ''), ('L2_BCOFFSET', '0xb5a8', ''), ('INT_ORBIT_READ', '0xc140', ''), ('INT_MAX_CLEAR', '0xc144', ''), ('INT_FIFO_MAX', '0xc148', ''), ('INT_DDL_EMU', '0xc14c', ''), ('INT_DISB_CTP_BUSY', '0xc150', ''), ('I2C_MUXWR', '0xc154', ''), ('I2C_MUXRD', '0xc158', ''), ('I2C_ADCWR', '0xc174', ''), ('I2C_ADCRD', '0xc160', ''), ('I2C_SET', '0xc164', ''), ('I2C_DATA', '0xc168', ''), ('INT_RC_BLCKMAX', '0xc16c', ''), ('INT_BLCKMAX_CLEAR', '0xc170', ''), ('INT_TCSET', '0xc400', ''), ('INT_TEST_COUNT', '0xc404', ''), ('INT_BCOFFSET', '0xc5a8', '')]
self.hiddenfuncs=" Common L0 dbghw ConfiguratioH DbgScopeCalls DebCon L012 DebugSSMcalls DbgSSMBROWSERcalls"
self.funcs=[['DbgSSMBROWSERcalls', 'return the names+modes of SSMs for present boards:\nstdout:\nname1 mode1 \nname2 mode2 \n...\nmode -mode of the ssm or:\n      _nomode if sms[ix].mode is epmty string\n      notin  board is not in the crate\n      nossm  if board or sms[ix].sm==NULL\n', 'void', 'gettableSSM', []], ['DbgSSMBROWSERcalls', 'return line:\nhighest_syncflag n1 n2...\nn1,n2 -numbers of items (indexes into sms[])\n', 'void', 'getsfSSM', [['board', 'int', '']]], ['DbgSSMBROWSERcalls', 'return line:\nhighest_syncflag n1 n2...\nn1,n2 -numbers of items (indexes into sms[])\n', 'void', 'getsyncedSSM', []], ['DbgSSMBROWSERcalls', "Extract 1 signal to stdout:\nInput:\nboard:   (0...) according to sms global array\nbit:     SSM bit (0-31)\nfrombc: bc number. \n         0 corresponds to word with address sms[board].offset\nbits:    number of bits to be examined (but don't print more then\n         102 lines)\nOutput:\nvalue_of_the_1st_bit      or <0 if error\nbit_number_for_which_value_changed\nbit_number_for_which_value_changed\n...\nErrors:\n-1 -> required SSM not read\n", 'void', 'getsigSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', ''], ['bits', 'int', '']]], ['DbgSSMBROWSERcalls', 'Find signal change.\nInput:\nboard,bit,frombc: as in getsigSSM()\nOutput (on stdout):\n-1 -signal does not change (or memory not accessible)\nn  - pointing to the last bit with the same value, next bit\n     is different\n', 'void', 'finddifSSM', [['board', 'int', ''], ['bit', 'int', ''], ['frombc', 'int', '']]], ['DbgSSMBROWSERcalls', 'print sms[board].offset\n', 'void', 'getoffsetSSM', [['board', 'int', '']]], ['DbgSSMBROWSERcalls', 'set sms[board].offset\n', 'void', 'setoffsetSSM', [['board', 'int', ''], ['newoffset', 'int', '']]], ['DbgSSMBROWSERcalls', 'set sms[board].mode, ltubase\nboard: 0..  index into sms[]\nnewmode: file name in CFG/ctp/ssmsigs without .sig suffix\nltubase: valid only for ltu (board>10)\n', 'void', 'setmodeSSM', [['board', 'int', ''], ['newmode', 'char', '*'], ['ltubase', 'char', '*']]], ['DbgSSMBROWSERcalls', 'set sms[board].offset\n', 'void', 'printsms', []], ['SimpleTests', 'Dump CTP configuration.\nL0 BOARD CLASSES section:\nclass: L0_CONDITION L0_VETO L0_RATE L0_MASK [L0_INVERT for classes45-50 or all]\n', 'void', 'dumpCTP', []], ['L0', 'get PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n', 'void', 'getPF', [['ix', 'int', '']]], ['L0', 'get PF parameters for 1 circuit \nI:\nL0, L1, or L2 -> ix= 1, 2 or 3\ncirc -> 1..5\nO: on stdout: 3 hexadecimal numbers: PFBLOCK_A, PFBLOCK_B, PFLUT\n', 'void', 'getPFc', [['ix', 'int', ''], ['circ', 'int', '']]], ['L0', 'like getPF\n', 'void', 'getprtPF', [['ix', 'int', '']]], ['L0', 'like getPFc\n', 'void', 'getprtPFc', [['ix', 'int', ''], ['circ', 'int', '']]], ['L0', 'set PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\npfc: PF_COMMON word\n', 'void', 'setPF', [['ix', 'int', ''], ['pfc', 'w32', '']]], ['L0', 'set PF parameters for 1 circuit \nI:\nL0, L1, or L2 -> ix= 1, 2 or 3\ncirc -> 1..5\nA, B, LUT -3 words to be written\n', 'void', 'setPFc', [['ix', 'int', ''], ['circ', 'int', ''], ['A', 'w32', ''], ['B', 'w32', ''], ['LUT', 'w32', '']]], ['L0', 'Print setings (12 hexa numbers) of PFcircuit for deltat in BCs\nFirst hexa number is 0xffffffff if error\n', 'void', 'printPFwc', [['deltat', 'int', '']]], ['L0', 'get rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2 INTSEL1 INTSEL2 allrare\n', 'void', 'getShared', []], ['L0', 'get 4096 hexa chars each containing i-bit of LUT4-1. i:0..4095\n', 'void', 'getSharedL0f34', [['lutout', 'int', '']]], ['L0', '4096 hexa chars from stdin will be loaded to LUT31 32 41 42', 'void', 'setSharedL0f34', []], ['L0', 'set rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2\n', 'void', 'setShared', [['r1', 'w32', ''], ['r2', 'w32', ''], ['bs1', 'w32', ''], ['bs2', 'w32', ''], ['int1', 'w32', ''], ['int2', 'w32', ''], ['intt', 'w32', ''], ['l0fun1', 'w32', ''], ['l0fun2', 'w32', '']]], ['L0', 'set INTERACTSEL ALL_RARE_FLAG\n', 'void', 'setShared2', [['intsel', 'w32', ''], ['allrare', 'w32', '']]], ['DbgNewFW', 'Load run reading RCFG file in WORK directory \n', 'void', 'loadRun', [['runnumber', 'w32', '']]], ['DbgNewFW', 'Prints static class CTPHardware.\n', 'void', 'printHW', []], ['DbgNewFW', '', 'void', 'unloadRun', [['runnumber', 'w32', '']]], ['DbgNewFW', '', 'void', 'printL0FUN34', []], ['Common', '', 'int', 'notInCrate', [['ix', 'int', '']]], ['Common', '', 'int', 'findBUSYINP', [['fo', 'int', ''], ['foc', 'int', '']]], ['busy', ' Input: time in milisecs\n For detectors in clusters as defined on busy board \n it calculates and prints average: \n  -fraction of the time detectors is busy \n  -average deadtime\n', 'w32', 'findDeadBusysRuns', [['time', 'int', '']]], ['busy', ' For detectors in clusters as defined on busy board\n it reads LasBusy counter.\n Last busy counts number of cases when detector is releasing busy LAST\n in given cluster.\n', 'void', 'printLastDetectors', [['cluster', 'w32', '']]], ['busy', 'Busy probe option - minimax select word\nSelect the object you want to study:\n0- CTP BUSY\n1-24 : detectors\n25-30 : clusters\n31 test cluster\n', 'void', 'busyprobe', [['det', 'char', '*']]], ['busy', 'Input: dets is pattern of detectors to be checked.  0xffffff: all dets\nOperation:\n- read busy timers\n- sleep 100ms\n- read busy timers \n- calculate difference between 2 measurements and compare \n  with busy_timer\nrc: busy pattern: [0..23] bits set to 1 correspond to Dead busy inputs\n', 'w32', 'findDeadBusys', [['dets', 'w32', '']]], ['DebCon', '', 'int', 'GenSwtrg', [['n', 'int', ''], ['trigtype', 'char', ''], ['roc', 'int', ''], ['BC', 'w32', ''], ['detectors', 'w32', ''], ['customer', 'int', '']]], ['DebCon', '', 'int', 'getCALIBBC2', [['ctprodets', 'w32', '']]], ['DbgScopeCalls', '', 'int', 'checkScopeBoard', [['ab', 'char', '']]], ['DbgScopeCalls', '', 'int', 'setScopeBoard', [['ab', 'char', ''], ['board', 'int', '']]], ['DbgScopeCalls', '', 'int', 'getScopeSignal', [['board', 'int', ''], ['ab', 'char', '']]], ['DbgScopeCalls', '', 'int', 'setScopeSignal', [['board', 'int', ''], ['ab', 'char', ''], ['signal', 'int', '']]], ['DbgScopeCalls', '', 'int', 'getVMERWScope', []], ['DbgScopeCalls', '', 'void', 'setVMERWScope', [['newv', 'w32', ''], ['oldv', 'w32', '']]], ['ConfiguratioH', 'Print 1 line string xxxx\nwhere x is the status (0/1) of software LED word\n', 'void', 'getSWLEDS', [['ixboard', 'int', '']]], ['inputsTools', 'board:0:busy (the CLK edge for input ORBIT signal) \n      1..3:L0/1/2  \ninput: no sense for busy board.For L0/1/2 boards: L0,L1:1..24   L2:1..12\nedge: 0:Positive 1:Negative\n\nEdge: choose negative (for delay:0) if unstability is found around delay 0.\n', 'void', 'setEdge', [['board', 'int', ''], ['input', 'w32', ''], ['edge', 'w32', '']]], ['inputsTools', 'set Edge/Delay \nInputs:\nboard: 1:L0 2:L1 3:L2\ninput: 1..24 (1..12 for L2)\nedge:  0:positive 1:negative\ndelay: 0..15', 'void', 'setEdgeDelay', [['board', 'int', ''], ['input', 'int', ''], ['edge', 'int', ''], ['delay', 'int', '']]], ['inputsTools', 'Read edge/delay info from hw for all the inputs (clk edge for ORbit\nin case of busy board).\nInputs:\n  board: 0:busy (the CLK edge for INPUT ORBIT signal)\n         1..3: L0/1/2\n  input: 1..24 (for L0/1 boards) 1..12 for L2 board\n\nEdge: choose negative (for delay:0) if unstability is found around delay 0.\n\n', 'void', 'printEdgeDelay', [['board', 'int', '']]], ['L0', 'read BC masks from HW and print out 3564 4bits words\n', 'void', 'getBCmasks', []], ['L0', 'set BC masks in HW from input line containing 3564 hexa-chars.\n', 'void', 'setBCmasks', []], ['L0', 'set/read/check ntimes\nwords: if 0 than check whole BCmask memory (3564)\n', 'void', 'checkBCmasks', [['ntimes', 'int', ''], ['words', 'int', '']]], ['SimpleTests', 'return 5 integers in 1 line corresponding to clcock phase on L0/1/2 BUSY INT\n', 'void', 'checkPhasesPrint', []], ['SimpleTests', '', 'void', 'printToggle', []], ['SimpleTests', '', 'int', 'Toggle', [['det', 'char', '*'], ['onoff', 'int', '']]], ['SimpleTests', 'Resets PLL clock on all boards\n', 'void', 'resetPLLS', []], ['SimpleTests', '', 'void', 'ReadPF', []], ['SimpleTests', '', 'void', 'WritePFcommon', [['INTa', 'w32', ''], ['INTb', 'w32', ''], ['Delayed_INT', 'w32', '']]], ['SimpleTests', '', 'void', 'WritePF', [['icircuit', 'w32', ''], ['THa1', 'w32', ''], ['THa2', 'w32', ''], ['THb1', 'w32', ''], ['THb2', 'w32', ''], ['dTa', 'int', ''], ['dTb', 'int', ''], ['P_signal', 'w32', '']]], ['SimpleTests', 'Set PF circuit for INT1 only (for INT1/2 combinations, another\nfunction should be prepared). Note that INT1 should be defined in Shared Resources!\nExamples of INT1 definition: it can be BC1,BC2,RND1,RND2 or any logical combination of \nfirst 4 L0 inputs (INTfun1). For example if we want to define INT1 as L01 input then INTfun1 \nwill be 0xaaaa, L02 only -> INTfun1=0xcccc, L03 only -> INTfun1=0xf0f0, L04 only -> INTfun1=0xff00,\nL01.or.L02.or.L03.or.L04 -> INTfun1=0xfffe, L01.and.L02.and.L03.and.L04 -> INTfun1=0x8000\n\nicircuit: 1..4 - circuit number - there can be 4 PF protections in parallel\n\nbcs: 1..4096 - protected interval in BCs. \nFor example: 10mus = 400 BC.\n\nthreshold: 0..63 - number of allowed interactions in protected interval \nFor example: 0: kill this event  1: only this event   2: max. 1 additional event\n', 'void', 'WritePFuser', [['icircuit', 'w32', ''], ['threshold', 'w32', ''], ['bcs', 'w32', '']]], ['SimpleTests', '', 'int', 'WritePFuserII', [['Ncoll', 'w32', ''], ['dT1', 'w32', ''], ['dT2', 'w32', ''], ['icircuit', 'w32', ''], ['plut', 'w32', '']]], [None, 'The Classes definition, i.e. for each (1-50) class: \n -enabling/disabling\n -L0,L1,L2 inputs and selectable vetos\n -cluster\n -L0 pre-scaler\n', 'GUI', 'CTP_Classes', [], 'Classes'], [None, "The Clusters definition, i.e. which detectors (LTUs) belong to each cluster.\nCluster definition consist of 'assignment of clusters to\neach Fanout connector'.\n", 'GUI', 'CTP_Clusters', [], 'FOs/Clusters'], [None, 'The Shared resources definition. They are:\n- random generators(2) and BC generators(2) rates\n- 3 Interaction functions (16 bits lookup tables)\n- 2 L0 input functions (16 bits lookup tables)\n- 2 Interaction selectors\n- All/Rare events CTP option\n- 5 Past/Future protection circuits for all trigger levels \n    (PF1-PF4 for physics and PF5 for Test Class)\n', 'GUI', 'Resources', [], 'Shared resources'], [None, 'Displays counters on all CTP boards\n', 'GUI', 'Counters', [], 'Counters'], [None, 'Test class control.\n', 'GUI', 'CheckTestClass', [], 'Test class'], [None, 'Signal selection for front panel \nA,B outputs\n', 'GUI', 'ScopeAB', [], 'Scope Signals'], [None, 'Browse CTP snapshot memories \n', 'GUI', 'SSMbrowser', [], 'SSMbrowser'], [None, 'The CTP snapshot memories control\n', 'GUI', 'SSMcontrol', [], 'SSMcontrol'], ['File', '- Save configuration to WORK/.cfg configuration to file\n', 'GUI', 'SaveFile', [], 'Save2file'], ['File', '- Load configuration from WORK/.cfg configuration to file\nTodo:\n- check hw configuration with the memory-configuration\n- Load (i.e. add) partition configuration (i.e. from .configuration\n  file prepared by partition editor)\n', 'GUI', 'LoadFile', [], 'Load file'], ['File', '- Load configuration from CTP boards\n', 'GUI', 'Readhw', [], 'Readhw'], ['File', '- Write configuration into CTP boards\n', 'GUI', 'Write2hw', [], 'Write2hw'], ['INT', 'read/print 2 counters: L2_ORBIT_READ and INT_ORBIT_READ ', 'void', 'readORBIT_READs', []], ['INT', 'Go through all boards in the CTP crate and print (ltuX, X is ECSnumber+1 from VALID.LTUS):\n- I2C values  (4 voltages)\n- temperature (1 value in centigrades)\n', 'void', 'i2creadall', []], ['busy', 'Set daqbsy, T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board\n', 'void', 'setClusters', [['daqbsy', 'w32', ''], ['tc', 'w32', ''], ['c1', 'w32', ''], ['c2', 'w32', ''], ['c3', 'w32', ''], ['c4', 'w32', ''], ['c5', 'w32', ''], ['c6', 'w32', '']]], ['busy', 'Read T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board and print it as 1 line\n', 'void', 'getClusters', []], ['busy', 'Read DAQ_BUSY word ', 'void', 'getDAQbusy', []], ['dbghw', "ix: FO1BOARD..FO1BOARD+5   (6 FO boards)\nalways read FO board's CLUSTER, TEST_CLUSTER words\nSTDOUT:\n- no output                if ix FO is not in the crate\ncluster testcluster        for FO in the crate\n", 'void', 'getFO', [['ix', 'int', '']]], ['dbghw', "write to FO board's registers only if modified\nix: FO1BOARD..FO1BOARD+5   (i.e. 5-10, 6 FO boards)\ncluster: 0x44332211      11 - bits [5..0]: clusters fed through 1st connector\ntcluster: 0xXCT4321\nX   : bits[31..28]: toggle signal on connector 4..1\nC   : bit[20]       calibration flag for sw trigger\nT   : bits[19..16]: sw trigger (test class) for connector 4..1\n4   : bits[15..12]: RoC for connector 4\n", 'void', 'setFO', [['ix', 'int', ''], ['cluster', 'w32', ''], ['tcluster', 'w32', '']]], ['dbghw', 'set cal. flag and roc on ALL the FO boards\n', 'void', 'setFOrocs', [['calflag', 'int', ''], ['roc', 'w32', '']]], ['L0', 'Start SW trigger.\nInput:\nssm: 1   ->start SSM recording in L0 output moinitoring mode before\n           starting trigger\nOperation:\n- clear flags\n- start SSM (optionally)\n- start sw trigger\n- usleep(200) -micsecs\n- read L0_TCSTATUS word\nOutput:\nL0_TCSTATUS word\nToDo: -for whic detector? \n      - ROC bits to be written to FO and INT board\n', 'w32', 'swtrigger', [['ssm', 'int', '']]], ['L0', 'ret: TCSTATUS bits from L0,1,2 boards:\nBits:\n4-0  L0_TCSTATUS bits\n5    L1_TCSTATUS bit3 (L1ack flag)\n7-6  L2_TCSTATUS bits (L2Aack and L2Rack)\n', 'w32', 'getTCSTATUS', []], ['L0', 'ret: TC_SET bits from L0,1,2 boards:\nBits:\n18-0  L0_TC_SET bits\n19   L1_TC_SET bit18 (P/F veto)\n20   L2_TC_SET bit24 (P/F/veto)\n', 'w32', 'getTCSET', []], ['L0', 'tcset012 -extended mening (bits 18,19 -see getTCSET() )\n', 'void', 'setTCSET', [['tcset012', 'w32', ''], ['dets', 'w32', '']]], ['L0', 'operation: clear TC flags on all the boards\n', 'void', 'clearTC', []], ['L0', 'klas: 1-50   -class number\nget L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n    L1_DEFINITION L1_INVERT L2_DEFINITION words for klas\ni.e. 7 hexa numbers.\nL0_INVERT, L1_INVERT are 0:for classes 1-44 (not valid for  >AC) or \ncorresponding board is not in the crate\n', 'void', 'getClass', [['klas', 'int', '']]], ['L0', 'set L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n    L1_DEFINITION L1_INVERT L2_DEFINITION\nwords for klas (1..50)\nATTENTION: \n1. bit17 (0x10000) of veto is CLASS MASK bit written into bit0 of L0_MASK\n   bit31 for firmAC\n2. invert,l1invert -valid only for class>=45\n', 'void', 'setClass', [['klas', 'int', ''], ['condition', 'w32', ''], ['invert', 'w32', ''], ['veto', 'w32', ''], ['scaler', 'w32', ''], ['l1def', 'w32', ''], ['l1invert', 'w32', ''], ['l2def', 'w32', '']]], ['L0', 'disable all 50 classes, i.e.:\n- set all inputs,vetos as dontcare for all 50 classes i.e.:\nL0_CONDITION = 0xffffffff\nL0_VETO      = 0xfffffff0   (cluster0) bit31:1-> class is disabled\nand 0x0 in:\nL0_INVERT   =0\nL0_PRESCALER=0\n', 'void', 'disableClasses', []], ['L0', 'read all rates (scalers) from hw to Klas structure\n', 'void', 'hw2rates', []], ['L0', 'write all rates (scalers) from Klas structure to hw\n', 'void', 'rates2hw', []], ['L0', 'check spy memory (256 words from 0x9400 on L0 board )\nOperation: \n- write a, a+1 a+2 ... \n- read back and check\n- write 0s to all the 256 words\n', 'void', 'clearSPY', [['board', 'int', '']]], ['SimpleTests', 'To be used with CTP_hlttest (instance of PHYSICS_1 in ACT)\nand mask defining 12 B-bunches. CTP_hlttest:\nALL cluster:\nDEMPTY(cn=CINT1-B-NOPF-ALLNOTRD,rnd1,BCM2,cg=8)\nD1DUM(cn=CINT1-AC-NOPF-ALLNOTRD,rnd2,BCM2,cg=8)\n+ there is cluster ALL with TRD in readout driven by similar WU-classes\n\nrate: required rate in hz to be set for L2a/r classes\noperation:\n1. calculate rate for rnd1/2 generators and set in in hw:\nrnd2=(required_input_rate1*3564/12.) hz\nrnd1= rnd2+1 to get different rnd1/2 setting\n', 'void', 'setRates4HLTtest', [['rate', 'int', '']]], ['inputsTools', 'set positive + delay on both 1EJE and 1EGA\n', 'void', 'setEJEGA', [['delay', 'int', '']]], ['L0', '1. Prepare 24 input signals in SSM, start it in continuous input generator mode.\n2. set step by step (keep 1 sec delay between settings) all 24 SYNCH_ADD\n   from 0 to 15\n', 'void', 'testSYNCH', []], ['busy', 'Set BC_DELAY from 0..31 with step 1, wait 1 sec between\nsteps: number of steps (0..34)\n', 'void', 'testBCDELAY', [['steps', 'int', '']]], ['busy', 'Operation:\n-Set BC_DELAY from 0..31 with step 1, \n-read BUSY_ORBIT_SELECT word (follow bit14: 0x4000 0:negBC 1:posBC)\n-wait 300 usecs between\nInput:\nsteps: number of steps \nOutput: Table: delay Edgeflag\n', 'void', 'orbitscan', [['steps', 'int', '']]], ['busy', 'set Orbit on backplane to BC/2 signal.\nbit8: 1 ->set toggling     0->disable toggling\nNecessary for delay measurement on l0/l1/l2 board.\n', 'void', 'setOrbitBChalf', [['bit8', 'int', '']]], ['SimpleTests', 'VME read/write in the loop (for l1glitch testing)\nInputs:\naddress: vme address or\n         0: read counters on all boards readCounters() (no I2C)\n         1: readTVCounters() -I2C only\n         2: do not read vme\nloops:   number of loops (0: endless loop)\nvalue:   0: read 1: write alternating 0/0xffffffff >1: write this value\nmics:  sleep time in micsecs between reads\nring:    32 do not ring, 0..31 -altrenate this bit in address \n', 'void', 'rwvmeloop', [['address', 'w32', ''], ['loops', 'int', ''], ['value', 'w32', ''], ['mics', 'int', ''], ['ring', 'int', '']]], ['SimpleTests', 'read+print N counters of the board \nboard (0:busy, 1:L0 2:L1, 3:L2, 4:INT, 5:FO1...)\nN==0: read+print all counters (according to ctpcounters.h) of the board\n', 'void', 'printBoardCounters', [['board', 'int', ''], ['N', 'int', '']]], ['SimpleTests', 'Dump choosen counters to file $VMEWORKDIR/counters.dump\n', 'void', 'dumpCounters', []], ['SimpleTests', '', 'void', 'ReadTemperatures', []], ['SimpleTests', '', 'void', 'TestLEDS', []], ['SimpleTests', 'Wait mics microeconds (using system usleep() call) ', 'void', 'micsleep', [['mics', 'int', '']]], ['SimpleTests', 'Synchronise/desynchronise random generators\nmask:\n3 synchronise RND1 and RND2 generators on L0 board\n1 desynchronise RND1 and RND2 generators on L0 board\n', 'void', 'RNDsync', [['mask', 'int', '']]], ['SimpleTests', 'TL2 play. Normal value: 3952\nCorresponding L2_DEALY_L1, FO_DELAY_L1CLST, L2_BCOFFSET:\n3628 456 383\n', 'void', 'changeTL2', [['tl2', 'int', '']]], ['Common', '   rc: 0 -board ix is in the crate \n       1 -board ix is not in the crate\n', 'void', 'initmain', []], ['DebugSSMcalls', '-------------------------------------------------------------- getswSSM() \nreturn status word of SSM\nLTU: [4] FrontPanel->SSM mode active\n     [3] not used\n     [2] BUSY bit\n     [1..0] operation\nCTP: [8] -BUSY\n     [7..6] Enable SSM Input..Output flag\n     [5..4] ConfSel bits\n     [3..3] InOut flag   0:out   1:in\n     [2..1] Operation bits \n     [0..0] mode bit \nerror: 0xdeadbeaf\n', 'w32', 'getswSSM', [['board', 'int', '']]], ['DebugSSMcalls', '-------------------------------------------------------------- setsmssw() \nset sms[].mode\n', 'void', 'setsmssw', [['ix', 'int', ''], ['newmode', 'char', '*']]], ['DebugSSMcalls', "Set operation & mode. If SSM is BUSY, an attempt is made to stop\nthe recording.\nInput parameteres:\nboard -number of the board (index into global sms array) \n       0..NSSMBOARDS    (busy,L0,1,2,int,fo1,2,3,4,5,6,ltu1,2,3,4)\nopmo  -mode/operation bit for SSMcommand word. symbolic names \n       are defined in ctp.h (as SSMom*)\n\nopmo for LTU boards:\n--------------\n0x0 -VME access, read\n0x1 -VME access, write\n0x2 -RECORDING, After  (cca 26 milsec)\n0x3 -RECORDING, Before (should be stopped by SSMstoprec)\n\nBit opmo[4] (0x10) should be set to 1 for LTU/RECORDING mode\n    (new feature 'FrontPanel->SSM' introduced for LTU 7.10.2005)\n    If not set, signals from LTU-FPGA will be recorded.\n\nopmo for CTP boards:\n--------------\nThe codes above (0-3) are valid, in addition 7 bits (opmo[9..3] are\nmeaningfull, and 2 more codes are added:\n0x4 - GENERATING, single pass\n0x5 - GENERATING, continuous\nopmo[9..8] - bits to be used for selecting SSMenable word\n             10 ->enable Input    01 ->enable Output\nopmo[7..6] - not used\nopmo[5..4] - ConfSel bits  (defined in \n               $VMECFDIR/CFG/ctp/ssmsigs/.sig files)\nopmo[3]      - InOut flag   1:in   0:out (side of FPGA logic)\nExamples: \n0x20d - generate continuously  inputs for board logic\n0x20c - generate 1 pass (27ms) inputs for board logic\n0x102 - record   1 pass (27ms) of board logic outputs\nRC:  0->ok, mode set\n     1->mode not set, possible errors (printed to stdout):\n        -BC signal not connected\n        -Cannot stop recording operation\n     2->bad mode for LTU board\n", 'int', 'setomSSM', [['board', 'int', ''], ['opmo', 'w32', '']]], ['DebugSSMcalls', '', 'int', 'startSSM1', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------- stopSSM()\nOpearation:\n- check if board is in BUSY status\n- stop (recording or generation)\nrc: == 0 OK\n       1 board not busy, no action\n       2 problem with openvme for LTU\n', 'int', 'stopSSM', [['board', 'int', '']]], ['DebugSSMcalls', "Opearation:\n- read counter cntpos\n- check 'the change of this counter' + check maxloops\n- sleep 'sleepafter' micsecs (should be 0 or at least 100)\n- stop (recording or generation) -> call stopSSM()\nInputs:\nboard: 0:busy, 1:L0,..., 10:INT\n      21: L0+L1 -> i.e. stop 2 SSM for L0/1 board\ncntpos: position of the counter (starting from 0) for this board\n        see 2. column in dimcdistrib/cnames.sorted2 file\nmaxloops: max. number of loops (1 loop == cca 2 ms)\n          0: loop forever\ncustomer: bakery customer (see ctplib/readCounters.c)\nrc: == 0 OK\n   1 board not busy, no action (i.e. SSM was not started before in\n     'BEFORE/continuous' mode)\n   2 problem with openvme for LTU\n  10 timeout (counter did not change even after 'maxloops' reads)\n--------------------- ", 'int', 'condstopSSM', [['board', 'int', ''], ['cntpos', 'int', ''], ['maxloops', 'int', ''], ['sleepafter', 'int', ''], ['customer', 'int', '']]], ['DebugSSMcalls', '--------------------------------------------------------- readSSM()\nread whole SSM into array of unsigned ints\nNote: InOut, ConfSel bits and SSMenable word left unchanged\nInput:\nboard: board according to sms global array\nOutput:\nrc:  0 SSM read into sms[board].sm->\n       i.e. Mega words were read\n    >0 only part of SSM was read into sms[board].sm-> \n       reason in After or Before mode:\n       - SSM stopped early (<26ms)\n', 'int', 'readSSM', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------ writeSSM()\nwrite whole sms[].sm into hardware\nNote: InOut, ConfSel bits and SSMenable word left unchanged\nInput:\nboard: board according to sms global array\nrc:    0: no errors found during writing\n', 'int', 'writeSSM', [['board', 'int', '']]], ['DebugSSMcalls', '------------------------------------------------------ dumpSSM()\nwrite whole sms[].sm into hardware\nInput:\nboard: board according to sms global array\nrc:    0: no errors found during writing\n', 'int', 'dumpSSM', [['board', 'int', ''], ['fname', 'char', '*']]], ['DebugSSMcalls', 'Dump computer ssm (not hw ssm)\ncompress: 0: old way 1; new way i.e. compressed\n', 'int', 'dumpssm_compress', [['board', 'int', ''], ['fname', 'char', '*'], ['compress', 'int', '']]], ['DebugSSMcalls', "print to stdout SSM board from word 'fromadr'\n", 'void', 'printSSM', [['board', 'int', ''], ['fromadr', 'int', '']]], ['SimpleTests', " Read binary dump written before by dumpSSM() to the sms[board].sm\nboard: 0,1,2,... ->   BUSY, L0, L1,...\nfilename: 'WORK/name.dmp'\ncompress: 0: old way 1; new way i.e. compressed\n", 'int', 'readSSMDump_compress', [['board', 'int', ''], ['filename', 'char', '*'], ['compress', 'int', '']]], ['TooBUSY', 'Reading the detector or cluster currently selected\n', 'void', 'readMINIMAXSel', []], ['TooBUSY', 'Write the detector or cluster number to select\n', 'void', 'writeMINIMAXSel', [['word', 'w32', '']]], ['TooBUSY', 'Clear the readMINMAX\n', 'void', 'writeMINIMAXClear', []], ['TooBUSY', 'Read the min and max busies since the last clear\n', 'void', 'readMINMAX', []], ['TooBUSY', 'The current maximum busy in microseconds for busylong counter\n', 'void', 'readMINIMAXLimit', []], ['TooBUSY', 'Set the maximum busy in microseconds for busylong counter\n', 'void', 'writeMINIMAXLimit', [['word', 'w32', '']]], ['TooBUSY', 'Enter the time you wish to wait between busylong reads in seconds and the counter\n will display how many times the detector selected has exceeded the limit written in that time.\n', 'void', 'readBUSYlong', [['delay', 'w32', '']]], ['TooBUSY', 'Sweep of busylong.\nRangemax is the maximum minimax_limit of the sweep in microseconds.\n  -maximum average busy\nRangemin (try zero to start) is the first minimax_limit set.\nStepsize is size of the increase in MINIMAX_limit steps ie the bin size in microseconds.\nThe sweep time is the time in seconds spent waiting on each datapoint.\nDetector is the bit number in MINIMAX_SELECT word:\n0       CTP BUSY\n1-24    Sub-detector 1 to 24 BUSY (Note 2)\n(this is the 4th row in VALID.LTUs)\n25-30   Cluster 1 to 6 BUSY (Note 3)\n31       Test cluster BUSY\n', 'int', 'busytool', [['rangemax', 'int', ''], ['rangemin', 'int', ''], ['stepsize', 'int', ''], ['sweeptime', 'int', ''], ['detector', 'w32', '']]], [None, 'read QPLL* and TTCrx status bits.\nRC: 0xTAB\nT: bit 8. 1: TTCrx ok\nA: [7..6] BC1 error,locked (i.e. 01 correct)\n   [5..4] BC2\nB: [3..2] BCref\n   [1..0] BCmain\nI.e. 0x155 is correct status of all 9 bits\n     0x1aa error in both BC, was not locked. NEXT READING is 0x155 !\n', 'w32', 'readstatus', []], ['L012', '', 'w32', 'getCounter', [['board', 'int', ''], ['reladr', 'int', ''], ['customer', 'int', '']]], ['L012', '', 'void', 'getCounters', [['N', 'int', ''], ['accrual', 'int', ''], ['customer', 'int', '']]], ['L012', '', 'void', 'clearCounters', [['customer', 'int', '']]], ['SimpleTests', 'rc: 0: if L0 borad firmware >0xAB\n    boardversion if firmware <=0xAB \n', 'int', 'l0AB', []], ['INT', "daqon:0       ->daq active\ndaqon:0xb     ->daq off (i.e. produce triggers in spite of DDL red diode \n                on INT board is on \ndaqon: other  -> show current status.\nNOTE about LEDs on INT board:\nDDL interface: \n  green:DDL line ready, data not read out \n  flashing green: DDL line ready, data are read out\n  flashing orange: data are read out, backpressure is sometimes active\n                   (DAQ is not able to read everything)\nupper DDL LED on INT board fron panel:\n  red: INT is raising CTPBUSY on backlplane, because of full DDL buffers\nINT_DDL_EMU word in normal mode (i.e. DAQ active):\n     DDLfiLF  DDLfiBEN  DDLfiDIR\n0x20:      0         1         0  data can't be sent (DDL not enabled from DIU)\n0x30:      0         1         1  data sent\n0x70:      1         1         1  data not sent (backpressure)\n", 'void', 'DAQonoff', [['daqon', 'int', '']]], ['IntBoard', 'Do the following for l1, l2, int boards:\nStart After 27ms, Read into ssm[] \nOut: message issued if time between 1st board start and last board start\ntoo high (>80us).\nrc: 0: ok\n   >0: error (printed to stdout)\n', 'int', 'startRead3SSM', []], ['IntBoard', ' *  analyze interface board data\n *  L2alist - list of CTP readout from L2 board\n *  INTlist - list of CTP readout and IR data from Interface board\n-dump to $VMEWORKDIR/IntList.txt\nin: 2 3 4  (l1 l2 int board index in ssm[])\nNote: start startRead3SSM() before\n', 'int', 'L2a2Interface', [['boardl1', 'int', ''], ['boardl2', 'int', ''], ['boardint', 'int', '']]], ['IntBoard', ' * Dumps Interface board ssm. Word is in output if any bit nonzero.\n * SSM should be read before\n', 'int', 'dumpIntSsm', [['board', 'int', '']]], ['IntBoard', ' * get L2 message from L2 board\n- dump something to file $VMEWORKDIR/L2amessageList.txt\n ', 'int', 'dumpL2amesage', [['board', 'int', '']]]]
