/* generated by comp.py */
#include <stdio.h>
#include "vmewrap.h"
#include "lexan.h"
#include "vmeaistd.h"

char BoardName[]="ctp";
char BoardBaseAddress[11]="0x820000";
char BoardSpaceLength[11]="0xd000";
char BoardSpaceAddmod[11]="A24";
char readMINIMAXSel_usagehelp[]="Reading the detector or cluster currently selected\n\
";

Tpardesc writeMINIMAXSel_parameters[1]={
{"word", 2}};
char writeMINIMAXSel_usagehelp[]="Write the detector or cluster number to select\n\
";

char writeMINIMAXClear_usagehelp[]="Clear the readMINMAX\n\
";

char readMINMAX_usagehelp[]="Read the min and max busies since the last clear\n\
";

char readMINIMAXLimit_usagehelp[]="The current maximum busy in microseconds for busylong counter\n\
";

Tpardesc writeMINIMAXLimit_parameters[1]={
{"word", 2}};
char writeMINIMAXLimit_usagehelp[]="Set the maximum busy in microseconds for busylong counter\n\
";

Tpardesc readBUSYlong_parameters[1]={
{"delay", 2}};
char readBUSYlong_usagehelp[]="Enter the time you wish to wait between busylong reads in seconds and the counter\n\
 will display how many times the detector selected has exceeded the limit written in that time.\n\
";

Tpardesc busytool_parameters[5]={
{"rangemax", 1},
{"rangemin", 1},
{"stepsize", 1},
{"sweeptime", 1},
{"detector", 2}};
char busytool_usagehelp[]="Sweep of busylong.\n\
Rangemax is the maximum minimax_limit of the sweep in microseconds.\n\
  -maximum average busy\n\
Rangemin (try zero to start) is the first minimax_limit set.\n\
Stepsize is size of the increase in MINIMAX_limit steps ie the bin size in microseconds.\n\
The sweep time is the time in seconds spent waiting on each datapoint.\n\
Detector is the bit number in MINIMAX_SELECT word:\n\
0       CTP BUSY\n\
1-24    Sub-detector 1 to 24 BUSY (Note 2)\n\
(this is the 4th row in VALID.LTUs)\n\
25-30   Cluster 1 to 6 BUSY (Note 3)\n\
31       Test cluster BUSY\n\
";

char startRead3SSM_usagehelp[]="Do the following for l1, l2, int boards:\n\
Start After 27ms, Read into ssm[] \n\
Out: message issued if time between 1st board start and last board start\n\
too high (>80us).\n\
rc: 0: ok\n\
   >0: error (printed to stdout)\n\
";

Tpardesc L2a2Interface_parameters[3]={
{"boardl1", 1},
{"boardl2", 1},
{"boardint", 1}};
char L2a2Interface_usagehelp[]=" *  analyze interface board data\n\
 *  L2alist - list of CTP readout from L2 board\n\
 *  INTlist - list of CTP readout and IR data from Interface board\n\
-dump to $VMEWORKDIR/IntList.txt\n\
in: 2 3 4  (l1 l2 int board index in ssm[])\n\
Note: start startRead3SSM() before\n\
";

Tpardesc dumpIntSsm_parameters[1]={
{"board", 1}};
char dumpIntSsm_usagehelp[]=" * Dumps Interface board ssm. Word is in output if any bit nonzero.\n\
 * SSM should be read before\n\
";

Tpardesc dumpL2amesage_parameters[1]={
{"board", 1}};
char dumpL2amesage_usagehelp[]=" * get L2 message from L2 board\n\
- dump something to file $VMEWORKDIR/L2amessageList.txt\n\
 ";

char dumpCTP_usagehelp[]="Dump CTP configuration.\n\
L0 BOARD CLASSES section:\n\
class: L0_CONDITION L0_VETO L0_RATE L0_MASK [L0_INVERT for classes45-50 or all]\n\
";

Tpardesc getPF_parameters[1]={
{"ix", 1}};
char getPF_usagehelp[]="get PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
";

Tpardesc getPFc_parameters[2]={
{"ix", 1},
{"circ", 1}};
char getPFc_usagehelp[]="get PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
O: on stdout: 3 hexadecimal numbers: PFBLOCK_A, PFBLOCK_B, PFLUT\n\
";

Tpardesc getprtPF_parameters[1]={
{"ix", 1}};
char getprtPF_usagehelp[]="like getPF\n\
";

Tpardesc getprtPFc_parameters[2]={
{"ix", 1},
{"circ", 1}};
char getprtPFc_usagehelp[]="like getPFc\n\
";

Tpardesc setPF_parameters[2]={
{"ix", 1},
{"pfc", 2}};
char setPF_usagehelp[]="set PF parameters for 1 board (L0, L1, or L2 -> ix= 1, 2 or 3)\n\
pfc: PF_COMMON word\n\
";

Tpardesc setPFc_parameters[5]={
{"ix", 1},
{"circ", 1},
{"A", 2},
{"B", 2},
{"LUT", 2}};
char setPFc_usagehelp[]="set PF parameters for 1 circuit \n\
I:\n\
L0, L1, or L2 -> ix= 1, 2 or 3\n\
circ -> 1..5\n\
A, B, LUT -3 words to be written\n\
";

Tpardesc printPFwc_parameters[1]={
{"deltat", 1}};
char printPFwc_usagehelp[]="Print setings (12 hexa numbers) of PFcircuit for deltat in BCs\n\
First hexa number is 0xffffffff if error\n\
";

char getShared_usagehelp[]="get rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2 INTSEL1 INTSEL2 allrare\n\
";

Tpardesc getSharedL0f34_parameters[1]={
{"lutout", 1}};
char getSharedL0f34_usagehelp[]="get 4096 hexa chars each containing i-bit of LUT4-1. i:0..4095\n\
";

char setSharedL0f34_usagehelp[]="4096 hexa chars from stdin will be loaded to LUT31 32 41 42";

Tpardesc setShared_parameters[9]={
{"r1", 2},
{"r2", 2},
{"bs1", 2},
{"bs2", 2},
{"int1", 2},
{"int2", 2},
{"intt", 2},
{"l0fun1", 2},
{"l0fun2", 2}};
char setShared_usagehelp[]="set rnd1 rnd2 bcsc1 bcsd2 int1 int2 intt L0fun1 L0fun2\n\
";

Tpardesc setShared2_parameters[2]={
{"intsel", 2},
{"allrare", 2}};
char setShared2_usagehelp[]="set INTERACTSEL ALL_RARE_FLAG\n\
";

Tpardesc loadRun_parameters[1]={
{"runnumber", 2}};
char loadRun_usagehelp[]="Load run reading RCFG file in WORK directory \n\
";

char printHW_usagehelp[]="Prints static class CTPHardware.\n\
";

Tpardesc unloadRun_parameters[1]={
{"runnumber", 2}};
Tpardesc notInCrate_parameters[1]={
{"ix", 1}};
Tpardesc findBUSYINP_parameters[2]={
{"fo", 1},
{"foc", 1}};
Tpardesc findDeadBusysRuns_parameters[1]={
{"time", 1}};
char findDeadBusysRuns_usagehelp[]=" Input: time in milisecs\n\
 For detectors in clusters as defined on busy board \n\
 it calculates and prints average: \n\
  -fraction of the time detectors is busy \n\
  -average deadtime\n\
";

Tpardesc printLastDetectors_parameters[1]={
{"cluster", 2}};
char printLastDetectors_usagehelp[]=" For detectors in clusters as defined on busy board\n\
 it reads LasBusy counter.\n\
 Last busy counts number of cases when detector is releasing busy LAST\n\
 in given cluster.\n\
";

Tpardesc busyprobe_parameters[1]={
{"det", 3| 0x80000000}};
char busyprobe_usagehelp[]="Busy probe option - minimax select word\n\
Select the object you want to study:\n\
0- CTP BUSY\n\
1-24 : detectors\n\
25-30 : clusters\n\
31 test cluster\n\
";

Tpardesc findDeadBusys_parameters[1]={
{"dets", 2}};
char findDeadBusys_usagehelp[]="Input: dets is pattern of detectors to be checked.  0xffffff: all dets\n\
Operation:\n\
- read busy timers\n\
- sleep 100ms\n\
- read busy timers \n\
- calculate difference between 2 measurements and compare \n\
  with busy_timer\n\
rc: busy pattern: [0..23] bits set to 1 correspond to Dead busy inputs\n\
";

Tpardesc GenSwtrg_parameters[6]={
{"n", 1},
{"trigtype", 3},
{"roc", 1},
{"BC", 2},
{"detectors", 2},
{"customer", 1}};
Tpardesc getCALIBBC2_parameters[1]={
{"ctprodets", 2}};
Tpardesc checkScopeBoard_parameters[1]={
{"ab", 3}};
Tpardesc setScopeBoard_parameters[2]={
{"ab", 3},
{"board", 1}};
Tpardesc getScopeSignal_parameters[2]={
{"board", 1},
{"ab", 3}};
Tpardesc setScopeSignal_parameters[3]={
{"board", 1},
{"ab", 3},
{"signal", 1}};
Tpardesc setVMERWScope_parameters[2]={
{"newv", 2},
{"oldv", 2}};
Tpardesc getSWLEDS_parameters[1]={
{"ixboard", 1}};
char getSWLEDS_usagehelp[]="Print 1 line string xxxx\n\
where x is the status (0/1) of software LED word\n\
";

Tpardesc setEdge_parameters[3]={
{"board", 1},
{"input", 2},
{"edge", 2}};
char setEdge_usagehelp[]="board:0:busy (the CLK edge for input ORBIT signal) \n\
      1..3:L0/1/2  \n\
input: no sense for busy board.For L0/1/2 boards: L0,L1:1..24   L2:1..12\n\
edge: 0:Positive 1:Negative\n\
\n\
Edge: choose negative (for delay:0) if unstability is found around delay 0.\n\
";

Tpardesc setEdgeDelay_parameters[4]={
{"board", 1},
{"input", 1},
{"edge", 1},
{"delay", 1}};
char setEdgeDelay_usagehelp[]="set Edge/Delay \n\
Inputs:\n\
board: 1:L0 2:L1 3:L2\n\
input: 1..24 (1..12 for L2)\n\
edge:  0:positive 1:negative\n\
delay: 0..15";

Tpardesc printEdgeDelay_parameters[1]={
{"board", 1}};
char printEdgeDelay_usagehelp[]="Read edge/delay info from hw for all the inputs (clk edge for ORbit\n\
in case of busy board).\n\
Inputs:\n\
  board: 0:busy (the CLK edge for INPUT ORBIT signal)\n\
         1..3: L0/1/2\n\
  input: 1..24 (for L0/1 boards) 1..12 for L2 board\n\
\n\
Edge: choose negative (for delay:0) if unstability is found around delay 0.\n\
\n\
";

char getBCmasks_usagehelp[]="read BC masks from HW and print out 3564 4bits words\n\
";

char setBCmasks_usagehelp[]="set BC masks in HW from input line containing 3564 hexa-chars.\n\
";

Tpardesc checkBCmasks_parameters[2]={
{"ntimes", 1},
{"words", 1}};
char checkBCmasks_usagehelp[]="set/read/check ntimes\n\
words: if 0 than check whole BCmask memory (3564)\n\
";

char checkPhasesPrint_usagehelp[]="return 5 integers in 1 line corresponding to clcock phase on L0/1/2 BUSY INT\n\
";

Tpardesc Toggle_parameters[2]={
{"det", 3| 0x80000000},
{"onoff", 1}};
char resetPLLS_usagehelp[]="Resets PLL clock on all boards\n\
";

Tpardesc WritePFcommon_parameters[3]={
{"INTa", 2},
{"INTb", 2},
{"Delayed_INT", 2}};
Tpardesc WritePF_parameters[8]={
{"icircuit", 2},
{"THa1", 2},
{"THa2", 2},
{"THb1", 2},
{"THb2", 2},
{"dTa", 1},
{"dTb", 1},
{"P_signal", 2}};
Tpardesc WritePFuser_parameters[3]={
{"icircuit", 2},
{"threshold", 2},
{"bcs", 2}};
char WritePFuser_usagehelp[]="Set PF circuit for INT1 only (for INT1/2 combinations, another\n\
function should be prepared). Note that INT1 should be defined in Shared Resources!\n\
Examples of INT1 definition: it can be BC1,BC2,RND1,RND2 or any logical combination of \n\
first 4 L0 inputs (INTfun1). For example if we want to define INT1 as L01 input then INTfun1 \n\
will be 0xaaaa, L02 only -> INTfun1=0xcccc, L03 only -> INTfun1=0xf0f0, L04 only -> INTfun1=0xff00,\n\
L01.or.L02.or.L03.or.L04 -> INTfun1=0xfffe, L01.and.L02.and.L03.and.L04 -> INTfun1=0x8000\n\
\n\
icircuit: 1..4 - circuit number - there can be 4 PF protections in parallel\n\
\n\
bcs: 1..4096 - protected interval in BCs. \n\
For example: 10mus = 400 BC.\n\
\n\
threshold: 0..63 - number of allowed interactions in protected interval \n\
For example: 0: kill this event  1: only this event   2: max. 1 additional event\n\
";

Tpardesc WritePFuserII_parameters[5]={
{"Ncoll", 2},
{"dT1", 2},
{"dT2", 2},
{"icircuit", 2},
{"plut", 2}};
char CTP_Classes_usagehelp[]="The Classes definition, i.e. for each (1-50) class: \n\
 -enabling/disabling\n\
 -L0,L1,L2 inputs and selectable vetos\n\
 -cluster\n\
 -L0 pre-scaler\n\
";

char CTP_Clusters_usagehelp[]="The Clusters definition, i.e. which detectors (LTUs) belong to each cluster.\n\
Cluster definition consist of 'assignment of clusters to\n\
each Fanout connector'.\n\
";

char Resources_usagehelp[]="The Shared resources definition. They are:\n\
- random generators(2) and BC generators(2) rates\n\
- 3 Interaction functions (16 bits lookup tables)\n\
- 2 L0 input functions (16 bits lookup tables)\n\
- 2 Interaction selectors\n\
- All/Rare events CTP option\n\
- 5 Past/Future protection circuits for all trigger levels \n\
    (PF1-PF4 for physics and PF5 for Test Class)\n\
";

char Counters_usagehelp[]="Displays counters on all CTP boards\n\
";

char CheckTestClass_usagehelp[]="Test class control.\n\
";

char ScopeAB_usagehelp[]="Signal selection for front panel \n\
A,B outputs\n\
";

char SSMbrowser_usagehelp[]="Browse CTP snapshot memories \n\
";

char SSMcontrol_usagehelp[]="The CTP snapshot memories control\n\
";

char SaveFile_usagehelp[]="- Save configuration to WORK/.cfg configuration to file\n\
";

char LoadFile_usagehelp[]="- Load configuration from WORK/.cfg configuration to file\n\
Todo:\n\
- check hw configuration with the memory-configuration\n\
- Load (i.e. add) partition configuration (i.e. from .configuration\n\
  file prepared by partition editor)\n\
";

char Readhw_usagehelp[]="- Load configuration from CTP boards\n\
";

char Write2hw_usagehelp[]="- Write configuration into CTP boards\n\
";

char readORBIT_READs_usagehelp[]="read/print 2 counters: L2_ORBIT_READ and INT_ORBIT_READ ";

char i2creadall_usagehelp[]="Go through all boards in the CTP crate and print (ltuX, X is ECSnumber+1 from VALID.LTUS):\n\
- I2C values  (4 voltages)\n\
- temperature (1 value in centigrades)\n\
";

Tpardesc setClusters_parameters[8]={
{"daqbsy", 2},
{"tc", 2},
{"c1", 2},
{"c2", 2},
{"c3", 2},
{"c4", 2},
{"c5", 2},
{"c6", 2}};
char setClusters_usagehelp[]="Set daqbsy, T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board\n\
";

char getClusters_usagehelp[]="Read T,1,2,3,4,5,6 SET_CLUSTER word on the BUSY board and print it as 1 line\n\
";

char getDAQbusy_usagehelp[]="Read DAQ_BUSY word ";

Tpardesc getFO_parameters[1]={
{"ix", 1}};
char getFO_usagehelp[]="ix: FO1BOARD..FO1BOARD+5   (6 FO boards)\n\
always read FO board's CLUSTER, TEST_CLUSTER words\n\
STDOUT:\n\
- no output                if ix FO is not in the crate\n\
cluster testcluster        for FO in the crate\n\
";

Tpardesc setFO_parameters[3]={
{"ix", 1},
{"cluster", 2},
{"tcluster", 2}};
char setFO_usagehelp[]="write to FO board's registers only if modified\n\
ix: FO1BOARD..FO1BOARD+5   (i.e. 5-10, 6 FO boards)\n\
cluster: 0x44332211      11 - bits [5..0]: clusters fed through 1st connector\n\
tcluster: 0xXCT4321\n\
X   : bits[31..28]: toggle signal on connector 4..1\n\
C   : bit[20]       calibration flag for sw trigger\n\
T   : bits[19..16]: sw trigger (test class) for connector 4..1\n\
4   : bits[15..12]: RoC for connector 4\n\
";

Tpardesc setFOrocs_parameters[2]={
{"calflag", 1},
{"roc", 2}};
char setFOrocs_usagehelp[]="set cal. flag and roc on ALL the FO boards\n\
";

Tpardesc swtrigger_parameters[1]={
{"ssm", 1}};
char swtrigger_usagehelp[]="Start SW trigger.\n\
Input:\n\
ssm: 1   ->start SSM recording in L0 output moinitoring mode before\n\
           starting trigger\n\
Operation:\n\
- clear flags\n\
- start SSM (optionally)\n\
- start sw trigger\n\
- usleep(200) -micsecs\n\
- read L0_TCSTATUS word\n\
Output:\n\
L0_TCSTATUS word\n\
ToDo: -for whic detector? \n\
      - ROC bits to be written to FO and INT board\n\
";

char getTCSTATUS_usagehelp[]="ret: TCSTATUS bits from L0,1,2 boards:\n\
Bits:\n\
4-0  L0_TCSTATUS bits\n\
5    L1_TCSTATUS bit3 (L1ack flag)\n\
7-6  L2_TCSTATUS bits (L2Aack and L2Rack)\n\
";

char getTCSET_usagehelp[]="ret: TC_SET bits from L0,1,2 boards:\n\
Bits:\n\
18-0  L0_TC_SET bits\n\
19   L1_TC_SET bit18 (P/F veto)\n\
20   L2_TC_SET bit24 (P/F/veto)\n\
";

Tpardesc setTCSET_parameters[2]={
{"tcset012", 2},
{"dets", 2}};
char setTCSET_usagehelp[]="tcset012 -extended mening (bits 18,19 -see getTCSET() )\n\
";

char clearTC_usagehelp[]="operation: clear TC flags on all the boards\n\
";

Tpardesc getClass_parameters[1]={
{"klas", 1}};
char getClass_usagehelp[]="klas: 1-50   -class number\n\
get L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n\
    L1_DEFINITION L1_INVERT L2_DEFINITION words for klas\n\
i.e. 7 hexa numbers.\n\
L0_INVERT, L1_INVERT are 0:for classes 1-44 (not valid for  >AC) or \n\
corresponding board is not in the crate\n\
";

Tpardesc setClass_parameters[8]={
{"klas", 1},
{"condition", 2},
{"invert", 2},
{"veto", 2},
{"scaler", 2},
{"l1def", 2},
{"l1invert", 2},
{"l2def", 2}};
char setClass_usagehelp[]="set L0_CONDITION L0_INVERT L0_VETO L0_PRESCALER \n\
    L1_DEFINITION L1_INVERT L2_DEFINITION\n\
words for klas (1..50)\n\
ATTENTION: \n\
1. bit17 (0x10000) of veto is CLASS MASK bit written into bit0 of L0_MASK\n\
   bit31 for firmAC\n\
2. invert,l1invert -valid only for class>=45\n\
";

char disableClasses_usagehelp[]="disable all 50 classes, i.e.:\n\
- set all inputs,vetos as dontcare for all 50 classes i.e.:\n\
L0_CONDITION = 0xffffffff\n\
L0_VETO      = 0xfffffff0   (cluster0) bit31:1-> class is disabled\n\
and 0x0 in:\n\
L0_INVERT   =0\n\
L0_PRESCALER=0\n\
";

char hw2rates_usagehelp[]="read all rates (scalers) from hw to Klas structure\n\
";

char rates2hw_usagehelp[]="write all rates (scalers) from Klas structure to hw\n\
";

Tpardesc clearSPY_parameters[1]={
{"board", 1}};
char clearSPY_usagehelp[]="check spy memory (256 words from 0x9400 on L0 board )\n\
Operation: \n\
- write a, a+1 a+2 ... \n\
- read back and check\n\
- write 0s to all the 256 words\n\
";

Tpardesc setRates4HLTtest_parameters[1]={
{"rate", 1}};
char setRates4HLTtest_usagehelp[]="To be used with CTP_hlttest (instance of PHYSICS_1 in ACT)\n\
and mask defining 12 B-bunches. CTP_hlttest:\n\
ALL cluster:\n\
DEMPTY(cn=CINT1-B-NOPF-ALLNOTRD,rnd1,BCM2,cg=8)\n\
D1DUM(cn=CINT1-AC-NOPF-ALLNOTRD,rnd2,BCM2,cg=8)\n\
+ there is cluster ALL with TRD in readout driven by similar WU-classes\n\
\n\
rate: required rate in hz to be set for L2a/r classes\n\
operation:\n\
1. calculate rate for rnd1/2 generators and set in in hw:\n\
rnd2=(required_input_rate1*3564/12.) hz\n\
rnd1= rnd2+1 to get different rnd1/2 setting\n\
";

Tpardesc setEJEGA_parameters[1]={
{"delay", 1}};
char setEJEGA_usagehelp[]="set positive + delay on both 1EJE and 1EGA\n\
";

char testSYNCH_usagehelp[]="1. Prepare 24 input signals in SSM, start it in continuous input generator mode.\n\
2. set step by step (keep 1 sec delay between settings) all 24 SYNCH_ADD\n\
   from 0 to 15\n\
";

Tpardesc testBCDELAY_parameters[1]={
{"steps", 1}};
char testBCDELAY_usagehelp[]="Set BC_DELAY from 0..31 with step 1, wait 1 sec between\n\
steps: number of steps (0..34)\n\
";

Tpardesc orbitscan_parameters[1]={
{"steps", 1}};
char orbitscan_usagehelp[]="Operation:\n\
-Set BC_DELAY from 0..31 with step 1, \n\
-read BUSY_ORBIT_SELECT word (follow bit14: 0x4000 0:negBC 1:posBC)\n\
-wait 300 usecs between\n\
Input:\n\
steps: number of steps \n\
Output: Table: delay Edgeflag\n\
";

Tpardesc setOrbitBChalf_parameters[1]={
{"bit8", 1}};
char setOrbitBChalf_usagehelp[]="set Orbit on backplane to BC/2 signal.\n\
bit8: 1 ->set toggling     0->disable toggling\n\
Necessary for delay measurement on l0/l1/l2 board.\n\
";

Tpardesc rwvmeloop_parameters[5]={
{"address", 2},
{"loops", 1},
{"value", 2},
{"mics", 1},
{"ring", 1}};
char rwvmeloop_usagehelp[]="VME read/write in the loop (for l1glitch testing)\n\
Inputs:\n\
address: vme address or\n\
         0: read counters on all boards readCounters() (no I2C)\n\
         1: readTVCounters() -I2C only\n\
         2: do not read vme\n\
loops:   number of loops (0: endless loop)\n\
value:   0: read 1: write alternating 0/0xffffffff >1: write this value\n\
mics:  sleep time in micsecs between reads\n\
ring:    32 do not ring, 0..31 -altrenate this bit in address \n\
";

Tpardesc printBoardCounters_parameters[2]={
{"board", 1},
{"N", 1}};
char printBoardCounters_usagehelp[]="read+print N counters of the board \n\
board (0:busy, 1:L0 2:L1, 3:L2, 4:INT, 5:FO1...)\n\
N==0: read+print all counters (according to ctpcounters.h) of the board\n\
";

char dumpCounters_usagehelp[]="Dump choosen counters to file $VMEWORKDIR/counters.dump\n\
";

Tpardesc micsleep_parameters[1]={
{"mics", 1}};
char micsleep_usagehelp[]="Wait mics microeconds (using system usleep() call) ";

Tpardesc RNDsync_parameters[1]={
{"mask", 1}};
char RNDsync_usagehelp[]="Synchronise/desynchronise random generators\n\
mask:\n\
3 synchronise RND1 and RND2 generators on L0 board\n\
1 desynchronise RND1 and RND2 generators on L0 board\n\
";

Tpardesc changeTL2_parameters[1]={
{"tl2", 1}};
char changeTL2_usagehelp[]="TL2 play. Normal value: 3952\n\
Corresponding L2_DEALY_L1, FO_DELAY_L1CLST, L2_BCOFFSET:\n\
3628 456 383\n\
";

char initmain_usagehelp[]="   rc: 0 -board ix is in the crate \n\
       1 -board ix is not in the crate\n\
";

char readstatus_usagehelp[]="read QPLL* and TTCrx status bits.\n\
RC: 0xTAB\n\
T: bit 8. 1: TTCrx ok\n\
A: [7..6] BC1 error,locked (i.e. 01 correct)\n\
   [5..4] BC2\n\
B: [3..2] BCref\n\
   [1..0] BCmain\n\
I.e. 0x155 is correct status of all 9 bits\n\
     0x1aa error in both BC, was not locked. NEXT READING is 0x155 !\n\
";

Tpardesc getCounter_parameters[3]={
{"board", 1},
{"reladr", 1},
{"customer", 1}};
Tpardesc getCounters_parameters[3]={
{"N", 1},
{"accrual", 1},
{"customer", 1}};
Tpardesc clearCounters_parameters[1]={
{"customer", 1}};
char l0AB_usagehelp[]="rc: 0: if L0 borad firmware >0xAB\n\
    boardversion if firmware <=0xAB \n\
";

Tpardesc DAQonoff_parameters[1]={
{"daqon", 1}};
char DAQonoff_usagehelp[]="daqon:0       ->daq active\n\
daqon:0xb     ->daq off (i.e. produce triggers in spite of DDL red diode \n\
                on INT board is on \n\
daqon: other  -> show current status.\n\
NOTE about LEDs on INT board:\n\
DDL interface: \n\
  green:DDL line ready, data not read out \n\
  flashing green: DDL line ready, data are read out\n\
  flashing orange: data are read out, backpressure is sometimes active\n\
                   (DAQ is not able to read everything)\n\
upper DDL LED on INT board fron panel:\n\
  red: INT is raising CTPBUSY on backlplane, because of full DDL buffers\n\
INT_DDL_EMU word in normal mode (i.e. DAQ active):\n\
     DDLfiLF  DDLfiBEN  DDLfiDIR\n\
0x20:      0         1         0  data can't be sent (DDL not enabled from DIU)\n\
0x30:      0         1         1  data sent\n\
0x70:      1         1         1  data not sent (backpressure)\n\
";

Tpardesc getswSSM_parameters[1]={
{"board", 1}};
char getswSSM_usagehelp[]="-------------------------------------------------------------- getswSSM() \n\
return status word of SSM\n\
LTU: [4] FrontPanel->SSM mode active\n\
     [3] not used\n\
     [2] BUSY bit\n\
     [1..0] operation\n\
CTP: [8] -BUSY\n\
     [7..6] Enable SSM Input..Output flag\n\
     [5..4] ConfSel bits\n\
     [3..3] InOut flag   0:out   1:in\n\
     [2..1] Operation bits \n\
     [0..0] mode bit \n\
error: 0xdeadbeaf\n\
";

Tpardesc setsmssw_parameters[2]={
{"ix", 1},
{"newmode", 3| 0x80000000}};
char setsmssw_usagehelp[]="-------------------------------------------------------------- setsmssw() \n\
set sms[].mode\n\
";

Tpardesc setomSSM_parameters[2]={
{"board", 1},
{"opmo", 2}};
char setomSSM_usagehelp[]="Set operation & mode. If SSM is BUSY, an attempt is made to stop\n\
the recording.\n\
Input parameteres:\n\
board -number of the board (index into global sms array) \n\
       0..NSSMBOARDS    (busy,L0,1,2,int,fo1,2,3,4,5,6,ltu1,2,3,4)\n\
opmo  -mode/operation bit for SSMcommand word. symbolic names \n\
       are defined in ctp.h (as SSMom*)\n\
\n\
opmo for LTU boards:\n\
--------------\n\
0x0 -VME access, read\n\
0x1 -VME access, write\n\
0x2 -RECORDING, After  (cca 26 milsec)\n\
0x3 -RECORDING, Before (should be stopped by SSMstoprec)\n\
\n\
Bit opmo[4] (0x10) should be set to 1 for LTU/RECORDING mode\n\
    (new feature 'FrontPanel->SSM' introduced for LTU 7.10.2005)\n\
    If not set, signals from LTU-FPGA will be recorded.\n\
\n\
opmo for CTP boards:\n\
--------------\n\
The codes above (0-3) are valid, in addition 7 bits (opmo[9..3] are\n\
meaningfull, and 2 more codes are added:\n\
0x4 - GENERATING, single pass\n\
0x5 - GENERATING, continuous\n\
opmo[9..8] - bits to be used for selecting SSMenable word\n\
             10 ->enable Input    01 ->enable Output\n\
opmo[7..6] - not used\n\
opmo[5..4] - ConfSel bits  (defined in \n\
               $VMECFDIR/CFG/ctp/ssmsigs/.sig files)\n\
opmo[3]      - InOut flag   1:in   0:out (side of FPGA logic)\n\
Examples: \n\
0x20d - generate continuously  inputs for board logic\n\
0x20c - generate 1 pass (27ms) inputs for board logic\n\
0x102 - record   1 pass (27ms) of board logic outputs\n\
RC:  0->ok, mode set\n\
     1->mode not set, possible errors (printed to stdout):\n\
        -BC signal not connected\n\
        -Cannot stop recording operation\n\
     2->bad mode for LTU board\n\
";

Tpardesc startSSM1_parameters[1]={
{"board", 1}};
Tpardesc stopSSM_parameters[1]={
{"board", 1}};
char stopSSM_usagehelp[]="------------------------------------------------------- stopSSM()\n\
Opearation:\n\
- check if board is in BUSY status\n\
- stop (recording or generation)\n\
rc: == 0 OK\n\
       1 board not busy, no action\n\
       2 problem with openvme for LTU\n\
";

Tpardesc condstopSSM_parameters[5]={
{"board", 1},
{"cntpos", 1},
{"maxloops", 1},
{"sleepafter", 1},
{"customer", 1}};
char condstopSSM_usagehelp[]="Opearation:\n\
- read counter cntpos\n\
- check 'the change of this counter' + check maxloops\n\
- sleep 'sleepafter' micsecs (should be 0 or at least 100)\n\
- stop (recording or generation) -> call stopSSM()\n\
Inputs:\n\
board: 0:busy, 1:L0,..., 10:INT\n\
      21: L0+L1 -> i.e. stop 2 SSM for L0/1 board\n\
cntpos: position of the counter (starting from 0) for this board\n\
        see 2. column in dimcdistrib/cnames.sorted2 file\n\
maxloops: max. number of loops (1 loop == cca 2 ms)\n\
          0: loop forever\n\
customer: bakery customer (see ctplib/readCounters.c)\n\
rc: == 0 OK\n\
   1 board not busy, no action (i.e. SSM was not started before in\n\
     'BEFORE/continuous' mode)\n\
   2 problem with openvme for LTU\n\
  10 timeout (counter did not change even after 'maxloops' reads)\n\
--------------------- ";

Tpardesc readSSM_parameters[1]={
{"board", 1}};
char readSSM_usagehelp[]="--------------------------------------------------------- readSSM()\n\
read whole SSM into array of unsigned ints\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
Output:\n\
rc:  0 SSM read into sms[board].sm->\n\
       i.e. Mega words were read\n\
    >0 only part of SSM was read into sms[board].sm-> \n\
       reason in After or Before mode:\n\
       - SSM stopped early (<26ms)\n\
";

Tpardesc writeSSM_parameters[1]={
{"board", 1}};
char writeSSM_usagehelp[]="------------------------------------------------------ writeSSM()\n\
write whole sms[].sm into hardware\n\
Note: InOut, ConfSel bits and SSMenable word left unchanged\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
";

Tpardesc dumpSSM_parameters[2]={
{"board", 1},
{"fname", 3| 0x80000000}};
char dumpSSM_usagehelp[]="------------------------------------------------------ dumpSSM()\n\
write whole sms[].sm into hardware\n\
Input:\n\
board: board according to sms global array\n\
rc:    0: no errors found during writing\n\
";

Tpardesc dumpssm_compress_parameters[3]={
{"board", 1},
{"fname", 3| 0x80000000},
{"compress", 1}};
char dumpssm_compress_usagehelp[]="Dump computer ssm (not hw ssm)\n\
compress: 0: old way 1; new way i.e. compressed\n\
";

Tpardesc printSSM_parameters[2]={
{"board", 1},
{"fromadr", 1}};
char printSSM_usagehelp[]="print to stdout SSM board from word 'fromadr'\n\
";

Tpardesc readSSMDump_compress_parameters[3]={
{"board", 1},
{"filename", 3| 0x80000000},
{"compress", 1}};
char readSSMDump_compress_usagehelp[]=" Read binary dump written before by dumpSSM() to the sms[board].sm\n\
board: 0,1,2,... ->   BUSY, L0, L1,...\n\
filename: 'WORK/name.dmp'\n\
compress: 0: old way 1; new way i.e. compressed\n\
";

char gettableSSM_usagehelp[]="return the names+modes of SSMs for present boards:\n\
stdout:\n\
name1 mode1 \n\
name2 mode2 \n\
...\n\
mode -mode of the ssm or:\n\
      _nomode if sms[ix].mode is epmty string\n\
      notin  board is not in the crate\n\
      nossm  if board or sms[ix].sm==NULL\n\
";

Tpardesc getsfSSM_parameters[1]={
{"board", 1}};
char getsfSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

char getsyncedSSM_usagehelp[]="return line:\n\
highest_syncflag n1 n2...\n\
n1,n2 -numbers of items (indexes into sms[])\n\
";

Tpardesc getsigSSM_parameters[4]={
{"board", 1},
{"bit", 1},
{"frombc", 1},
{"bits", 1}};
char getsigSSM_usagehelp[]="Extract 1 signal to stdout:\n\
Input:\n\
board:   (0...) according to sms global array\n\
bit:     SSM bit (0-31)\n\
frombc: bc number. \n\
         0 corresponds to word with address sms[board].offset\n\
bits:    number of bits to be examined (but don't print more then\n\
         102 lines)\n\
Output:\n\
value_of_the_1st_bit      or <0 if error\n\
bit_number_for_which_value_changed\n\
bit_number_for_which_value_changed\n\
...\n\
Errors:\n\
-1 -> required SSM not read\n\
";

Tpardesc finddifSSM_parameters[3]={
{"board", 1},
{"bit", 1},
{"frombc", 1}};
char finddifSSM_usagehelp[]="Find signal change.\n\
Input:\n\
board,bit,frombc: as in getsigSSM()\n\
Output (on stdout):\n\
-1 -signal does not change (or memory not accessible)\n\
n  - pointing to the last bit with the same value, next bit\n\
     is different\n\
";

Tpardesc getoffsetSSM_parameters[1]={
{"board", 1}};
char getoffsetSSM_usagehelp[]="print sms[board].offset\n\
";

Tpardesc setoffsetSSM_parameters[2]={
{"board", 1},
{"newoffset", 1}};
char setoffsetSSM_usagehelp[]="set sms[board].offset\n\
";

Tpardesc setmodeSSM_parameters[3]={
{"board", 1},
{"newmode", 3| 0x80000000},
{"ltubase", 3| 0x80000000}};
char setmodeSSM_usagehelp[]="set sms[board].mode, ltubase\n\
board: 0..  index into sms[]\n\
newmode: file name in CFG/ctp/ssmsigs without .sig suffix\n\
ltubase: valid only for ltu (board>10)\n\
";

char printsms_usagehelp[]="set sms[board].offset\n\
";

void readMINIMAXSel();
void writeMINIMAXSel(w32 word);
void writeMINIMAXClear();
void readMINMAX();
void readMINIMAXLimit();
void writeMINIMAXLimit(w32 word);
void readBUSYlong(w32 delay);
int busytool(int rangemax, int rangemin, int stepsize, int sweeptime, w32 detector);
int startRead3SSM();
int L2a2Interface(int boardl1, int boardl2, int boardint);
int dumpIntSsm(int board);
int dumpL2amesage(int board);
void dumpCTP();
void getPF(int ix);
void getPFc(int ix, int circ);
void getprtPF(int ix);
void getprtPFc(int ix, int circ);
void setPF(int ix, w32 pfc);
void setPFc(int ix, int circ, w32 A, w32 B, w32 LUT);
void printPFwc(int deltat);
void getShared();
void getSharedL0f34(int lutout);
void setSharedL0f34();
void setShared(w32 r1, w32 r2, w32 bs1, w32 bs2, w32 int1, w32 int2, w32 intt, w32 l0fun1, w32 l0fun2);
void setShared2(w32 intsel, w32 allrare);
void loadRun(w32 runnumber);
void printHW();
void unloadRun(w32 runnumber);
void printL0FUN34();
int notInCrate(int ix);
int findBUSYINP(int fo, int foc);
w32 findDeadBusysRuns(int time);
void printLastDetectors(w32 cluster);
void busyprobe(char *det);
w32 findDeadBusys(w32 dets);
int GenSwtrg(int n, char trigtype, int roc, w32 BC, w32 detectors, int customer);
int getCALIBBC2(w32 ctprodets);
int checkScopeBoard(char ab);
int setScopeBoard(char ab, int board);
int getScopeSignal(int board, char ab);
int setScopeSignal(int board, char ab, int signal);
int getVMERWScope();
void setVMERWScope(w32 newv, w32 oldv);
void getSWLEDS(int ixboard);
void setEdge(int board, w32 input, w32 edge);
void setEdgeDelay(int board, int input, int edge, int delay);
void printEdgeDelay(int board);
void getBCmasks();
void setBCmasks();
void checkBCmasks(int ntimes, int words);
void checkPhasesPrint();
void printToggle();
int Toggle(char *det, int onoff);
void resetPLLS();
void ReadPF();
void WritePFcommon(w32 INTa, w32 INTb, w32 Delayed_INT);
void WritePF(w32 icircuit, w32 THa1, w32 THa2, w32 THb1, w32 THb2, int dTa, int dTb, w32 P_signal);
void WritePFuser(w32 icircuit, w32 threshold, w32 bcs);
int WritePFuserII(w32 Ncoll, w32 dT1, w32 dT2, w32 icircuit, w32 plut);
void readORBIT_READs();
void i2creadall();
void setClusters(w32 daqbsy, w32 tc, w32 c1, w32 c2, w32 c3, w32 c4, w32 c5, w32 c6);
void getClusters();
void getDAQbusy();
void getFO(int ix);
void setFO(int ix, w32 cluster, w32 tcluster);
void setFOrocs(int calflag, w32 roc);
w32 swtrigger(int ssm);
w32 getTCSTATUS();
w32 getTCSET();
void setTCSET(w32 tcset012, w32 dets);
void clearTC();
void getClass(int klas);
void setClass(int klas, w32 condition, w32 invert, w32 veto, w32 scaler, w32 l1def, w32 l1invert, w32 l2def);
void disableClasses();
void hw2rates();
void rates2hw();
void clearSPY(int board);
void setRates4HLTtest(int rate);
void setEJEGA(int delay);
void testSYNCH();
void testBCDELAY(int steps);
void orbitscan(int steps);
void setOrbitBChalf(int bit8);
void rwvmeloop(w32 address, int loops, w32 value, int mics, int ring);
void printBoardCounters(int board, int N);
void dumpCounters();
void ReadTemperatures();
void TestLEDS();
void micsleep(int mics);
void RNDsync(int mask);
void changeTL2(int tl2);
void initmain();
w32 readstatus();
w32 getCounter(int board, int reladr, int customer);
void getCounters(int N, int accrual, int customer);
void clearCounters(int customer);
int l0AB();
void DAQonoff(int daqon);
w32 getswSSM(int board);
void setsmssw(int ix, char *newmode);
int setomSSM(int board, w32 opmo);
int startSSM1(int board);
int stopSSM(int board);
int condstopSSM(int board, int cntpos, int maxloops, int sleepafter, int customer);
int readSSM(int board);
int writeSSM(int board);
int dumpSSM(int board, char *fname);
int dumpssm_compress(int board, char *fname, int compress);
void printSSM(int board, int fromadr);
int readSSMDump_compress(int board, char *filename, int compress);
void gettableSSM();
void getsfSSM(int board);
void getsyncedSSM();
void getsigSSM(int board, int bit, int frombc, int bits);
void finddifSSM(int board, int bit, int frombc);
void getoffsetSSM(int board);
void setoffsetSSM(int board, int newoffset);
void setmodeSSM(int board, char *newmode, char *ltubase);
void printsms();

int nnames=247;
Tname allnames[MAXNAMES]={
{"ctp", tSYMNAME, NULL, (w32)BoardSpaceLength, 0.0, NULL, (w32)BoardBaseAddress, NULL},
{"CODE_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x4, NULL},
{"SERIAL_NUMBER", tVMEADR, NULL, 0, 0.0, NULL, 0x8, NULL},
{"VERSION_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0xc, NULL},
{"SOFT_RESET", tVMEADR, NULL, 0, 0.0, NULL, 0x28, NULL},
{"TEMP_START", tVMEADR, NULL, 0, 0.0, NULL, 0x58, NULL},
{"TEMP_STATUS", tVMEADR, NULL, 0, 0.0, NULL, 0x5c, NULL},
{"TEMP_READ", tVMEADR, NULL, 0, 0.0, NULL, 0x60, NULL},
{"FPGAVERSION_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x80, NULL},
{"TEST_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x7e0, NULL},
{"BC_STATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xc4, NULL},
{"SSMcommand", tVMEADR, NULL, 0, 0.0, NULL, 0x19c, NULL},
{"SSMstart", tVMEADR, NULL, 0, 0.0, NULL, 0x1a0, NULL},
{"SSMstop", tVMEADR, NULL, 0, 0.0, NULL, 0x1a4, NULL},
{"SSMaddress", tVMEADR, NULL, 0, 0.0, NULL, 0x1a8, NULL},
{"SSMdata", tVMEADR, NULL, 0, 0.0, NULL, 0x1ac, NULL},
{"SSMstatus", tVMEADR, NULL, 0, 0.0, NULL, 0x1b0, NULL},
{"SSMenable", tVMEADR, NULL, 0, 0.0, NULL, 0x1b4, NULL},
{"PLLreset", tVMEADR, NULL, 0, 0.0, NULL, 0x1bc, NULL},
{"ADC_START", tVMEADR, NULL, 0, 0.0, NULL, 0xcc, NULL},
{"ADC_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0xd0, NULL},
{"SOFT_LED", tVMEADR, NULL, 0, 0.0, NULL, 0x15c, NULL},
{"COPYCOUNT", tVMEADR, NULL, 0, 0.0, NULL, 0x1d4, NULL},
{"COPYBUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x1d8, NULL},
{"COPYCLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x1dc, NULL},
{"COPYREAD", tVMEADR, NULL, 0, 0.0, NULL, 0x1e0, NULL},
{"CLEARCOUNTER", tVMEADR, NULL, 0, 0.0, NULL, 0x5ac, NULL},
{"SPY_MEMORY", tVMEADR, NULL, 0, 0.0, NULL, 0x400, NULL},
{"SCOPE_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x4f8, NULL},
{"ADC_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x500, NULL},
{"SYNCH_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x504, NULL},
{"PF_COMMON", tVMEADR, NULL, 0, 0.0, NULL, 0x564, NULL},
{"PFBLOCK_A", tVMEADR, NULL, 0, 0.0, NULL, 0x568, NULL},
{"PFBLOCK_B", tVMEADR, NULL, 0, 0.0, NULL, 0x56c, NULL},
{"PFLUT", tVMEADR, NULL, 0, 0.0, NULL, 0x570, NULL},
{"FO_CLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x240, NULL},
{"FO_TESTCLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x244, NULL},
{"FO_DELAY_L1CLST", tVMEADR, NULL, 0, 0.0, NULL, 0x248, NULL},
{"FO_FILTER_L1", tVMEADR, NULL, 0, 0.0, NULL, 0x84, NULL},
{"BUSY_DELAY_ADD", tVMEADR, NULL, 0, 0.0, NULL, 0x84c8, NULL},
{"BUSY_ORBIT_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x80d4, NULL},
{"BUSY_DISB_CTP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x80d8, NULL},
{"BUSYMAX_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x8168, NULL},
{"BUSYMINI_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x816c, NULL},
{"MINIMAX_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x8570, NULL},
{"MINIMAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0x8174, NULL},
{"MINIMAX_LIMIT", tVMEADR, NULL, 0, 0.0, NULL, 0x8578, NULL},
{"BUSYLAST_SELECT", tVMEADR, NULL, 0, 0.0, NULL, 0x857c, NULL},
{"BUSY_CLUSTER", tVMEADR, NULL, 0, 0.0, NULL, 0x8600, NULL},
{"BUSY_DAQBUSY", tVMEADR, NULL, 0, 0.0, NULL, 0x861c, NULL},
{"BUSY_L0L1DEADTIME", tVMEADR, NULL, 0, 0.0, NULL, 0x8620, NULL},
{"BUSY_CTPDEADTIME", tVMEADR, NULL, 0, 0.0, NULL, 0x8624, NULL},
{"BUSY_OVERLAP", tVMEADR, NULL, 0, 0.0, NULL, 0x8640, NULL},
{"L0_CLEAR_RND", tVMEADR, NULL, 0, 0.0, NULL, 0x90c8, NULL},
{"L0_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0x91c0, NULL},
{"L0_TCSTART", tVMEADR, NULL, 0, 0.0, NULL, 0x91c4, NULL},
{"L0_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0x91c8, NULL},
{"RATE_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x91cc, NULL},
{"RATE_CLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x91d0, NULL},
{"MASK_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0x91e4, NULL},
{"MASK_CLEARADD", tVMEADR, NULL, 0, 0.0, NULL, 0x91e8, NULL},
{"L0_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0x9400, NULL},
{"L0_CONDITION", tVMEADR, NULL, 0, 0.0, NULL, 0x9400, NULL},
{"L0_VETO", tVMEADR, NULL, 0, 0.0, NULL, 0x9600, NULL},
{"DAQ_LED", tVMEADR, NULL, 0, 0.0, NULL, 0x9600, NULL},
{"L0_MASK", tVMEADR, NULL, 0, 0.0, NULL, 0x9700, NULL},
{"L0_INVERT", tVMEADR, NULL, 0, 0.0, NULL, 0x9500, NULL},
{"L0_INVERTac", tVMEADR, NULL, 0, 0.0, NULL, 0x9800, NULL},
{"L0_INTERACT1", tVMEADR, NULL, 0, 0.0, NULL, 0x94cc, NULL},
{"L0_INTERACT2", tVMEADR, NULL, 0, 0.0, NULL, 0x94d0, NULL},
{"L0_INTERACTT", tVMEADR, NULL, 0, 0.0, NULL, 0x94d4, NULL},
{"L0_INTERACTSEL", tVMEADR, NULL, 0, 0.0, NULL, 0x94d8, NULL},
{"L0_FUNCTION1", tVMEADR, NULL, 0, 0.0, NULL, 0x94dc, NULL},
{"L0_FUNCTION2", tVMEADR, NULL, 0, 0.0, NULL, 0x94e0, NULL},
{"RANDOM_1", tVMEADR, NULL, 0, 0.0, NULL, 0x94e4, NULL},
{"RANDOM_2", tVMEADR, NULL, 0, 0.0, NULL, 0x94e8, NULL},
{"SCALED_1", tVMEADR, NULL, 0, 0.0, NULL, 0x94ec, NULL},
{"SCALED_2", tVMEADR, NULL, 0, 0.0, NULL, 0x94f0, NULL},
{"ALL_RARE_FLAG", tVMEADR, NULL, 0, 0.0, NULL, 0x94f4, NULL},
{"L0_ENA_CRND", tVMEADR, NULL, 0, 0.0, NULL, 0x94fc, NULL},
{"MASK_MODE", tVMEADR, NULL, 0, 0.0, NULL, 0x95a4, NULL},
{"L0_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0x95a8, NULL},
{"RATE_MODE", tVMEADR, NULL, 0, 0.0, NULL, 0x9700, NULL},
{"L0_FUNCTION34", tVMEADR, NULL, 0, 0.0, NULL, 0x97ec, NULL},
{"L1_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xa1c0, NULL},
{"L1_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xa1c8, NULL},
{"L1_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xa400, NULL},
{"L1_DEFINITION", tVMEADR, NULL, 0, 0.0, NULL, 0xa400, NULL},
{"L1_DELAY_L0", tVMEADR, NULL, 0, 0.0, NULL, 0xa4cc, NULL},
{"L1_INVERT", tVMEADR, NULL, 0, 0.0, NULL, 0xa500, NULL},
{"ROIP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0xa600, NULL},
{"L2_DEFINITION", tVMEADR, NULL, 0, 0.0, NULL, 0xb400, NULL},
{"L2_ORBIT_READ", tVMEADR, NULL, 0, 0.0, NULL, 0xb140, NULL},
{"L2_ORBIT_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xb144, NULL},
{"L2_TCSTATUS", tVMEADR, NULL, 0, 0.0, NULL, 0xb1c0, NULL},
{"L2_TCCLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xb1c8, NULL},
{"L2_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xb400, NULL},
{"L2_DELAY_L1", tVMEADR, NULL, 0, 0.0, NULL, 0xb4cc, NULL},
{"L2_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0xb5a8, NULL},
{"INT_ORBIT_READ", tVMEADR, NULL, 0, 0.0, NULL, 0xc140, NULL},
{"INT_MAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xc144, NULL},
{"INT_FIFO_MAX", tVMEADR, NULL, 0, 0.0, NULL, 0xc148, NULL},
{"INT_DDL_EMU", tVMEADR, NULL, 0, 0.0, NULL, 0xc14c, NULL},
{"INT_DISB_CTP_BUSY", tVMEADR, NULL, 0, 0.0, NULL, 0xc150, NULL},
{"I2C_MUXWR", tVMEADR, NULL, 0, 0.0, NULL, 0xc154, NULL},
{"I2C_MUXRD", tVMEADR, NULL, 0, 0.0, NULL, 0xc158, NULL},
{"I2C_ADCWR", tVMEADR, NULL, 0, 0.0, NULL, 0xc174, NULL},
{"I2C_ADCRD", tVMEADR, NULL, 0, 0.0, NULL, 0xc160, NULL},
{"I2C_SET", tVMEADR, NULL, 0, 0.0, NULL, 0xc164, NULL},
{"I2C_DATA", tVMEADR, NULL, 0, 0.0, NULL, 0xc168, NULL},
{"INT_RC_BLCKMAX", tVMEADR, NULL, 0, 0.0, NULL, 0xc16c, NULL},
{"INT_BLCKMAX_CLEAR", tVMEADR, NULL, 0, 0.0, NULL, 0xc170, NULL},
{"INT_TCSET", tVMEADR, NULL, 0, 0.0, NULL, 0xc400, NULL},
{"INT_TEST_COUNT", tVMEADR, NULL, 0, 0.0, NULL, 0xc404, NULL},
{"INT_BCOFFSET", tVMEADR, NULL, 0, 0.0, NULL, 0xc5a8, NULL},
{"readMINIMAXSel", tFUN+0x400, (funcall)readMINIMAXSel, 0xdead, 0.0, NULL, 0, readMINIMAXSel_usagehelp},
{"writeMINIMAXSel", tFUN+0x400, (funcall)writeMINIMAXSel, 0xdead, 0.0, writeMINIMAXSel_parameters, 1, writeMINIMAXSel_usagehelp},
{"writeMINIMAXClear", tFUN+0x400, (funcall)writeMINIMAXClear, 0xdead, 0.0, NULL, 0, writeMINIMAXClear_usagehelp},
{"readMINMAX", tFUN+0x400, (funcall)readMINMAX, 0xdead, 0.0, NULL, 0, readMINMAX_usagehelp},
{"readMINIMAXLimit", tFUN+0x400, (funcall)readMINIMAXLimit, 0xdead, 0.0, NULL, 0, readMINIMAXLimit_usagehelp},
{"writeMINIMAXLimit", tFUN+0x400, (funcall)writeMINIMAXLimit, 0xdead, 0.0, writeMINIMAXLimit_parameters, 1, writeMINIMAXLimit_usagehelp},
{"readBUSYlong", tFUN+0x400, (funcall)readBUSYlong, 0xdead, 0.0, readBUSYlong_parameters, 1, readBUSYlong_usagehelp},
{"busytool", tFUN+0x200, (funcall)busytool, 0xdead, 0.0, busytool_parameters, 5, busytool_usagehelp},
{"startRead3SSM", tFUN+0x200, (funcall)startRead3SSM, 0xdead, 0.0, NULL, 0, startRead3SSM_usagehelp},
{"L2a2Interface", tFUN+0x200, (funcall)L2a2Interface, 0xdead, 0.0, L2a2Interface_parameters, 3, L2a2Interface_usagehelp},
{"dumpIntSsm", tFUN+0x200, (funcall)dumpIntSsm, 0xdead, 0.0, dumpIntSsm_parameters, 1, dumpIntSsm_usagehelp},
{"dumpL2amesage", tFUN+0x200, (funcall)dumpL2amesage, 0xdead, 0.0, dumpL2amesage_parameters, 1, dumpL2amesage_usagehelp},
{"dumpCTP", tFUN+0x400, (funcall)dumpCTP, 0xdead, 0.0, NULL, 0, dumpCTP_usagehelp},
{"getPF", tFUN+0x400, (funcall)getPF, 0xdead, 0.0, getPF_parameters, 1, getPF_usagehelp},
{"getPFc", tFUN+0x400, (funcall)getPFc, 0xdead, 0.0, getPFc_parameters, 2, getPFc_usagehelp},
{"getprtPF", tFUN+0x400, (funcall)getprtPF, 0xdead, 0.0, getprtPF_parameters, 1, getprtPF_usagehelp},
{"getprtPFc", tFUN+0x400, (funcall)getprtPFc, 0xdead, 0.0, getprtPFc_parameters, 2, getprtPFc_usagehelp},
{"setPF", tFUN+0x400, (funcall)setPF, 0xdead, 0.0, setPF_parameters, 2, setPF_usagehelp},
{"setPFc", tFUN+0x400, (funcall)setPFc, 0xdead, 0.0, setPFc_parameters, 5, setPFc_usagehelp},
{"printPFwc", tFUN+0x400, (funcall)printPFwc, 0xdead, 0.0, printPFwc_parameters, 1, printPFwc_usagehelp},
{"getShared", tFUN+0x400, (funcall)getShared, 0xdead, 0.0, NULL, 0, getShared_usagehelp},
{"getSharedL0f34", tFUN+0x400, (funcall)getSharedL0f34, 0xdead, 0.0, getSharedL0f34_parameters, 1, getSharedL0f34_usagehelp},
{"setSharedL0f34", tFUN+0x400, (funcall)setSharedL0f34, 0xdead, 0.0, NULL, 0, setSharedL0f34_usagehelp},
{"setShared", tFUN+0x400, (funcall)setShared, 0xdead, 0.0, setShared_parameters, 9, setShared_usagehelp},
{"setShared2", tFUN+0x400, (funcall)setShared2, 0xdead, 0.0, setShared2_parameters, 2, setShared2_usagehelp},
{"loadRun", tFUN+0x400, (funcall)loadRun, 0xdead, 0.0, loadRun_parameters, 1, loadRun_usagehelp},
{"printHW", tFUN+0x400, (funcall)printHW, 0xdead, 0.0, NULL, 0, printHW_usagehelp},
{"unloadRun", tFUN+0x400, (funcall)unloadRun, 0xdead, 0.0, unloadRun_parameters, 1, NULL},
{"printL0FUN34", tFUN+0x400, (funcall)printL0FUN34, 0xdead, 0.0, NULL, 0, NULL},
{"notInCrate", tFUN+0x200, (funcall)notInCrate, 0xdead, 0.0, notInCrate_parameters, 1, NULL},
{"findBUSYINP", tFUN+0x200, (funcall)findBUSYINP, 0xdead, 0.0, findBUSYINP_parameters, 2, NULL},
{"findDeadBusysRuns", tFUN+0x100, (funcall)findDeadBusysRuns, 0xdead, 0.0, findDeadBusysRuns_parameters, 1, findDeadBusysRuns_usagehelp},
{"printLastDetectors", tFUN+0x400, (funcall)printLastDetectors, 0xdead, 0.0, printLastDetectors_parameters, 1, printLastDetectors_usagehelp},
{"busyprobe", tFUN+0x400, (funcall)busyprobe, 0xdead, 0.0, busyprobe_parameters, 1, busyprobe_usagehelp},
{"findDeadBusys", tFUN+0x100, (funcall)findDeadBusys, 0xdead, 0.0, findDeadBusys_parameters, 1, findDeadBusys_usagehelp},
{"GenSwtrg", tFUN+0x200, (funcall)GenSwtrg, 0xdead, 0.0, GenSwtrg_parameters, 6, NULL},
{"getCALIBBC2", tFUN+0x200, (funcall)getCALIBBC2, 0xdead, 0.0, getCALIBBC2_parameters, 1, NULL},
{"checkScopeBoard", tFUN+0x200, (funcall)checkScopeBoard, 0xdead, 0.0, checkScopeBoard_parameters, 1, NULL},
{"setScopeBoard", tFUN+0x200, (funcall)setScopeBoard, 0xdead, 0.0, setScopeBoard_parameters, 2, NULL},
{"getScopeSignal", tFUN+0x200, (funcall)getScopeSignal, 0xdead, 0.0, getScopeSignal_parameters, 2, NULL},
{"setScopeSignal", tFUN+0x200, (funcall)setScopeSignal, 0xdead, 0.0, setScopeSignal_parameters, 3, NULL},
{"getVMERWScope", tFUN+0x200, (funcall)getVMERWScope, 0xdead, 0.0, NULL, 0, NULL},
{"setVMERWScope", tFUN+0x400, (funcall)setVMERWScope, 0xdead, 0.0, setVMERWScope_parameters, 2, NULL},
{"getSWLEDS", tFUN+0x400, (funcall)getSWLEDS, 0xdead, 0.0, getSWLEDS_parameters, 1, getSWLEDS_usagehelp},
{"setEdge", tFUN+0x400, (funcall)setEdge, 0xdead, 0.0, setEdge_parameters, 3, setEdge_usagehelp},
{"setEdgeDelay", tFUN+0x400, (funcall)setEdgeDelay, 0xdead, 0.0, setEdgeDelay_parameters, 4, setEdgeDelay_usagehelp},
{"printEdgeDelay", tFUN+0x400, (funcall)printEdgeDelay, 0xdead, 0.0, printEdgeDelay_parameters, 1, printEdgeDelay_usagehelp},
{"getBCmasks", tFUN+0x400, (funcall)getBCmasks, 0xdead, 0.0, NULL, 0, getBCmasks_usagehelp},
{"setBCmasks", tFUN+0x400, (funcall)setBCmasks, 0xdead, 0.0, NULL, 0, setBCmasks_usagehelp},
{"checkBCmasks", tFUN+0x400, (funcall)checkBCmasks, 0xdead, 0.0, checkBCmasks_parameters, 2, checkBCmasks_usagehelp},
{"checkPhasesPrint", tFUN+0x400, (funcall)checkPhasesPrint, 0xdead, 0.0, NULL, 0, checkPhasesPrint_usagehelp},
{"printToggle", tFUN+0x400, (funcall)printToggle, 0xdead, 0.0, NULL, 0, NULL},
{"Toggle", tFUN+0x200, (funcall)Toggle, 0xdead, 0.0, Toggle_parameters, 2, NULL},
{"resetPLLS", tFUN+0x400, (funcall)resetPLLS, 0xdead, 0.0, NULL, 0, resetPLLS_usagehelp},
{"ReadPF", tFUN+0x400, (funcall)ReadPF, 0xdead, 0.0, NULL, 0, NULL},
{"WritePFcommon", tFUN+0x400, (funcall)WritePFcommon, 0xdead, 0.0, WritePFcommon_parameters, 3, NULL},
{"WritePF", tFUN+0x400, (funcall)WritePF, 0xdead, 0.0, WritePF_parameters, 8, NULL},
{"WritePFuser", tFUN+0x400, (funcall)WritePFuser, 0xdead, 0.0, WritePFuser_parameters, 3, WritePFuser_usagehelp},
{"WritePFuserII", tFUN+0x200, (funcall)WritePFuserII, 0xdead, 0.0, WritePFuserII_parameters, 5, NULL},
{"CTP_Classes", tFUN, NULL, 0xdead, 0.0, NULL, 0, CTP_Classes_usagehelp},
{"CTP_Clusters", tFUN, NULL, 0xdead, 0.0, NULL, 0, CTP_Clusters_usagehelp},
{"Resources", tFUN, NULL, 0xdead, 0.0, NULL, 0, Resources_usagehelp},
{"Counters", tFUN, NULL, 0xdead, 0.0, NULL, 0, Counters_usagehelp},
{"CheckTestClass", tFUN, NULL, 0xdead, 0.0, NULL, 0, CheckTestClass_usagehelp},
{"ScopeAB", tFUN, NULL, 0xdead, 0.0, NULL, 0, ScopeAB_usagehelp},
{"SSMbrowser", tFUN, NULL, 0xdead, 0.0, NULL, 0, SSMbrowser_usagehelp},
{"SSMcontrol", tFUN, NULL, 0xdead, 0.0, NULL, 0, SSMcontrol_usagehelp},
{"SaveFile", tFUN, NULL, 0xdead, 0.0, NULL, 0, SaveFile_usagehelp},
{"LoadFile", tFUN, NULL, 0xdead, 0.0, NULL, 0, LoadFile_usagehelp},
{"Readhw", tFUN, NULL, 0xdead, 0.0, NULL, 0, Readhw_usagehelp},
{"Write2hw", tFUN, NULL, 0xdead, 0.0, NULL, 0, Write2hw_usagehelp},
{"readORBIT_READs", tFUN+0x400, (funcall)readORBIT_READs, 0xdead, 0.0, NULL, 0, readORBIT_READs_usagehelp},
{"i2creadall", tFUN+0x400, (funcall)i2creadall, 0xdead, 0.0, NULL, 0, i2creadall_usagehelp},
{"setClusters", tFUN+0x400, (funcall)setClusters, 0xdead, 0.0, setClusters_parameters, 8, setClusters_usagehelp},
{"getClusters", tFUN+0x400, (funcall)getClusters, 0xdead, 0.0, NULL, 0, getClusters_usagehelp},
{"getDAQbusy", tFUN+0x400, (funcall)getDAQbusy, 0xdead, 0.0, NULL, 0, getDAQbusy_usagehelp},
{"getFO", tFUN+0x400, (funcall)getFO, 0xdead, 0.0, getFO_parameters, 1, getFO_usagehelp},
{"setFO", tFUN+0x400, (funcall)setFO, 0xdead, 0.0, setFO_parameters, 3, setFO_usagehelp},
{"setFOrocs", tFUN+0x400, (funcall)setFOrocs, 0xdead, 0.0, setFOrocs_parameters, 2, setFOrocs_usagehelp},
{"swtrigger", tFUN+0x100, (funcall)swtrigger, 0xdead, 0.0, swtrigger_parameters, 1, swtrigger_usagehelp},
{"getTCSTATUS", tFUN+0x100, (funcall)getTCSTATUS, 0xdead, 0.0, NULL, 0, getTCSTATUS_usagehelp},
{"getTCSET", tFUN+0x100, (funcall)getTCSET, 0xdead, 0.0, NULL, 0, getTCSET_usagehelp},
{"setTCSET", tFUN+0x400, (funcall)setTCSET, 0xdead, 0.0, setTCSET_parameters, 2, setTCSET_usagehelp},
{"clearTC", tFUN+0x400, (funcall)clearTC, 0xdead, 0.0, NULL, 0, clearTC_usagehelp},
{"getClass", tFUN+0x400, (funcall)getClass, 0xdead, 0.0, getClass_parameters, 1, getClass_usagehelp},
{"setClass", tFUN+0x400, (funcall)setClass, 0xdead, 0.0, setClass_parameters, 8, setClass_usagehelp},
{"disableClasses", tFUN+0x400, (funcall)disableClasses, 0xdead, 0.0, NULL, 0, disableClasses_usagehelp},
{"hw2rates", tFUN+0x400, (funcall)hw2rates, 0xdead, 0.0, NULL, 0, hw2rates_usagehelp},
{"rates2hw", tFUN+0x400, (funcall)rates2hw, 0xdead, 0.0, NULL, 0, rates2hw_usagehelp},
{"clearSPY", tFUN+0x400, (funcall)clearSPY, 0xdead, 0.0, clearSPY_parameters, 1, clearSPY_usagehelp},
{"setRates4HLTtest", tFUN+0x400, (funcall)setRates4HLTtest, 0xdead, 0.0, setRates4HLTtest_parameters, 1, setRates4HLTtest_usagehelp},
{"setEJEGA", tFUN+0x400, (funcall)setEJEGA, 0xdead, 0.0, setEJEGA_parameters, 1, setEJEGA_usagehelp},
{"testSYNCH", tFUN+0x400, (funcall)testSYNCH, 0xdead, 0.0, NULL, 0, testSYNCH_usagehelp},
{"testBCDELAY", tFUN+0x400, (funcall)testBCDELAY, 0xdead, 0.0, testBCDELAY_parameters, 1, testBCDELAY_usagehelp},
{"orbitscan", tFUN+0x400, (funcall)orbitscan, 0xdead, 0.0, orbitscan_parameters, 1, orbitscan_usagehelp},
{"setOrbitBChalf", tFUN+0x400, (funcall)setOrbitBChalf, 0xdead, 0.0, setOrbitBChalf_parameters, 1, setOrbitBChalf_usagehelp},
{"rwvmeloop", tFUN+0x400, (funcall)rwvmeloop, 0xdead, 0.0, rwvmeloop_parameters, 5, rwvmeloop_usagehelp},
{"printBoardCounters", tFUN+0x400, (funcall)printBoardCounters, 0xdead, 0.0, printBoardCounters_parameters, 2, printBoardCounters_usagehelp},
{"dumpCounters", tFUN+0x400, (funcall)dumpCounters, 0xdead, 0.0, NULL, 0, dumpCounters_usagehelp},
{"ReadTemperatures", tFUN+0x400, (funcall)ReadTemperatures, 0xdead, 0.0, NULL, 0, NULL},
{"TestLEDS", tFUN+0x400, (funcall)TestLEDS, 0xdead, 0.0, NULL, 0, NULL},
{"micsleep", tFUN+0x400, (funcall)micsleep, 0xdead, 0.0, micsleep_parameters, 1, micsleep_usagehelp},
{"RNDsync", tFUN+0x400, (funcall)RNDsync, 0xdead, 0.0, RNDsync_parameters, 1, RNDsync_usagehelp},
{"changeTL2", tFUN+0x400, (funcall)changeTL2, 0xdead, 0.0, changeTL2_parameters, 1, changeTL2_usagehelp},
{"initmain", tFUN+0x400, (funcall)initmain, 0xdead, 0.0, NULL, 0, initmain_usagehelp},
{"readstatus", tFUN+0x100, (funcall)readstatus, 0xdead, 0.0, NULL, 0, readstatus_usagehelp},
{"getCounter", tFUN+0x100, (funcall)getCounter, 0xdead, 0.0, getCounter_parameters, 3, NULL},
{"getCounters", tFUN+0x400, (funcall)getCounters, 0xdead, 0.0, getCounters_parameters, 3, NULL},
{"clearCounters", tFUN+0x400, (funcall)clearCounters, 0xdead, 0.0, clearCounters_parameters, 1, NULL},
{"l0AB", tFUN+0x200, (funcall)l0AB, 0xdead, 0.0, NULL, 0, l0AB_usagehelp},
{"DAQonoff", tFUN+0x400, (funcall)DAQonoff, 0xdead, 0.0, DAQonoff_parameters, 1, DAQonoff_usagehelp},
{"getswSSM", tFUN+0x100, (funcall)getswSSM, 0xdead, 0.0, getswSSM_parameters, 1, getswSSM_usagehelp},
{"setsmssw", tFUN+0x400, (funcall)setsmssw, 0xdead, 0.0, setsmssw_parameters, 2, setsmssw_usagehelp},
{"setomSSM", tFUN+0x200, (funcall)setomSSM, 0xdead, 0.0, setomSSM_parameters, 2, setomSSM_usagehelp},
{"startSSM1", tFUN+0x200, (funcall)startSSM1, 0xdead, 0.0, startSSM1_parameters, 1, NULL},
{"stopSSM", tFUN+0x200, (funcall)stopSSM, 0xdead, 0.0, stopSSM_parameters, 1, stopSSM_usagehelp},
{"condstopSSM", tFUN+0x200, (funcall)condstopSSM, 0xdead, 0.0, condstopSSM_parameters, 5, condstopSSM_usagehelp},
{"readSSM", tFUN+0x200, (funcall)readSSM, 0xdead, 0.0, readSSM_parameters, 1, readSSM_usagehelp},
{"writeSSM", tFUN+0x200, (funcall)writeSSM, 0xdead, 0.0, writeSSM_parameters, 1, writeSSM_usagehelp},
{"dumpSSM", tFUN+0x200, (funcall)dumpSSM, 0xdead, 0.0, dumpSSM_parameters, 2, dumpSSM_usagehelp},
{"dumpssm_compress", tFUN+0x200, (funcall)dumpssm_compress, 0xdead, 0.0, dumpssm_compress_parameters, 3, dumpssm_compress_usagehelp},
{"printSSM", tFUN+0x400, (funcall)printSSM, 0xdead, 0.0, printSSM_parameters, 2, printSSM_usagehelp},
{"readSSMDump_compress", tFUN+0x200, (funcall)readSSMDump_compress, 0xdead, 0.0, readSSMDump_compress_parameters, 3, readSSMDump_compress_usagehelp},
{"gettableSSM", tFUN+0x400, (funcall)gettableSSM, 0xdead, 0.0, NULL, 0, gettableSSM_usagehelp},
{"getsfSSM", tFUN+0x400, (funcall)getsfSSM, 0xdead, 0.0, getsfSSM_parameters, 1, getsfSSM_usagehelp},
{"getsyncedSSM", tFUN+0x400, (funcall)getsyncedSSM, 0xdead, 0.0, NULL, 0, getsyncedSSM_usagehelp},
{"getsigSSM", tFUN+0x400, (funcall)getsigSSM, 0xdead, 0.0, getsigSSM_parameters, 4, getsigSSM_usagehelp},
{"finddifSSM", tFUN+0x400, (funcall)finddifSSM, 0xdead, 0.0, finddifSSM_parameters, 3, finddifSSM_usagehelp},
{"getoffsetSSM", tFUN+0x400, (funcall)getoffsetSSM, 0xdead, 0.0, getoffsetSSM_parameters, 1, getoffsetSSM_usagehelp},
{"setoffsetSSM", tFUN+0x400, (funcall)setoffsetSSM, 0xdead, 0.0, setoffsetSSM_parameters, 2, setoffsetSSM_usagehelp},
{"setmodeSSM", tFUN+0x400, (funcall)setmodeSSM, 0xdead, 0.0, setmodeSSM_parameters, 3, setmodeSSM_usagehelp},
{"printsms", tFUN+0x400, (funcall)printsms, 0xdead, 0.0, NULL, 0, printsms_usagehelp}};
